"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws";
exports.ids = ["vendor-chunks/ws"];
exports.modules = {

/***/ "(rsc)/./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nconst WebSocket = __webpack_require__(/*! ./lib/WebSocket */ \"(rsc)/./node_modules/ws/lib/WebSocket.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/WebSocketServer */ \"(rsc)/./node_modules/ws/lib/WebSocketServer.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/Receiver */ \"(rsc)/./node_modules/ws/lib/Receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/Sender */ \"(rsc)/./node_modules/ws/lib/Sender.js\");\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEO0FBRUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUM7QUFFMUJELFVBQVVFLE1BQU0sR0FBR0QsbUJBQU9BLENBQUM7QUFDM0JELFVBQVVHLFFBQVEsR0FBR0YsbUJBQU9BLENBQUM7QUFDN0JELFVBQVVJLE1BQU0sR0FBR0gsbUJBQU9BLENBQUM7QUFFM0JJLE9BQU9DLE9BQU8sR0FBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQtYW5hbHl0aWNzLy4vbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzPzE1NGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB3czogYSBub2RlLmpzIHdlYnNvY2tldCBjbGllbnRcbiAqIENvcHlyaWdodChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi9XZWJTb2NrZXQnKTtcblxuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL1dlYlNvY2tldFNlcnZlcicpO1xuV2ViU29ja2V0LlJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvUmVjZWl2ZXInKTtcbldlYlNvY2tldC5TZW5kZXIgPSByZXF1aXJlKCcuL2xpYi9TZW5kZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiV2ViU29ja2V0IiwicmVxdWlyZSIsIlNlcnZlciIsIlJlY2VpdmVyIiwiU2VuZGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/BufferUtil.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/BufferUtil.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\");\nconst Buffer = safeBuffer.Buffer;\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */ const concat = (list, totalLength)=>{\n    const target = Buffer.allocUnsafe(totalLength);\n    var offset = 0;\n    for(var i = 0; i < list.length; i++){\n        const buf = list[i];\n        buf.copy(target, offset);\n        offset += buf.length;\n    }\n    return target;\n};\ntry {\n    const bufferUtil = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    module.exports = Object.assign({\n        concat\n    }, bufferUtil.BufferUtil || bufferUtil);\n} catch (e) /* istanbul ignore next */ {\n    /**\n   * Masks a buffer using the given mask.\n   *\n   * @param {Buffer} source The buffer to mask\n   * @param {Buffer} mask The mask to use\n   * @param {Buffer} output The buffer where to store the result\n   * @param {Number} offset The offset at which to start writing\n   * @param {Number} length The number of bytes to mask.\n   * @public\n   */ const mask = (source, mask, output, offset, length)=>{\n        for(var i = 0; i < length; i++){\n            output[offset + i] = source[i] ^ mask[i & 3];\n        }\n    };\n    /**\n   * Unmasks a buffer using the given mask.\n   *\n   * @param {Buffer} buffer The buffer to unmask\n   * @param {Buffer} mask The mask to use\n   * @public\n   */ const unmask = (buffer, mask)=>{\n        // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n        const length = buffer.length;\n        for(var i = 0; i < length; i++){\n            buffer[i] ^= mask[i & 3];\n        }\n    };\n    module.exports = {\n        concat,\n        mask,\n        unmask\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL0J1ZmZlclV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUMsU0FBU0YsV0FBV0UsTUFBTTtBQUVoQzs7Ozs7OztDQU9DLEdBQ0QsTUFBTUMsU0FBUyxDQUFDQyxNQUFNQztJQUNwQixNQUFNQyxTQUFTSixPQUFPSyxXQUFXLENBQUNGO0lBQ2xDLElBQUlHLFNBQVM7SUFFYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsS0FBS00sTUFBTSxFQUFFRCxJQUFLO1FBQ3BDLE1BQU1FLE1BQU1QLElBQUksQ0FBQ0ssRUFBRTtRQUNuQkUsSUFBSUMsSUFBSSxDQUFDTixRQUFRRTtRQUNqQkEsVUFBVUcsSUFBSUQsTUFBTTtJQUN0QjtJQUVBLE9BQU9KO0FBQ1Q7QUFFQSxJQUFJO0lBQ0YsTUFBTU8sYUFBYVosbUJBQU9BLENBQUM7SUFFM0JhLE9BQU9DLE9BQU8sR0FBR0MsT0FBT0MsTUFBTSxDQUFDO1FBQUVkO0lBQU8sR0FBR1UsV0FBV0ssVUFBVSxJQUFJTDtBQUN0RSxFQUFFLE9BQU9NLEdBQUcsd0JBQXdCLEdBQUc7SUFDckM7Ozs7Ozs7OztHQVNDLEdBQ0QsTUFBTUMsT0FBTyxDQUFDQyxRQUFRRCxNQUFNRSxRQUFRZCxRQUFRRTtRQUMxQyxJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSUMsUUFBUUQsSUFBSztZQUMvQmEsTUFBTSxDQUFDZCxTQUFTQyxFQUFFLEdBQUdZLE1BQU0sQ0FBQ1osRUFBRSxHQUFHVyxJQUFJLENBQUNYLElBQUksRUFBRTtRQUM5QztJQUNGO0lBRUE7Ozs7OztHQU1DLEdBQ0QsTUFBTWMsU0FBUyxDQUFDQyxRQUFRSjtRQUN0Qix5RUFBeUU7UUFDekUsTUFBTVYsU0FBU2MsT0FBT2QsTUFBTTtRQUM1QixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSUMsUUFBUUQsSUFBSztZQUMvQmUsTUFBTSxDQUFDZixFQUFFLElBQUlXLElBQUksQ0FBQ1gsSUFBSSxFQUFFO1FBQzFCO0lBQ0Y7SUFFQUssT0FBT0MsT0FBTyxHQUFHO1FBQUVaO1FBQVFpQjtRQUFNRztJQUFPO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0LWFuYWx5dGljcy8uL25vZGVfbW9kdWxlcy93cy9saWIvQnVmZmVyVXRpbC5qcz85MGRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogd3M6IGEgbm9kZS5qcyB3ZWJzb2NrZXQgY2xpZW50XG4gKiBDb3B5cmlnaHQoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJyk7XG5cbmNvbnN0IEJ1ZmZlciA9IHNhZmVCdWZmZXIuQnVmZmVyO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGNvbmNhdCA9IChsaXN0LCB0b3RhbExlbmd0aCkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG50cnkge1xuICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbih7IGNvbmNhdCB9LCBidWZmZXJVdGlsLkJ1ZmZlclV0aWwgfHwgYnVmZmVyVXRpbCk7XG59IGNhdGNoIChlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gIC8qKlxuICAgKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAgICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjb25zdCBtYXNrID0gKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICAgKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29uc3QgdW5tYXNrID0gKGJ1ZmZlciwgbWFzaykgPT4ge1xuICAgIC8vIFJlcXVpcmVkIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvOTAwNiBpcyByZXNvbHZlZC5cbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7IGNvbmNhdCwgbWFzaywgdW5tYXNrIH07XG59XG4iXSwibmFtZXMiOlsic2FmZUJ1ZmZlciIsInJlcXVpcmUiLCJCdWZmZXIiLCJjb25jYXQiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsImkiLCJsZW5ndGgiLCJidWYiLCJjb3B5IiwiYnVmZmVyVXRpbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJhc3NpZ24iLCJCdWZmZXJVdGlsIiwiZSIsIm1hc2siLCJzb3VyY2UiLCJvdXRwdXQiLCJ1bm1hc2siLCJidWZmZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/BufferUtil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/Constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/Constants.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\");\nconst Buffer = safeBuffer.Buffer;\nexports.BINARY_TYPES = [\n    \"nodebuffer\",\n    \"arraybuffer\",\n    \"fragments\"\n];\nexports.GUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\nexports.EMPTY_BUFFER = Buffer.alloc(0);\nexports.NOOP = ()=>{};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL0NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLFNBQVNGLFdBQVdFLE1BQU07QUFFaENDLG9CQUFvQixHQUFHO0lBQUM7SUFBYztJQUFlO0NBQVk7QUFDakVBLFlBQVksR0FBRztBQUNmQSxvQkFBb0IsR0FBR0QsT0FBT0ssS0FBSyxDQUFDO0FBQ3BDSixZQUFZLEdBQUcsS0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvd3MvbGliL0NvbnN0YW50cy5qcz8xMmE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJyk7XG5cbmNvbnN0IEJ1ZmZlciA9IHNhZmVCdWZmZXIuQnVmZmVyO1xuXG5leHBvcnRzLkJJTkFSWV9UWVBFUyA9IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXTtcbmV4cG9ydHMuR1VJRCA9ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnO1xuZXhwb3J0cy5FTVBUWV9CVUZGRVIgPSBCdWZmZXIuYWxsb2MoMCk7XG5leHBvcnRzLk5PT1AgPSAoKSA9PiB7fTtcbiJdLCJuYW1lcyI6WyJzYWZlQnVmZmVyIiwicmVxdWlyZSIsIkJ1ZmZlciIsImV4cG9ydHMiLCJCSU5BUllfVFlQRVMiLCJHVUlEIiwiRU1QVFlfQlVGRkVSIiwiYWxsb2MiLCJOT09QIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/Constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/ErrorCodes.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/ErrorCodes.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nmodule.exports = {\n    isValidErrorCode: function(code) {\n        return code >= 1000 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n    },\n    1000: \"normal\",\n    1001: \"going away\",\n    1002: \"protocol error\",\n    1003: \"unsupported data\",\n    1004: \"reserved\",\n    1005: \"reserved for extensions\",\n    1006: \"reserved for extensions\",\n    1007: \"inconsistent or invalid data\",\n    1008: \"policy violation\",\n    1009: \"message too big\",\n    1010: \"extension handshake missing\",\n    1011: \"an unexpected condition prevented the request from being fulfilled\",\n    1012: \"service restart\",\n    1013: \"try again later\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL0Vycm9yQ29kZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxrQkFBa0IsU0FBVUMsSUFBSTtRQUM5QixPQUFPLFFBQVMsUUFBUUEsUUFBUSxRQUFRQSxTQUFTLFFBQVFBLFNBQVMsUUFBUUEsU0FBUyxRQUNoRkEsUUFBUSxRQUFRQSxRQUFRO0lBQzdCO0lBQ0EsTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvd3MvbGliL0Vycm9yQ29kZXMuanM/MGQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1ZhbGlkRXJyb3JDb2RlOiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gMTAxMyAmJiBjb2RlICE9PSAxMDA0ICYmIGNvZGUgIT09IDEwMDUgJiYgY29kZSAhPT0gMTAwNikgfHxcbiAgICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbiAgfSxcbiAgMTAwMDogJ25vcm1hbCcsXG4gIDEwMDE6ICdnb2luZyBhd2F5JyxcbiAgMTAwMjogJ3Byb3RvY29sIGVycm9yJyxcbiAgMTAwMzogJ3Vuc3VwcG9ydGVkIGRhdGEnLFxuICAxMDA0OiAncmVzZXJ2ZWQnLFxuICAxMDA1OiAncmVzZXJ2ZWQgZm9yIGV4dGVuc2lvbnMnLFxuICAxMDA2OiAncmVzZXJ2ZWQgZm9yIGV4dGVuc2lvbnMnLFxuICAxMDA3OiAnaW5jb25zaXN0ZW50IG9yIGludmFsaWQgZGF0YScsXG4gIDEwMDg6ICdwb2xpY3kgdmlvbGF0aW9uJyxcbiAgMTAwOTogJ21lc3NhZ2UgdG9vIGJpZycsXG4gIDEwMTA6ICdleHRlbnNpb24gaGFuZHNoYWtlIG1pc3NpbmcnLFxuICAxMDExOiAnYW4gdW5leHBlY3RlZCBjb25kaXRpb24gcHJldmVudGVkIHRoZSByZXF1ZXN0IGZyb20gYmVpbmcgZnVsZmlsbGVkJyxcbiAgMTAxMjogJ3NlcnZpY2UgcmVzdGFydCcsXG4gIDEwMTM6ICd0cnkgYWdhaW4gbGF0ZXInXG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJpc1ZhbGlkRXJyb3JDb2RlIiwiY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/ErrorCodes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/EventTarget.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/EventTarget.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n/**\n * Class representing an event.\n *\n * @private\n */ class Event {\n    /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */ constructor(type, target){\n        this.target = target;\n        this.type = type;\n    }\n}\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */ class MessageEvent extends Event {\n    /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */ constructor(data, target){\n        super(\"message\", target);\n        this.data = data;\n    }\n}\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */ class CloseEvent extends Event {\n    /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */ constructor(code, reason, target){\n        super(\"close\", target);\n        this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n        this.reason = reason;\n        this.code = code;\n    }\n}\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */ class OpenEvent extends Event {\n    /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */ constructor(target){\n        super(\"open\", target);\n    }\n}\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */ const EventTarget = {\n    /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */ addEventListener (method, listener) {\n        if (typeof listener !== \"function\") return;\n        function onMessage(data) {\n            listener.call(this, new MessageEvent(data, this));\n        }\n        function onClose(code, message) {\n            listener.call(this, new CloseEvent(code, message, this));\n        }\n        function onError(event) {\n            event.type = \"error\";\n            event.target = this;\n            listener.call(this, event);\n        }\n        function onOpen() {\n            listener.call(this, new OpenEvent(this));\n        }\n        if (method === \"message\") {\n            onMessage._listener = listener;\n            this.on(method, onMessage);\n        } else if (method === \"close\") {\n            onClose._listener = listener;\n            this.on(method, onClose);\n        } else if (method === \"error\") {\n            onError._listener = listener;\n            this.on(method, onError);\n        } else if (method === \"open\") {\n            onOpen._listener = listener;\n            this.on(method, onOpen);\n        } else {\n            this.on(method, listener);\n        }\n    },\n    /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */ removeEventListener (method, listener) {\n        const listeners = this.listeners(method);\n        for(var i = 0; i < listeners.length; i++){\n            if (listeners[i] === listener || listeners[i]._listener === listener) {\n                this.removeListener(method, listeners[i]);\n            }\n        }\n    }\n};\nmodule.exports = EventTarget;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL0V2ZW50VGFyZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1BO0lBQ0o7Ozs7O0dBS0MsR0FDREMsWUFBYUMsSUFBSSxFQUFFQyxNQUFNLENBQUU7UUFDekIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRCxJQUFJLEdBQUdBO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUUscUJBQXFCSjtJQUN6Qjs7Ozs7R0FLQyxHQUNEQyxZQUFhSSxJQUFJLEVBQUVGLE1BQU0sQ0FBRTtRQUN6QixLQUFLLENBQUMsV0FBV0E7UUFFakIsSUFBSSxDQUFDRSxJQUFJLEdBQUdBO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUMsbUJBQW1CTjtJQUN2Qjs7Ozs7O0dBTUMsR0FDREMsWUFBYU0sSUFBSSxFQUFFQyxNQUFNLEVBQUVMLE1BQU0sQ0FBRTtRQUNqQyxLQUFLLENBQUMsU0FBU0E7UUFFZixJQUFJLENBQUNNLFFBQVEsR0FBR04sT0FBT08sbUJBQW1CLElBQUlQLE9BQU9RLGVBQWU7UUFDcEUsSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRCxJQUFJLEdBQUdBO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUssa0JBQWtCWjtJQUN0Qjs7OztHQUlDLEdBQ0RDLFlBQWFFLE1BQU0sQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUUE7SUFDaEI7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTVUsY0FBYztJQUNsQjs7Ozs7O0dBTUMsR0FDREMsa0JBQWtCQyxNQUFNLEVBQUVDLFFBQVE7UUFDaEMsSUFBSSxPQUFPQSxhQUFhLFlBQVk7UUFFcEMsU0FBU0MsVUFBV1osSUFBSTtZQUN0QlcsU0FBU0UsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJZCxhQUFhQyxNQUFNLElBQUk7UUFDakQ7UUFFQSxTQUFTYyxRQUFTWixJQUFJLEVBQUVhLE9BQU87WUFDN0JKLFNBQVNFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSVosV0FBV0MsTUFBTWEsU0FBUyxJQUFJO1FBQ3hEO1FBRUEsU0FBU0MsUUFBU0MsS0FBSztZQUNyQkEsTUFBTXBCLElBQUksR0FBRztZQUNib0IsTUFBTW5CLE1BQU0sR0FBRyxJQUFJO1lBQ25CYSxTQUFTRSxJQUFJLENBQUMsSUFBSSxFQUFFSTtRQUN0QjtRQUVBLFNBQVNDO1lBQ1BQLFNBQVNFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSU4sVUFBVSxJQUFJO1FBQ3hDO1FBRUEsSUFBSUcsV0FBVyxXQUFXO1lBQ3hCRSxVQUFVTyxTQUFTLEdBQUdSO1lBQ3RCLElBQUksQ0FBQ1MsRUFBRSxDQUFDVixRQUFRRTtRQUNsQixPQUFPLElBQUlGLFdBQVcsU0FBUztZQUM3QkksUUFBUUssU0FBUyxHQUFHUjtZQUNwQixJQUFJLENBQUNTLEVBQUUsQ0FBQ1YsUUFBUUk7UUFDbEIsT0FBTyxJQUFJSixXQUFXLFNBQVM7WUFDN0JNLFFBQVFHLFNBQVMsR0FBR1I7WUFDcEIsSUFBSSxDQUFDUyxFQUFFLENBQUNWLFFBQVFNO1FBQ2xCLE9BQU8sSUFBSU4sV0FBVyxRQUFRO1lBQzVCUSxPQUFPQyxTQUFTLEdBQUdSO1lBQ25CLElBQUksQ0FBQ1MsRUFBRSxDQUFDVixRQUFRUTtRQUNsQixPQUFPO1lBQ0wsSUFBSSxDQUFDRSxFQUFFLENBQUNWLFFBQVFDO1FBQ2xCO0lBQ0Y7SUFFQTs7Ozs7O0dBTUMsR0FDRFUscUJBQXFCWCxNQUFNLEVBQUVDLFFBQVE7UUFDbkMsTUFBTVcsWUFBWSxJQUFJLENBQUNBLFNBQVMsQ0FBQ1o7UUFFakMsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUlELFVBQVVFLE1BQU0sRUFBRUQsSUFBSztZQUN6QyxJQUFJRCxTQUFTLENBQUNDLEVBQUUsS0FBS1osWUFBWVcsU0FBUyxDQUFDQyxFQUFFLENBQUNKLFNBQVMsS0FBS1IsVUFBVTtnQkFDcEUsSUFBSSxDQUFDYyxjQUFjLENBQUNmLFFBQVFZLFNBQVMsQ0FBQ0MsRUFBRTtZQUMxQztRQUNGO0lBQ0Y7QUFDRjtBQUVBRyxPQUFPQyxPQUFPLEdBQUduQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvd3MvbGliL0V2ZW50VGFyZ2V0LmpzPzkzZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgcmVjZWl2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGF0YSwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ21lc3NhZ2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvZGUsIHJlYXNvbiwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ2Nsb3NlJywgdGFyZ2V0KTtcblxuICAgIHRoaXMud2FzQ2xlYW4gPSB0YXJnZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0YXJnZXQuX2Nsb3NlRnJhbWVTZW50O1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gb3BlbiBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgT3BlbkV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBPcGVuRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGFyZ2V0KSB7XG4gICAgc3VwZXIoJ29wZW4nLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIgKG1ldGhvZCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UgKGRhdGEpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IE1lc3NhZ2VFdmVudChkYXRhLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZSAoY29kZSwgbWVzc2FnZSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgQ2xvc2VFdmVudChjb2RlLCBtZXNzYWdlLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvciAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSAnZXJyb3InO1xuICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3BlbiAoKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBPcGVuRXZlbnQodGhpcykpO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QgPT09ICdtZXNzYWdlJykge1xuICAgICAgb25NZXNzYWdlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpcy5vbihtZXRob2QsIG9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdjbG9zZScpIHtcbiAgICAgIG9uQ2xvc2UuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgb25DbG9zZSk7XG4gICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdlcnJvcicpIHtcbiAgICAgIG9uRXJyb3IuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgb25FcnJvcik7XG4gICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdvcGVuJykge1xuICAgICAgb25PcGVuLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpcy5vbihtZXRob2QsIG9uT3Blbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24obWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIgKG1ldGhvZCwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbiJdLCJuYW1lcyI6WyJFdmVudCIsImNvbnN0cnVjdG9yIiwidHlwZSIsInRhcmdldCIsIk1lc3NhZ2VFdmVudCIsImRhdGEiLCJDbG9zZUV2ZW50IiwiY29kZSIsInJlYXNvbiIsIndhc0NsZWFuIiwiX2Nsb3NlRnJhbWVSZWNlaXZlZCIsIl9jbG9zZUZyYW1lU2VudCIsIk9wZW5FdmVudCIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1ldGhvZCIsImxpc3RlbmVyIiwib25NZXNzYWdlIiwiY2FsbCIsIm9uQ2xvc2UiLCJtZXNzYWdlIiwib25FcnJvciIsImV2ZW50Iiwib25PcGVuIiwiX2xpc3RlbmVyIiwib24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuZXJzIiwiaSIsImxlbmd0aCIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/EventTarget.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/Extensions.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/Extensions.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\nconst tokenChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0 // 112 - 127\n];\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */ function push(dest, name, elem) {\n    if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\n    else dest[name] = [\n        elem\n    ];\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */ function parse(header) {\n    const offers = {};\n    if (header === undefined || header === \"\") return offers;\n    var params = {};\n    var mustUnescape = false;\n    var isEscaping = false;\n    var inQuotes = false;\n    var extensionName;\n    var paramName;\n    var start = -1;\n    var end = -1;\n    for(var i = 0; i < header.length; i++){\n        const code = header.charCodeAt(i);\n        if (extensionName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 /* ' ' */  || code === 0x09 /* '\\t' */ ) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                if (start === -1) throw new Error(`unexpected character at index ${i}`);\n                if (end === -1) end = i;\n                const name = header.slice(start, end);\n                if (code === 0x2c) {\n                    push(offers, name, params);\n                    params = {};\n                } else {\n                    extensionName = name;\n                }\n                start = end = -1;\n            } else {\n                throw new Error(`unexpected character at index ${i}`);\n            }\n        } else if (paramName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 || code === 0x09) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) throw new Error(`unexpected character at index ${i}`);\n                if (end === -1) end = i;\n                push(params, header.slice(start, end), true);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = {};\n                    extensionName = undefined;\n                }\n                start = end = -1;\n            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                paramName = header.slice(start, i);\n                start = end = -1;\n            } else {\n                throw new Error(`unexpected character at index ${i}`);\n            }\n        } else {\n            //\n            // The value of a quoted-string after unescaping must conform to the\n            // token ABNF, so only token characters are valid.\n            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n            //\n            if (isEscaping) {\n                if (tokenChars[code] !== 1) {\n                    throw new Error(`unexpected character at index ${i}`);\n                }\n                if (start === -1) start = i;\n                else if (!mustUnescape) mustUnescape = true;\n                isEscaping = false;\n            } else if (inQuotes) {\n                if (tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                    inQuotes = false;\n                    end = i;\n                } else if (code === 0x5c /* '\\' */ ) {\n                    isEscaping = true;\n                } else {\n                    throw new Error(`unexpected character at index ${i}`);\n                }\n            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                inQuotes = true;\n            } else if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                if (end === -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) throw new Error(`unexpected character at index ${i}`);\n                if (end === -1) end = i;\n                var value = header.slice(start, end);\n                if (mustUnescape) {\n                    value = value.replace(/\\\\/g, \"\");\n                    mustUnescape = false;\n                }\n                push(params, paramName, value);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = {};\n                    extensionName = undefined;\n                }\n                paramName = undefined;\n                start = end = -1;\n            } else {\n                throw new Error(`unexpected character at index ${i}`);\n            }\n        }\n    }\n    if (start === -1 || inQuotes) throw new Error(\"unexpected end of input\");\n    if (end === -1) end = i;\n    const token = header.slice(start, end);\n    if (extensionName === undefined) {\n        push(offers, token, {});\n    } else {\n        if (paramName === undefined) {\n            push(params, token, true);\n        } else if (mustUnescape) {\n            push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n            push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n    }\n    return offers;\n}\n/**\n * Serializes a parsed `Sec-WebSocket-Extensions` header to a string.\n *\n * @param {Object} value The object to format\n * @return {String} A string representing the given value\n * @public\n */ function format(value) {\n    return Object.keys(value).map((token)=>{\n        var paramsList = value[token];\n        if (!Array.isArray(paramsList)) paramsList = [\n            paramsList\n        ];\n        return paramsList.map((params)=>{\n            return [\n                token\n            ].concat(Object.keys(params).map((k)=>{\n                var p = params[k];\n                if (!Array.isArray(p)) p = [\n                    p\n                ];\n                return p.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n            })).join(\"; \");\n        }).join(\", \");\n    }).join(\", \");\n}\nmodule.exports = {\n    format,\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL0V4dGVuc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRiwrQ0FBK0M7QUFDL0MsOENBQThDO0FBQzlDLEVBQUU7QUFDRiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixNQUFNO0FBQ04sRUFBRTtBQUNGLE1BQU1BLGFBQWE7SUFDakI7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsRUFBRSxZQUFZO0NBQzVEO0FBRUQ7Ozs7Ozs7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QUNwQixPQUFPdEIsT0FBTzBCLElBQUksQ0FBQ0osT0FBT0ssR0FBRyxDQUFDLENBQUNIO1FBQzdCLElBQUlJLGFBQWFOLEtBQUssQ0FBQ0UsTUFBTTtRQUM3QixJQUFJLENBQUNLLE1BQU1DLE9BQU8sQ0FBQ0YsYUFBYUEsYUFBYTtZQUFDQTtTQUFXO1FBQ3pELE9BQU9BLFdBQVdELEdBQUcsQ0FBQyxDQUFDbkI7WUFDckIsT0FBTztnQkFBQ2dCO2FBQU0sQ0FBQ08sTUFBTSxDQUFDL0IsT0FBTzBCLElBQUksQ0FBQ2xCLFFBQVFtQixHQUFHLENBQUMsQ0FBQ0s7Z0JBQzdDLElBQUlDLElBQUl6QixNQUFNLENBQUN3QixFQUFFO2dCQUNqQixJQUFJLENBQUNILE1BQU1DLE9BQU8sQ0FBQ0csSUFBSUEsSUFBSTtvQkFBQ0E7aUJBQUU7Z0JBQzlCLE9BQU9BLEVBQUVOLEdBQUcsQ0FBQyxDQUFDTyxJQUFNQSxNQUFNLE9BQU9GLElBQUksQ0FBQyxFQUFFQSxFQUFFLENBQUMsRUFBRUUsRUFBRSxDQUFDLEVBQUVDLElBQUksQ0FBQztZQUN6RCxJQUFJQSxJQUFJLENBQUM7UUFDWCxHQUFHQSxJQUFJLENBQUM7SUFDVixHQUFHQSxJQUFJLENBQUM7QUFDVjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFBRVo7SUFBUXJCO0FBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQtYW5hbHl0aWNzLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9FeHRlbnNpb25zLmpzP2UxOWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoIChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVzdCwgbmFtZSkpIGRlc3RbbmFtZV0ucHVzaChlbGVtKTtcbiAgZWxzZSBkZXN0W25hbWVdID0gW2VsZW1dO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UgKGhlYWRlcikge1xuICBjb25zdCBvZmZlcnMgPSB7fTtcblxuICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgaGVhZGVyID09PSAnJykgcmV0dXJuIG9mZmVycztcblxuICB2YXIgcGFyYW1zID0ge307XG4gIHZhciBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgdmFyIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgdmFyIGluUXVvdGVzID0gZmFsc2U7XG4gIHZhciBleHRlbnNpb25OYW1lO1xuICB2YXIgcGFyYW1OYW1lO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAvKiAnICcgKi98fCBjb2RlID09PSAweDA5LyogJ1xcdCcgKi8pIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QvKiAnPScgKi8mJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1Yy8qICdcXCcgKi8pIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcykgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuXG4gIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICBjb25zdCB0b2tlbiA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwge30pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgcGFyc2VkIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIG9iamVjdCB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmb3JtYXQgKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKCh0b2tlbikgPT4ge1xuICAgIHZhciBwYXJhbXNMaXN0ID0gdmFsdWVbdG9rZW5dO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXNMaXN0KSkgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcbiAgICByZXR1cm4gcGFyYW1zTGlzdC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgcmV0dXJuIFt0b2tlbl0uY29uY2F0KE9iamVjdC5rZXlzKHBhcmFtcykubWFwKChrKSA9PiB7XG4gICAgICAgIHZhciBwID0gcGFyYW1zW2tdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocCkpIHAgPSBbcF07XG4gICAgICAgIHJldHVybiBwLm1hcCgodikgPT4gdiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkuam9pbignOyAnKTtcbiAgICAgIH0pKS5qb2luKCc7ICcpO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gIH0pLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInB1c2giLCJkZXN0IiwibmFtZSIsImVsZW0iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwYXJzZSIsImhlYWRlciIsIm9mZmVycyIsInVuZGVmaW5lZCIsInBhcmFtcyIsIm11c3RVbmVzY2FwZSIsImlzRXNjYXBpbmciLCJpblF1b3RlcyIsImV4dGVuc2lvbk5hbWUiLCJwYXJhbU5hbWUiLCJzdGFydCIsImVuZCIsImkiLCJsZW5ndGgiLCJjb2RlIiwiY2hhckNvZGVBdCIsIkVycm9yIiwic2xpY2UiLCJ2YWx1ZSIsInJlcGxhY2UiLCJ0b2tlbiIsImZvcm1hdCIsImtleXMiLCJtYXAiLCJwYXJhbXNMaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwiayIsInAiLCJ2Iiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/Extensions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/PerMessageDeflate.js":
/*!**************************************************!*\
  !*** ./node_modules/ws/lib/PerMessageDeflate.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\");\nconst Limiter = __webpack_require__(/*! async-limiter */ \"(rsc)/./node_modules/async-limiter/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"(rsc)/./node_modules/ws/lib/BufferUtil.js\");\nconst Buffer = safeBuffer.Buffer;\nconst TRAILER = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst EMPTY_BLOCK = Buffer.from([\n    0x00\n]);\nconst kWriteInProgress = Symbol(\"write-in-progress\");\nconst kPendingClose = Symbol(\"pending-close\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError = Symbol(\"error\");\nconst kOwner = Symbol(\"owner\");\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */ class PerMessageDeflate {\n    /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Number} options.level The value of zlib's `level` param\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */ constructor(options, isServer, maxPayload){\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n            zlibLimiter = new Limiter({\n                concurrency\n            });\n        }\n    }\n    /**\n   * @type {String}\n   */ static get extensionName() {\n        return \"permessage-deflate\";\n    }\n    /**\n   * Create extension parameters offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */ offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n            params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n            params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n            params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n            params.client_max_window_bits = true;\n        }\n        return params;\n    }\n    /**\n   * Accept extension offer.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @public\n   */ accept(paramsList) {\n        paramsList = this.normalizeParams(paramsList);\n        var params;\n        if (this._isServer) {\n            params = this.acceptAsServer(paramsList);\n        } else {\n            params = this.acceptAsClient(paramsList);\n        }\n        this.params = params;\n        return params;\n    }\n    /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */ cleanup() {\n        if (this._inflate) {\n            if (this._inflate[kWriteInProgress]) {\n                this._inflate[kPendingClose] = true;\n            } else {\n                this._inflate.close();\n                this._inflate = null;\n            }\n        }\n        if (this._deflate) {\n            if (this._deflate[kWriteInProgress]) {\n                this._deflate[kPendingClose] = true;\n            } else {\n                this._deflate.close();\n                this._deflate = null;\n            }\n        }\n    }\n    /**\n   * Accept extension offer from client.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsServer(paramsList) {\n        const accepted = {};\n        const result = paramsList.some((params)=>{\n            if (this._options.serverNoContextTakeover === false && params.server_no_context_takeover || this._options.serverMaxWindowBits === false && params.server_max_window_bits || typeof this._options.serverMaxWindowBits === \"number\" && typeof params.server_max_window_bits === \"number\" && this._options.serverMaxWindowBits > params.server_max_window_bits || typeof this._options.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                return;\n            }\n            if (this._options.serverNoContextTakeover || params.server_no_context_takeover) {\n                accepted.server_no_context_takeover = true;\n            }\n            if (this._options.clientNoContextTakeover || this._options.clientNoContextTakeover !== false && params.client_no_context_takeover) {\n                accepted.client_no_context_takeover = true;\n            }\n            if (typeof this._options.serverMaxWindowBits === \"number\") {\n                accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n            } else if (typeof params.server_max_window_bits === \"number\") {\n                accepted.server_max_window_bits = params.server_max_window_bits;\n            }\n            if (typeof this._options.clientMaxWindowBits === \"number\") {\n                accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n            } else if (this._options.clientMaxWindowBits !== false && typeof params.client_max_window_bits === \"number\") {\n                accepted.client_max_window_bits = params.client_max_window_bits;\n            }\n            return true;\n        });\n        if (!result) throw new Error(\"Doesn't support the offered configuration\");\n        return accepted;\n    }\n    /**\n   * Accept extension response from server.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsClient(paramsList) {\n        const params = paramsList[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n            throw new Error('Invalid value for \"client_no_context_takeover\"');\n        }\n        if (typeof this._options.clientMaxWindowBits === \"number\" && (!params.client_max_window_bits || params.client_max_window_bits > this._options.clientMaxWindowBits) || this._options.clientMaxWindowBits === false && params.client_max_window_bits) {\n            throw new Error('Invalid value for \"client_max_window_bits\"');\n        }\n        return params;\n    }\n    /**\n   * Normalize extensions parameters.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Array} Normalized extensions parameters\n   * @private\n   */ normalizeParams(paramsList) {\n        return paramsList.map((params)=>{\n            Object.keys(params).forEach((key)=>{\n                var value = params[key];\n                if (value.length > 1) {\n                    throw new Error(`Multiple extension parameters for ${key}`);\n                }\n                value = value[0];\n                switch(key){\n                    case \"server_no_context_takeover\":\n                    case \"client_no_context_takeover\":\n                        if (value !== true) {\n                            throw new Error(`invalid extension parameter value for ${key} (${value})`);\n                        }\n                        params[key] = true;\n                        break;\n                    case \"server_max_window_bits\":\n                    case \"client_max_window_bits\":\n                        if (typeof value === \"string\") {\n                            value = parseInt(value, 10);\n                            if (Number.isNaN(value) || value < zlib.Z_MIN_WINDOWBITS || value > zlib.Z_MAX_WINDOWBITS) {\n                                throw new Error(`invalid extension parameter value for ${key} (${value})`);\n                            }\n                        }\n                        if (!this._isServer && value === true) {\n                            throw new Error(`Missing extension parameter value for ${key}`);\n                        }\n                        params[key] = value;\n                        break;\n                    default:\n                        throw new Error(`Not defined extension parameter (${key})`);\n                }\n            });\n            return params;\n        });\n    }\n    /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ decompress(data, fin, callback) {\n        zlibLimiter.push((done)=>{\n            this._decompress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ compress(data, fin, callback) {\n        zlibLimiter.push((done)=>{\n            this._compress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._inflate = zlib.createInflateRaw({\n                windowBits\n            });\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            this._inflate[kOwner] = this;\n            this._inflate.on(\"error\", inflateOnError);\n            this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate[kWriteInProgress] = true;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(()=>{\n            const err = this._inflate[kError];\n            if (err) {\n                this._inflate.close();\n                this._inflate = null;\n                callback(err);\n                return;\n            }\n            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n            if (fin && this.params[`${endpoint}_no_context_takeover`] || this._inflate[kPendingClose]) {\n                this._inflate.close();\n                this._inflate = null;\n            } else {\n                this._inflate[kWriteInProgress] = false;\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n            }\n            callback(null, data);\n        });\n    }\n    /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _compress(data, fin, callback) {\n        if (!data || data.length === 0) {\n            process.nextTick(callback, null, EMPTY_BLOCK);\n            return;\n        }\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._deflate = zlib.createDeflateRaw({\n                memLevel: this._options.memLevel,\n                level: this._options.level,\n                flush: zlib.Z_SYNC_FLUSH,\n                windowBits\n            });\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            //\n            // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n            // it is made after it has already been closed. This cannot happen here,\n            // so we only add a listener for the `'data'` event.\n            //\n            this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kWriteInProgress] = true;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n            var data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n            if (fin) data = data.slice(0, data.length - 4);\n            if (fin && this.params[`${endpoint}_no_context_takeover`] || this._deflate[kPendingClose]) {\n                this._deflate.close();\n                this._deflate = null;\n            } else {\n                this._deflate[kWriteInProgress] = false;\n                this._deflate[kTotalLength] = 0;\n                this._deflate[kBuffers] = [];\n            }\n            callback(null, data);\n        });\n    }\n}\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function deflateOnData(chunk) {\n    this[kBuffers].push(chunk);\n    this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function inflateOnData(chunk) {\n    this[kTotalLength] += chunk.length;\n    if (this[kOwner]._maxPayload < 1 || this[kTotalLength] <= this[kOwner]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n    }\n    this[kError] = new Error(\"max payload size exceeded\");\n    this[kError].closeCode = 1009;\n    this.removeListener(\"data\", inflateOnData);\n    this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */ function inflateOnError(err) {\n    //\n    // There is no need to call `Zlib#close()` as the handle is automatically\n    // closed when an error is emitted.\n    //\n    this[kOwner]._inflate = null;\n    this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL1Blck1lc3NhZ2VEZWZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFFckIsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUksU0FBU0wsV0FBV0ssTUFBTTtBQUVoQyxNQUFNQyxVQUFVRCxPQUFPRSxJQUFJLENBQUM7SUFBQztJQUFNO0lBQU07SUFBTTtDQUFLO0FBQ3BELE1BQU1DLGNBQWNILE9BQU9FLElBQUksQ0FBQztJQUFDO0NBQUs7QUFFdEMsTUFBTUUsbUJBQW1CQyxPQUFPO0FBQ2hDLE1BQU1DLGdCQUFnQkQsT0FBTztBQUM3QixNQUFNRSxlQUFlRixPQUFPO0FBQzVCLE1BQU1HLFlBQVlILE9BQU87QUFDekIsTUFBTUksV0FBV0osT0FBTztBQUN4QixNQUFNSyxTQUFTTCxPQUFPO0FBQ3RCLE1BQU1NLFNBQVNOLE9BQU87QUFFdEIsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSxxRkFBcUY7QUFDckYsbURBQW1EO0FBQ25ELEVBQUU7QUFDRixxRUFBcUU7QUFDckUsRUFBRTtBQUNGLElBQUlPO0FBRUo7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkMsR0FDREMsWUFBYUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUMxQyxJQUFJLENBQUNDLFdBQVcsR0FBR0QsYUFBYTtRQUNoQyxJQUFJLENBQUNFLFFBQVEsR0FBR0osV0FBVyxDQUFDO1FBQzVCLElBQUksQ0FBQ0ssVUFBVSxHQUFHLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxTQUFTLEtBQUtDLFlBQzFDLElBQUksQ0FBQ0gsUUFBUSxDQUFDRSxTQUFTLEdBQ3ZCO1FBQ0osSUFBSSxDQUFDRSxTQUFTLEdBQUcsQ0FBQyxDQUFD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QUcsRUFBRTtZQUM5QjtZQUVBd0QsU0FBUyxNQUFNRjtRQUNqQjtJQUNGO0FBQ0Y7QUFFQTJCLE9BQU9DLE9BQU8sR0FBRzlFO0FBRWpCOzs7OztDQUtDLEdBQ0QsU0FBUzJFLGNBQWVJLEtBQUs7SUFDM0IsSUFBSSxDQUFDbkYsU0FBUyxDQUFDeUQsSUFBSSxDQUFDMEI7SUFDcEIsSUFBSSxDQUFDckYsYUFBYSxJQUFJcUYsTUFBTXBDLE1BQU07QUFDcEM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNzQixjQUFlYyxLQUFLO0lBQzNCLElBQUksQ0FBQ3JGLGFBQWEsSUFBSXFGLE1BQU1wQyxNQUFNO0lBRWxDLElBQ0UsSUFBSSxDQUFDN0MsT0FBTyxDQUFDTyxXQUFXLEdBQUcsS0FDM0IsSUFBSSxDQUFDWCxhQUFhLElBQUksSUFBSSxDQUFDSSxPQUFPLENBQUNPLFdBQVcsRUFDOUM7UUFDQSxJQUFJLENBQUNULFNBQVMsQ0FBQ3lELElBQUksQ0FBQzBCO1FBQ3BCO0lBQ0Y7SUFFQSxJQUFJLENBQUNsRixPQUFPLEdBQUcsSUFBSXVDLE1BQU07SUFDekIsSUFBSSxDQUFDdkMsT0FBTyxDQUFDbUYsU0FBUyxHQUFHO0lBQ3pCLElBQUksQ0FBQ0MsY0FBYyxDQUFDLFFBQVFoQjtJQUM1QixJQUFJLENBQUNpQixLQUFLO0FBQ1o7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNsQixlQUFnQlIsR0FBRztJQUMxQixFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLG1DQUFtQztJQUNuQyxFQUFFO0lBQ0YsSUFBSSxDQUFDMUQsT0FBTyxDQUFDYyxRQUFRLEdBQUc7SUFDeEIsSUFBSSxDQUFDakIsVUFBVSxDQUFDNkQ7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQtYW5hbHl0aWNzLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9QZXJNZXNzYWdlRGVmbGF0ZS5qcz9kMzgzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnYXN5bmMtbGltaXRlcicpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vQnVmZmVyVXRpbCcpO1xuXG5jb25zdCBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlcjtcblxuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBFTVBUWV9CTE9DSyA9IEJ1ZmZlci5mcm9tKFsweDAwXSk7XG5cbmNvbnN0IGtXcml0ZUluUHJvZ3Jlc3MgPSBTeW1ib2woJ3dyaXRlLWluLXByb2dyZXNzJyk7XG5jb25zdCBrUGVuZGluZ0Nsb3NlID0gU3ltYm9sKCdwZW5kaW5nLWNsb3NlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbmNvbnN0IGtPd25lciA9IFN5bWJvbCgnb3duZXInKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyIFJlcXVlc3QvYWNjZXB0IGRpc2FibGluZ1xuICAgKiAgICAgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyIEFkdmVydGlzZS9hY2tub3dsZWRnZVxuICAgKiAgICAgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmxldmVsIFRoZSB2YWx1ZSBvZiB6bGliJ3MgYGxldmVsYCBwYXJhbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tZW1MZXZlbCBUaGUgdmFsdWUgb2YgemxpYidzIGBtZW1MZXZlbGAgcGFyYW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMudGhyZXNob2xkIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaCBtZXNzYWdlc1xuICAgKiAgICAgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgVGhlIG51bWJlciBvZiBjb25jdXJyZW50IGNhbGxzIHRvXG4gICAqICAgICB6bGliXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNTZXJ2ZXIgQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yIGNsaWVudFxuICAgKiAgICAgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID0gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZFxuICAgICAgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZFxuICAgICAgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcbiAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoeyBjb25jdXJyZW5jeSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSAoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBleHRlbnNpb24gcGFyYW1ldGVycyBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlciAoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgZXh0ZW5zaW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNMaXN0IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQgKHBhcmFtc0xpc3QpIHtcbiAgICBwYXJhbXNMaXN0ID0gdGhpcy5ub3JtYWxpemVQYXJhbXMocGFyYW1zTGlzdCk7XG5cbiAgICB2YXIgcGFyYW1zO1xuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgcGFyYW1zID0gdGhpcy5hY2NlcHRBc1NlcnZlcihwYXJhbXNMaXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zID0gdGhpcy5hY2NlcHRBc0NsaWVudChwYXJhbXNMaXN0KTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwICgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX2luZmxhdGVba1dyaXRlSW5Qcm9ncmVzc10pIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrUGVuZGluZ0Nsb3NlXSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX2RlZmxhdGVba1dyaXRlSW5Qcm9ncmVzc10pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrUGVuZGluZ0Nsb3NlXSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgZXh0ZW5zaW9uIG9mZmVyIGZyb20gY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNMaXN0IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIgKHBhcmFtc0xpc3QpIHtcbiAgICBjb25zdCBhY2NlcHRlZCA9IHt9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcmFtc0xpc3Quc29tZSgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykgfHxcbiAgICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgdHlwZW9mIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSB8fFxuICAgICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgfHxcbiAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgICApIHtcbiAgICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyIHx8XG4gICAgICAgICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyICE9PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcilcbiAgICAgICkge1xuICAgICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHM7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyAhPT0gZmFsc2UgJiZcbiAgICAgICAgdHlwZW9mIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSAnbnVtYmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQpIHRocm93IG5ldyBFcnJvcihcIkRvZXNuJ3Qgc3VwcG9ydCB0aGUgb2ZmZXJlZCBjb25maWd1cmF0aW9uXCIpO1xuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBleHRlbnNpb24gcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc0xpc3QgRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudCAocGFyYW1zTGlzdCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHBhcmFtc0xpc3RbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzIHx8XG4gICAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpKSB8fFxuICAgICAgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgZXh0ZW5zaW9ucyBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNMaXN0IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm4ge0FycmF5fSBOb3JtYWxpemVkIGV4dGVuc2lvbnMgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zIChwYXJhbXNMaXN0KSB7XG4gICAgcmV0dXJuIHBhcmFtc0xpc3QubWFwKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJzpcbiAgICAgICAgICBjYXNlICdjbGllbnRfbm9fY29udGV4dF90YWtlb3Zlcic6XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGV4dGVuc2lvbiBwYXJhbWV0ZXIgdmFsdWUgZm9yICR7a2V5fSAoJHt2YWx1ZX0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJzpcbiAgICAgICAgICBjYXNlICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSA8IHpsaWIuWl9NSU5fV0lORE9XQklUUyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID4gemxpYi5aX01BWF9XSU5ET1dCSVRTXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBleHRlbnNpb24gcGFyYW1ldGVyIHZhbHVlIGZvciAke2tleX0gKCR7dmFsdWV9KWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU2VydmVyICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBleHRlbnNpb24gcGFyYW1ldGVyIHZhbHVlIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZGVmaW5lZCBleHRlbnNpb24gcGFyYW1ldGVyICgke2tleX0pYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQgYnkgYXN5bmMtbGltaXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MgKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5wdXNoKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZCBieSBhc3luYy1saW1pdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzIChkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIucHVzaCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MgKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID0gdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoeyB3aW5kb3dCaXRzIH0pO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlW2tPd25lcl0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5faW5mbGF0ZVtrV3JpdGVJblByb2dyZXNzXSA9IHRydWU7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKFxuICAgICAgICAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHx8XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1BlbmRpbmdDbG9zZV1cbiAgICAgICkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrV3JpdGVJblByb2dyZXNzXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MgKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG51bGwsIEVNUFRZX0JMT0NLKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID0gdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICBtZW1MZXZlbDogdGhpcy5fb3B0aW9ucy5tZW1MZXZlbCxcbiAgICAgICAgbGV2ZWw6IHRoaXMuX29wdGlvbnMubGV2ZWwsXG4gICAgICAgIGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAvL1xuICAgICAgLy8gYHpsaWIuRGVmbGF0ZVJhd2AgZW1pdHMgYW4gYCdlcnJvcidgIGV2ZW50IG9ubHkgd2hlbiBhbiBhdHRlbXB0IHRvIHVzZVxuICAgICAgLy8gaXQgaXMgbWFkZSBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4gVGhpcyBjYW5ub3QgaGFwcGVuIGhlcmUsXG4gICAgICAvLyBzbyB3ZSBvbmx5IGFkZCBhIGxpc3RlbmVyIGZvciB0aGUgYCdkYXRhJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba1dyaXRlSW5Qcm9ncmVzc10gPSB0cnVlO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICB2YXIgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSBkYXRhID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIDQpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkgfHxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrUGVuZGluZ0Nsb3NlXVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWZsYXRlW2tXcml0ZUluUHJvZ3Jlc3NdID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YSAoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YSAoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trT3duZXJdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tPd25lcl0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IEVycm9yKCdtYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jbG9zZUNvZGUgPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvciAoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trT3duZXJdLl9pbmZsYXRlID0gbnVsbDtcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOlsic2FmZUJ1ZmZlciIsInJlcXVpcmUiLCJMaW1pdGVyIiwiemxpYiIsImJ1ZmZlclV0aWwiLCJCdWZmZXIiLCJUUkFJTEVSIiwiZnJvbSIsIkVNUFRZX0JMT0NLIiwia1dyaXRlSW5Qcm9ncmVzcyIsIlN5bWJvbCIsImtQZW5kaW5nQ2xvc2UiLCJrVG90YWxMZW5ndGgiLCJrQ2FsbGJhY2siLCJrQnVmZmVycyIsImtFcnJvciIsImtPd25lciIsInpsaWJMaW1pdGVyIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJfbWF4UGF5bG9hZCIsIl9vcHRpb25zIiwiX3RocmVzaG9sZCIsInRocmVzaG9sZCIsInVuZGVmaW5lZCIsIl9pc1NlcnZlciIsIl9kZWZsYXRlIiwiX2luZmxhdGUiLCJwYXJhbXMiLCJjb25jdXJyZW5jeSIsImNvbmN1cnJlbmN5TGltaXQiLCJleHRlbnNpb25OYW1lIiwib2ZmZXIiLCJzZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciIsInNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyIiwiY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIiLCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciIsInNlcnZlck1heFdpbmRvd0JpdHMiLCJzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzIiwiY2xpZW50TWF4V2luZG93Qml0cyIsImNsaWVudF9tYXhfd2luZG93X2JpdHMiLCJhY2NlcHQiLCJwYXJhbXNMaXN0Iiwibm9ybWFsaXplUGFyYW1zIiwiYWNjZXB0QXNTZXJ2ZXIiLCJhY2NlcHRBc0NsaWVudCIsImNsZWFudXAiLCJjbG9zZSIsImFjY2VwdGVkIiwicmVzdWx0Iiwic29tZSIsIkVycm9yIiwibWFwIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsImxlbmd0aCIsInBhcnNlSW50IiwiTnVtYmVyIiwiaXNOYU4iLCJaX01JTl9XSU5ET1dCSVRTIiwiWl9NQVhfV0lORE9XQklUUyIsImRlY29tcHJlc3MiLCJkYXRhIiwiZmluIiwiY2FsbGJhY2siLCJwdXNoIiwiZG9uZSIsIl9kZWNvbXByZXNzIiwiZXJyIiwiY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJvbiIsImluZmxhdGVPbkVycm9yIiwiaW5mbGF0ZU9uRGF0YSIsIndyaXRlIiwiZmx1c2giLCJjb25jYXQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjcmVhdGVEZWZsYXRlUmF3IiwibWVtTGV2ZWwiLCJsZXZlbCIsIlpfU1lOQ19GTFVTSCIsImRlZmxhdGVPbkRhdGEiLCJzbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaHVuayIsImNsb3NlQ29kZSIsInJlbW92ZUxpc3RlbmVyIiwicmVzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/PerMessageDeflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/Receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/Receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/ws/lib/PerMessageDeflate.js\");\nconst isValidUTF8 = __webpack_require__(/*! ./Validation */ \"(rsc)/./node_modules/ws/lib/Validation.js\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"(rsc)/./node_modules/ws/lib/BufferUtil.js\");\nconst ErrorCodes = __webpack_require__(/*! ./ErrorCodes */ \"(rsc)/./node_modules/ws/lib/ErrorCodes.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/ws/lib/Constants.js\");\nconst Buffer = safeBuffer.Buffer;\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n */ class Receiver {\n    /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */ constructor(extensions, maxPayload, binaryType){\n        this._binaryType = binaryType || constants.BINARY_TYPES[0];\n        this._extensions = extensions || {};\n        this._maxPayload = maxPayload | 0;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._mask = null;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._cleanupCallback = null;\n        this._hadError = false;\n        this._dead = false;\n        this._loop = false;\n        this.onmessage = null;\n        this.onclose = null;\n        this.onerror = null;\n        this.onping = null;\n        this.onpong = null;\n        this._state = GET_INFO;\n    }\n    /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */ readBuffer(bytes) {\n        var offset = 0;\n        var dst;\n        var l;\n        this._bufferedBytes -= bytes;\n        if (bytes === this._buffers[0].length) return this._buffers.shift();\n        if (bytes < this._buffers[0].length) {\n            dst = this._buffers[0].slice(0, bytes);\n            this._buffers[0] = this._buffers[0].slice(bytes);\n            return dst;\n        }\n        dst = Buffer.allocUnsafe(bytes);\n        while(bytes > 0){\n            l = this._buffers[0].length;\n            if (bytes >= l) {\n                this._buffers[0].copy(dst, offset);\n                offset += l;\n                this._buffers.shift();\n            } else {\n                this._buffers[0].copy(dst, offset, 0, bytes);\n                this._buffers[0] = this._buffers[0].slice(bytes);\n            }\n            bytes -= l;\n        }\n        return dst;\n    }\n    /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */ hasBufferedBytes(n) {\n        if (this._bufferedBytes >= n) return true;\n        this._loop = false;\n        if (this._dead) this.cleanup(this._cleanupCallback);\n        return false;\n    }\n    /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */ add(data) {\n        if (this._dead) return;\n        this._bufferedBytes += data.length;\n        this._buffers.push(data);\n        this.startLoop();\n    }\n    /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */ startLoop() {\n        this._loop = true;\n        while(this._loop){\n            switch(this._state){\n                case GET_INFO:\n                    this.getInfo();\n                    break;\n                case GET_PAYLOAD_LENGTH_16:\n                    this.getPayloadLength16();\n                    break;\n                case GET_PAYLOAD_LENGTH_64:\n                    this.getPayloadLength64();\n                    break;\n                case GET_MASK:\n                    this.getMask();\n                    break;\n                case GET_DATA:\n                    this.getData();\n                    break;\n                default:\n                    this._loop = false;\n            }\n        }\n    }\n    /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */ getInfo() {\n        if (!this.hasBufferedBytes(2)) return;\n        const buf = this.readBuffer(2);\n        if ((buf[0] & 0x30) !== 0x00) {\n            this.error(new Error(\"RSV2 and RSV3 must be clear\"), 1002);\n            return;\n        }\n        const compressed = (buf[0] & 0x40) === 0x40;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n            this.error(new Error(\"RSV1 must be clear\"), 1002);\n            return;\n        }\n        this._fin = (buf[0] & 0x80) === 0x80;\n        this._opcode = buf[0] & 0x0f;\n        this._payloadLength = buf[1] & 0x7f;\n        if (this._opcode === 0x00) {\n            if (compressed) {\n                this.error(new Error(\"RSV1 must be clear\"), 1002);\n                return;\n            }\n            if (!this._fragmented) {\n                this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n                return;\n            } else {\n                this._opcode = this._fragmented;\n            }\n        } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n            if (this._fragmented) {\n                this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n                return;\n            }\n            this._compressed = compressed;\n        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n            if (!this._fin) {\n                this.error(new Error(\"FIN must be set\"), 1002);\n                return;\n            }\n            if (compressed) {\n                this.error(new Error(\"RSV1 must be clear\"), 1002);\n                return;\n            }\n            if (this._payloadLength > 0x7d) {\n                this.error(new Error(\"invalid payload length\"), 1002);\n                return;\n            }\n        } else {\n            this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n            return;\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 0x80) === 0x80;\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */ getPayloadLength16() {\n        if (!this.hasBufferedBytes(2)) return;\n        this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n        this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */ getPayloadLength64() {\n        if (!this.hasBufferedBytes(8)) return;\n        const buf = this.readBuffer(8);\n        const num = buf.readUInt32BE(0, true);\n        //\n        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n        // if payload length is greater than this number.\n        //\n        if (num > Math.pow(2, 53 - 32) - 1) {\n            this.error(new Error(\"max payload size exceeded\"), 1009);\n            return;\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4, true);\n        this.haveLength();\n    }\n    /**\n   * Payload length has been read.\n   *\n   * @private\n   */ haveLength() {\n        if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n            return;\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n    }\n    /**\n   * Reads mask bytes.\n   *\n   * @private\n   */ getMask() {\n        if (!this.hasBufferedBytes(4)) return;\n        this._mask = this.readBuffer(4);\n        this._state = GET_DATA;\n    }\n    /**\n   * Reads data bytes.\n   *\n   * @private\n   */ getData() {\n        var data = constants.EMPTY_BUFFER;\n        if (this._payloadLength) {\n            if (!this.hasBufferedBytes(this._payloadLength)) return;\n            data = this.readBuffer(this._payloadLength);\n            if (this._masked) bufferUtil.unmask(data, this._mask);\n        }\n        if (this._opcode > 0x07) {\n            this.controlMessage(data);\n        } else if (this._compressed) {\n            this._state = INFLATING;\n            this.decompress(data);\n        } else if (this.pushFragment(data)) {\n            this.dataMessage();\n        }\n    }\n    /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */ decompress(data) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n            if (err) {\n                this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n                return;\n            }\n            if (this.pushFragment(buf)) this.dataMessage();\n            this.startLoop();\n        });\n    }\n    /**\n   * Handles a data message.\n   *\n   * @private\n   */ dataMessage() {\n        if (this._fin) {\n            const messageLength = this._messageLength;\n            const fragments = this._fragments;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragmented = 0;\n            this._fragments = [];\n            if (this._opcode === 2) {\n                var data;\n                if (this._binaryType === \"nodebuffer\") {\n                    data = toBuffer(fragments, messageLength);\n                } else if (this._binaryType === \"arraybuffer\") {\n                    data = toArrayBuffer(toBuffer(fragments, messageLength));\n                } else {\n                    data = fragments;\n                }\n                this.onmessage(data);\n            } else {\n                const buf = toBuffer(fragments, messageLength);\n                if (!isValidUTF8(buf)) {\n                    this.error(new Error(\"invalid utf8 sequence\"), 1007);\n                    return;\n                }\n                this.onmessage(buf.toString());\n            }\n        }\n        this._state = GET_INFO;\n    }\n    /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */ controlMessage(data) {\n        if (this._opcode === 0x08) {\n            if (data.length === 0) {\n                this.onclose(1000, \"\");\n                this._loop = false;\n                this.cleanup(this._cleanupCallback);\n            } else if (data.length === 1) {\n                this.error(new Error(\"invalid payload length\"), 1002);\n            } else {\n                const code = data.readUInt16BE(0, true);\n                if (!ErrorCodes.isValidErrorCode(code)) {\n                    this.error(new Error(`invalid status code: ${code}`), 1002);\n                    return;\n                }\n                const buf = data.slice(2);\n                if (!isValidUTF8(buf)) {\n                    this.error(new Error(\"invalid utf8 sequence\"), 1007);\n                    return;\n                }\n                this.onclose(code, buf.toString());\n                this._loop = false;\n                this.cleanup(this._cleanupCallback);\n            }\n            return;\n        }\n        if (this._opcode === 0x09) this.onping(data);\n        else this.onpong(data);\n        this._state = GET_INFO;\n    }\n    /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */ error(err, code) {\n        this.onerror(err, code);\n        this._hadError = true;\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n    }\n    /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */ maxPayloadExceeded(length) {\n        if (length === 0 || this._maxPayload < 1) return false;\n        const fullLength = this._totalPayloadLength + length;\n        if (fullLength <= this._maxPayload) {\n            this._totalPayloadLength = fullLength;\n            return false;\n        }\n        this.error(new Error(\"max payload size exceeded\"), 1009);\n        return true;\n    }\n    /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */ pushFragment(fragment) {\n        if (fragment.length === 0) return true;\n        const totalLength = this._messageLength + fragment.length;\n        if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n            this._messageLength = totalLength;\n            this._fragments.push(fragment);\n            return true;\n        }\n        this.error(new Error(\"max payload size exceeded\"), 1009);\n        return false;\n    }\n    /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */ cleanup(cb) {\n        this._dead = true;\n        if (!this._hadError && (this._loop || this._state === INFLATING)) {\n            this._cleanupCallback = cb;\n        } else {\n            this._extensions = null;\n            this._fragments = null;\n            this._buffers = null;\n            this._mask = null;\n            this._cleanupCallback = null;\n            this.onmessage = null;\n            this.onclose = null;\n            this.onerror = null;\n            this.onping = null;\n            this.onpong = null;\n            if (cb) cb();\n        }\n    }\n}\nmodule.exports = Receiver;\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */ function toBuffer(fragments, messageLength) {\n    if (fragments.length === 1) return fragments[0];\n    if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n    return constants.EMPTY_BUFFER;\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */ function toArrayBuffer(buf) {\n    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n        return buf.buffer;\n    }\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL1JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FFRDtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUksYUFBYUosbUJBQU9BLENBQUM7QUFDM0IsTUFBTUssWUFBWUwsbUJBQU9BLENBQUM7QUFFMUIsTUFBTU0sU0FBU1AsV0FBV08sTUFBTTtBQUVoQyxNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFlBQVk7QUFFbEI7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7R0FNQyxHQUNEQyxZQUFhQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxDQUFFO1FBQy9DLElBQUksQ0FBQ0MsV0FBVyxHQUFHRCxjQUFjWixVQUFVYyxZQUFZLENBQUMsRUFBRTtRQUMxRCxJQUFJLENBQUNDLFdBQVcsR0FBR0wsY0FBYyxDQUFDO1FBQ2xDLElBQUksQ0FBQ00sV0FBVyxHQUFHTCxhQUFhO1FBRWhDLElBQUksQ0FBQ00sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7UUFFbEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFFZixJQUFJLENBQUNDLG1CQUFtQixHQUFHO1FBQzNCLElBQUks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b3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQtYW5hbHl0aWNzLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9SZWNlaXZlci5qcz9hNDdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogd3M6IGEgbm9kZS5qcyB3ZWJzb2NrZXQgY2xpZW50XG4gKiBDb3B5cmlnaHQoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9QZXJNZXNzYWdlRGVmbGF0ZScpO1xuY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCcuL1ZhbGlkYXRpb24nKTtcbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL0J1ZmZlclV0aWwnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSByZXF1aXJlKCcuL0Vycm9yQ29kZXMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5cbmNvbnN0IEJ1ZmZlciA9IHNhZmVCdWZmZXIuQnVmZmVyO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUmVjZWl2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJpbmFyeVR5cGUgVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZXh0ZW5zaW9ucywgbWF4UGF5bG9hZCwgYmluYXJ5VHlwZSkge1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBiaW5hcnlUeXBlIHx8IGNvbnN0YW50cy5CSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fY2xlYW51cENhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuX2RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG5cbiAgICB0aGlzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25waW5nID0gbnVsbDtcbiAgICB0aGlzLm9ucG9uZyA9IG51bGw7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGJ5dGVzIGZyb20gdGhlIGF2YWlsYWJsZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZXMgVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gQ29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlYWRCdWZmZXIgKGJ5dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGRzdDtcbiAgICB2YXIgbDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gYnl0ZXM7XG5cbiAgICBpZiAoYnl0ZXMgPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKGJ5dGVzIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGRzdCA9IHRoaXMuX2J1ZmZlcnNbMF0uc2xpY2UoMCwgYnl0ZXMpO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IHRoaXMuX2J1ZmZlcnNbMF0uc2xpY2UoYnl0ZXMpO1xuICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpO1xuXG4gICAgd2hpbGUgKGJ5dGVzID4gMCkge1xuICAgICAgbCA9IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoO1xuXG4gICAgICBpZiAoYnl0ZXMgPj0gbCkge1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdLmNvcHkoZHN0LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gbDtcbiAgICAgICAgdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXS5jb3B5KGRzdCwgb2Zmc2V0LCAwLCBieXRlcyk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSB0aGlzLl9idWZmZXJzWzBdLnNsaWNlKGJ5dGVzKTtcbiAgICAgIH1cblxuICAgICAgYnl0ZXMgLT0gbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbnVtYmVyIG9mIGJ1ZmZlcmVkIGJ5dGVzIGlzIGJpZ2dlciBvciBlcXVhbCB0aGFuIGBuYCBhbmRcbiAgICogY2FsbHMgYGNsZWFudXBgIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjaGVjayBhZ2FpbnN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmZmVyZWRCeXRlcyA+PSBuYCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNCdWZmZXJlZEJ5dGVzIChuKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPj0gbikgcmV0dXJuIHRydWU7XG5cbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2RlYWQpIHRoaXMuY2xlYW51cCh0aGlzLl9jbGVhbnVwQ2FsbGJhY2spO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoZSBwYXJzZXIuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZCAoZGF0YSkge1xuICAgIGlmICh0aGlzLl9kZWFkKSByZXR1cm47XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChkYXRhKTtcbiAgICB0aGlzLnN0YXJ0TG9vcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wICgpIHtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIHdoaWxlICh0aGlzLl9sb29wKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQnVmZmVyZWRCeXRlcygyKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicpLCAxMDAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdSU1YxIG11c3QgYmUgY2xlYXInKSwgMTAwMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignUlNWMSBtdXN0IGJlIGNsZWFyJyksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcihgaW52YWxpZCBvcGNvZGU6ICR7dGhpcy5fb3Bjb2RlfWApLCAxMDAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKGBpbnZhbGlkIG9wY29kZTogJHt0aGlzLl9vcGNvZGV9YCksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignRklOIG11c3QgYmUgc2V0JyksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdSU1YxIG11c3QgYmUgY2xlYXInKSwgMTAwMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdpbnZhbGlkIHBheWxvYWQgbGVuZ3RoJyksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKGBpbnZhbGlkIG9wY29kZTogJHt0aGlzLl9vcGNvZGV9YCksIDEwMDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuXG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2ICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQnVmZmVyZWRCeXRlcygyKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMucmVhZEJ1ZmZlcigyKS5yZWFkVUludDE2QkUoMCwgdHJ1ZSk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQgKCkge1xuICAgIGlmICghdGhpcy5oYXNCdWZmZXJlZEJ5dGVzKDgpKSByZXR1cm47XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwLCB0cnVlKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ21heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKSwgMTAwOSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IChudW0gKiBNYXRoLnBvdygyLCAzMikpICsgYnVmLnJlYWRVSW50MzJCRSg0LCB0cnVlKTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aCAoKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA8IDB4MDggJiYgdGhpcy5tYXhQYXlsb2FkRXhjZWVkZWQodGhpcy5fcGF5bG9hZExlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzayAoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0J1ZmZlcmVkQnl0ZXMoNCkpIHJldHVybjtcblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLnJlYWRCdWZmZXIoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YSAoKSB7XG4gICAgdmFyIGRhdGEgPSBjb25zdGFudHMuRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNCdWZmZXJlZEJ5dGVzKHRoaXMuX3BheWxvYWRMZW5ndGgpKSByZXR1cm47XG5cbiAgICAgIGRhdGEgPSB0aGlzLnJlYWRCdWZmZXIodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSBidWZmZXJVdGlsLnVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykge1xuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wdXNoRnJhZ21lbnQoZGF0YSkpIHtcbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzc2VzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVjb21wcmVzcyAoZGF0YSkge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmRlY29tcHJlc3MoZGF0YSwgdGhpcy5fZmluLCAoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5lcnJvcihlcnIsIGVyci5jbG9zZUNvZGUgPT09IDEwMDkgPyAxMDA5IDogMTAwNyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHVzaEZyYWdtZW50KGJ1ZikpIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICAgIHRoaXMuc3RhcnRMb29wKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlICgpIHtcbiAgICBpZiAodGhpcy5fZmluKSB7XG4gICAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ubWVzc2FnZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgdXRmOCBzZXF1ZW5jZScpLCAxMDA3KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ubWVzc2FnZShidWYudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UgKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5vbmNsb3NlKDEwMDAsICcnKTtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFudXAodGhpcy5fY2xlYW51cENhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgcGF5bG9hZCBsZW5ndGgnKSwgMTAwMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFFcnJvckNvZGVzLmlzVmFsaWRFcnJvckNvZGUoY29kZSkpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcihgaW52YWxpZCBzdGF0dXMgY29kZTogJHtjb2RlfWApLCAxMDAyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBkYXRhLnNsaWNlKDIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdpbnZhbGlkIHV0Zjggc2VxdWVuY2UnKSwgMTAwNyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbmNsb3NlKGNvZGUsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFudXAodGhpcy5fY2xlYW51cENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDkpIHRoaXMub25waW5nKGRhdGEpO1xuICAgIGVsc2UgdGhpcy5vbnBvbmcoZGF0YSk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgQ2xvc2UgY29kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXJyb3IgKGVyciwgY29kZSkge1xuICAgIHRoaXMub25lcnJvcihlcnIsIGNvZGUpO1xuICAgIHRoaXMuX2hhZEVycm9yID0gdHJ1ZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhbnVwKHRoaXMuX2NsZWFudXBDYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHBheWxvYWQgc2l6ZSwgZGlzY29ubmVjdHMgc29ja2V0IHdoZW4gaXQgZXhjZWVkcyBgbWF4UGF5bG9hZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggUGF5bG9hZCBsZW5ndGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1heFBheWxvYWRFeGNlZWRlZCAobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCB8fCB0aGlzLl9tYXhQYXlsb2FkIDwgMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgZnVsbExlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArIGxlbmd0aDtcblxuICAgIGlmIChmdWxsTGVuZ3RoIDw9IHRoaXMuX21heFBheWxvYWQpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IGZ1bGxMZW5ndGg7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ21heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKSwgMTAwOSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBhIGZyYWdtZW50IGluIHRoZSBmcmFnbWVudHMgYXJyYXkgYWZ0ZXIgY2hlY2tpbmcgdGhhdCB0aGUgc3VtIG9mXG4gICAqIGZyYWdtZW50IGxlbmd0aHMgZG9lcyBub3QgZXhjZWVkIGBtYXhQYXlsb2FkYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBhZGRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBtYXhQYXlsb2FkYCBpcyBub3QgZXhjZWVkZWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHVzaEZyYWdtZW50IChmcmFnbWVudCkge1xuICAgIGlmIChmcmFnbWVudC5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3QgdG90YWxMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoICsgZnJhZ21lbnQubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuX21heFBheWxvYWQgPCAxIHx8IHRvdGFsTGVuZ3RoIDw9IHRoaXMuX21heFBheWxvYWQpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0b3RhbExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdtYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyksIDEwMDkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyByZXNvdXJjZXMgdXNlZCBieSB0aGUgcmVjZWl2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAgKGNiKSB7XG4gICAgdGhpcy5fZGVhZCA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX2hhZEVycm9yICYmICh0aGlzLl9sb29wIHx8IHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcpKSB7XG4gICAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2sgPSBjYjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICB0aGlzLl9tYXNrID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XG4gICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5vbnBpbmcgPSBudWxsO1xuICAgICAgdGhpcy5vbnBvbmcgPSBudWxsO1xuXG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXI7XG5cbi8qKlxuICogTWFrZXMgYSBidWZmZXIgZnJvbSBhIGxpc3Qgb2YgZnJhZ21lbnRzLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGZyYWdtZW50cyBUaGUgbGlzdCBvZiBmcmFnbWVudHMgY29tcG9zaW5nIHRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZUxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0J1ZmZlciAoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSB7XG4gIGlmIChmcmFnbWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZnJhZ21lbnRzWzBdO1xuICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBidWZmZXJVdGlsLmNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICByZXR1cm4gY29uc3RhbnRzLkVNUFRZX0JVRkZFUjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1Zikge1xuICBpZiAoYnVmLmJ5dGVPZmZzZXQgPT09IDAgJiYgYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xufVxuIl0sIm5hbWVzIjpbInNhZmVCdWZmZXIiLCJyZXF1aXJlIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJpc1ZhbGlkVVRGOCIsImJ1ZmZlclV0aWwiLCJFcnJvckNvZGVzIiwiY29uc3RhbnRzIiwiQnVmZmVyIiwiR0VUX0lORk8iLCJHRVRfUEFZTE9BRF9MRU5HVEhfMTYiLCJHRVRfUEFZTE9BRF9MRU5HVEhfNjQiLCJHRVRfTUFTSyIsIkdFVF9EQVRBIiwiSU5GTEFUSU5HIiwiUmVjZWl2ZXIiLCJjb25zdHJ1Y3RvciIsImV4dGVuc2lvbnMiLCJtYXhQYXlsb2FkIiwiYmluYXJ5VHlwZSIsIl9iaW5hcnlUeXBlIiwiQklOQVJZX1RZUEVTIiwiX2V4dGVuc2lvbnMiLCJfbWF4UGF5bG9hZCIsIl9idWZmZXJlZEJ5dGVzIiwiX2J1ZmZlcnMiLCJfY29tcHJlc3NlZCIsIl9wYXlsb2FkTGVuZ3RoIiwiX2ZyYWdtZW50ZWQiLCJfbWFza2VkIiwiX2ZpbiIsIl9tYXNrIiwiX29wY29kZSIsIl90b3RhbFBheWxvYWRMZW5ndGgiLCJfbWVzc2FnZUxlbmd0aCIsIl9mcmFnbWVudHMiLCJfY2xlYW51cENhbGxiYWNrIiwiX2hhZEVycm9yIiwiX2RlYWQiLCJfbG9vcCIsIm9ubWVzc2FnZSIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25waW5nIiwib25wb25nIiwiX3N0YXRlIiwicmVhZEJ1ZmZlciIsImJ5dGVzIiwib2Zmc2V0IiwiZHN0IiwibCIsImxlbmd0aCIsInNoaWZ0Iiwic2xpY2UiLCJhbGxvY1Vuc2FmZSIsImNvcHkiLCJoYXNCdWZmZXJlZEJ5dGVzIiwibiIsImNsZWFudXAiLCJhZGQiLCJkYXRhIiwicHVzaCIsInN0YXJ0TG9vcCIsImdldEluZm8iLCJnZXRQYXlsb2FkTGVuZ3RoMTYiLCJnZXRQYXlsb2FkTGVuZ3RoNjQiLCJnZXRNYXNrIiwiZ2V0RGF0YSIsImJ1ZiIsImVycm9yIiwiRXJyb3IiLCJjb21wcmVzc2VkIiwiZXh0ZW5zaW9uTmFtZSIsImhhdmVMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJudW0iLCJyZWFkVUludDMyQkUiLCJNYXRoIiwicG93IiwibWF4UGF5bG9hZEV4Y2VlZGVkIiwiRU1QVFlfQlVGRkVSIiwidW5tYXNrIiwiY29udHJvbE1lc3NhZ2UiLCJkZWNvbXByZXNzIiwicHVzaEZyYWdtZW50IiwiZGF0YU1lc3NhZ2UiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImVyciIsImNsb3NlQ29kZSIsIm1lc3NhZ2VMZW5ndGgiLCJmcmFnbWVudHMiLCJ0b0J1ZmZlciIsInRvQXJyYXlCdWZmZXIiLCJ0b1N0cmluZyIsImNvZGUiLCJpc1ZhbGlkRXJyb3JDb2RlIiwiZnVsbExlbmd0aCIsImZyYWdtZW50IiwidG90YWxMZW5ndGgiLCJjYiIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb25jYXQiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/Receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/Sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/Sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/ws/lib/PerMessageDeflate.js\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"(rsc)/./node_modules/ws/lib/BufferUtil.js\");\nconst ErrorCodes = __webpack_require__(/*! ./ErrorCodes */ \"(rsc)/./node_modules/ws/lib/ErrorCodes.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/ws/lib/Constants.js\");\nconst Buffer = safeBuffer.Buffer;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */ constructor(socket, extensions){\n        this._extensions = extensions || {};\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._deflating = false;\n        this._queue = [];\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */ static frame(data, options) {\n        const merge = data.length < 1024 || options.mask && options.readOnly;\n        var offset = options.mask ? 6 : 2;\n        var payloadLength = data.length;\n        if (data.length >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (data.length > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(data.length, 2, true);\n        } else if (payloadLength === 127) {\n            target.writeUInt32BE(0, 2, true);\n            target.writeUInt32BE(data.length, 6, true);\n        }\n        if (!options.mask) {\n            target[1] = payloadLength;\n            if (merge) {\n                data.copy(target, offset);\n                return [\n                    target\n                ];\n            }\n            return [\n                target,\n                data\n            ];\n        }\n        const mask = crypto.randomBytes(4);\n        target[1] = payloadLength | 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (merge) {\n            bufferUtil.mask(data, mask, target, offset, data.length);\n            return [\n                target\n            ];\n        }\n        bufferUtil.mask(data, mask, data, 0, data.length);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        var buf;\n        if (code === undefined) {\n            code = 1000;\n        } else if (typeof code !== \"number\" || !ErrorCodes.isValidErrorCode(code)) {\n            throw new Error(\"first argument must be a valid error code number\");\n        }\n        if (data === undefined || data === \"\") {\n            if (code === 1000) {\n                buf = constants.EMPTY_BUFFER;\n            } else {\n                buf = Buffer.allocUnsafe(2);\n                buf.writeUInt16BE(code, 0, true);\n            }\n        } else {\n            buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n            buf.writeUInt16BE(code, 0, true);\n            buf.write(data, 2);\n        }\n        if (this._deflating) {\n            this.enqueue([\n                this.doClose,\n                buf,\n                mask,\n                cb\n            ]);\n        } else {\n            this.doClose(buf, mask, cb);\n        }\n    }\n    /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */ doClose(data, mask, cb) {\n        this.sendFrame(Sender.frame(data, {\n            fin: true,\n            rsv1: false,\n            opcode: 0x08,\n            mask,\n            readOnly: false\n        }), cb);\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */ ping(data, mask) {\n        var readOnly = true;\n        if (!Buffer.isBuffer(data)) {\n            if (data instanceof ArrayBuffer) {\n                data = Buffer.from(data);\n            } else if (ArrayBuffer.isView(data)) {\n                data = viewToBuffer(data);\n            } else {\n                data = Buffer.from(data);\n                readOnly = false;\n            }\n        }\n        if (this._deflating) {\n            this.enqueue([\n                this.doPing,\n                data,\n                mask,\n                readOnly\n            ]);\n        } else {\n            this.doPing(data, mask, readOnly);\n        }\n    }\n    /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */ doPing(data, mask, readOnly) {\n        this.sendFrame(Sender.frame(data, {\n            fin: true,\n            rsv1: false,\n            opcode: 0x09,\n            mask,\n            readOnly\n        }));\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */ pong(data, mask) {\n        var readOnly = true;\n        if (!Buffer.isBuffer(data)) {\n            if (data instanceof ArrayBuffer) {\n                data = Buffer.from(data);\n            } else if (ArrayBuffer.isView(data)) {\n                data = viewToBuffer(data);\n            } else {\n                data = Buffer.from(data);\n                readOnly = false;\n            }\n        }\n        if (this._deflating) {\n            this.enqueue([\n                this.doPong,\n                data,\n                mask,\n                readOnly\n            ]);\n        } else {\n            this.doPong(data, mask, readOnly);\n        }\n    }\n    /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */ doPong(data, mask, readOnly) {\n        this.sendFrame(Sender.frame(data, {\n            fin: true,\n            rsv1: false,\n            opcode: 0x0a,\n            mask,\n            readOnly\n        }));\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */ send(data, options, cb) {\n        var opcode = options.binary ? 2 : 1;\n        var rsv1 = options.compress;\n        var readOnly = true;\n        if (!Buffer.isBuffer(data)) {\n            if (data instanceof ArrayBuffer) {\n                data = Buffer.from(data);\n            } else if (ArrayBuffer.isView(data)) {\n                data = viewToBuffer(data);\n            } else {\n                data = Buffer.from(data);\n                readOnly = false;\n            }\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate) {\n                rsv1 = data.length >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        if (perMessageDeflate) {\n            const opts = {\n                fin: options.fin,\n                rsv1,\n                opcode,\n                mask: options.mask,\n                readOnly\n            };\n            if (this._deflating) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(data, this._compress, opts, cb);\n            }\n        } else {\n            this.sendFrame(Sender.frame(data, {\n                fin: options.fin,\n                rsv1: false,\n                opcode,\n                mask: options.mask,\n                readOnly\n            }), cb);\n        }\n    }\n    /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._deflating = true;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this._deflating = false;\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(!this._deflating && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[1].length;\n            params[0].apply(this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[1].length;\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */ function viewToBuffer(view) {\n    const buf = Buffer.from(view.buffer);\n    if (view.byteLength !== view.buffer.byteLength) {\n        return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n    }\n    return buf;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL1NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBRUQ7QUFFQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUV2QixNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1LLFlBQVlMLG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1NLFNBQVNQLFdBQVdPLE1BQU07QUFFaEM7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7OztHQUtDLEdBQ0RDLFlBQWFDLE1BQU0sRUFBRUMsVUFBVSxDQUFFO1FBQy9CLElBQUksQ0FBQ0MsV0FBVyxHQUFHRCxjQUFjLENBQUM7UUFDbEMsSUFBSSxDQUFDRSxPQUFPLEdBQUdIO1FBRWYsSUFBSSxDQUFDSSxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNsQjtJQUVBOzs7Ozs7Ozs7Ozs7R0FZQyxHQUNELE9BQU9DLE1BQU9DLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQzNCLE1BQU1DLFFBQVFGLEtBQUtHLE1BQU0sR0FBRyxRQUFTRixRQUFRRyxJQUFJLElBQUlILFFBQVFJLFFBQVE7UUFDckUsSUFBSUMsU0FBU0wsUUFBUUcsSUFBSSxHQUFHLElBQUk7UUFDaEMsSUFBSUcsZ0JBQWdCUCxLQUFLRyxNQUFNO1FBRS9CLElBQUlILEtBQUtHLE1BQU0sSUFBSSxPQUFPO1lBQ3hCRyxVQUFVO1lBQ1ZDLGdCQUFnQjtRQUNsQixPQUFPLElBQUlQLEtBQUtHLE1BQU0sR0FBRyxLQUFLO1lBQzVCRyxVQUFVO1lBQ1ZDLGdCQUFnQjtR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LENBQUNpQyxLQUFLLENBQUM0QixJQUFJLENBQUMsRUFBRSxFQUFFbkM7UUFDOUIsT0FBTztZQUNMLElBQUksQ0FBQzFCLE9BQU8sQ0FBQ2lDLEtBQUssQ0FBQzRCLElBQUksQ0FBQyxFQUFFLEVBQUVuQztRQUM5QjtJQUNGO0FBQ0Y7QUFFQW9DLE9BQU9DLE9BQU8sR0FBR3BFO0FBRWpCOzs7Ozs7Q0FNQyxHQUNELFNBQVMrQyxhQUFjc0IsSUFBSTtJQUN6QixNQUFNckMsTUFBTWpDLE9BQU84QyxJQUFJLENBQUN3QixLQUFLQyxNQUFNO0lBRW5DLElBQUlELEtBQUtoQyxVQUFVLEtBQUtnQyxLQUFLQyxNQUFNLENBQUNqQyxVQUFVLEVBQUU7UUFDOUMsT0FBT0wsSUFBSWdDLEtBQUssQ0FBQ0ssS0FBS0UsVUFBVSxFQUFFRixLQUFLRSxVQUFVLEdBQUdGLEtBQUtoQyxVQUFVO0lBQ3JFO0lBRUEsT0FBT0w7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvd3MvbGliL1NlbmRlci5qcz8wMGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogd3M6IGEgbm9kZS5qcyB3ZWJzb2NrZXQgY2xpZW50XG4gKiBDb3B5cmlnaHQoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL1Blck1lc3NhZ2VEZWZsYXRlJyk7XG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9CdWZmZXJVdGlsJyk7XG5jb25zdCBFcnJvckNvZGVzID0gcmVxdWlyZSgnLi9FcnJvckNvZGVzJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xuXG5jb25zdCBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlcjtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc29ja2V0LCBleHRlbnNpb25zKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yc3YxIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIFJTVjEgYml0XG4gICAqIEByZXR1cm4ge0J1ZmZlcltdfSBUaGUgZnJhbWVkIGRhdGEgYXMgYSBsaXN0IG9mIGBCdWZmZXJgIGluc3RhbmNlc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUgKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXJnZSA9IGRhdGEubGVuZ3RoIDwgMTAyNCB8fCAob3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkpO1xuICAgIHZhciBvZmZzZXQgPSBvcHRpb25zLm1hc2sgPyA2IDogMjtcbiAgICB2YXIgcGF5bG9hZExlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGEubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhLmxlbmd0aCwgMiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKDAsIDIsIHRydWUpO1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoZGF0YS5sZW5ndGgsIDYsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSB7XG4gICAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgIGRhdGEuY29weSh0YXJnZXQsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1hc2sgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoIHwgMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBidWZmZXJVdGlsLm1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGEubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBidWZmZXJVdGlsLm1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YS5sZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7KE51bWJlcnx1bmRlZmluZWQpfSBjb2RlIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZSAoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICB2YXIgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29kZSA9IDEwMDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIUVycm9yQ29kZXMuaXNWYWxpZEVycm9yQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09ICcnKSB7XG4gICAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgICBidWYgPSBjb25zdGFudHMuRU1QVFlfQlVGRkVSO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwLCB0cnVlKTtcbiAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9DbG9zZSwgYnVmLCBtYXNrLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvQ2xvc2UoYnVmLCBtYXNrLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBjbG9zZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvQ2xvc2UgKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgbWFzayxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZVxuICAgIH0pLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyAoZGF0YSwgbWFzaykge1xuICAgIHZhciByZWFkT25seSA9IHRydWU7XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICBkYXRhID0gdmlld1RvQnVmZmVyKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb1BpbmcsIGRhdGEsIG1hc2ssIHJlYWRPbmx5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9QaW5nKGRhdGEsIG1hc2ssIHJlYWRPbmx5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBpbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUGluZyAoZGF0YSwgbWFzaywgcmVhZE9ubHkpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgZmluOiB0cnVlLFxuICAgICAgcnN2MTogZmFsc2UsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICBtYXNrLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyAoZGF0YSwgbWFzaykge1xuICAgIHZhciByZWFkT25seSA9IHRydWU7XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICBkYXRhID0gdmlld1RvQnVmZmVyKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb1BvbmcsIGRhdGEsIG1hc2ssIHJlYWRPbmx5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9Qb25nKGRhdGEsIG1hc2ssIHJlYWRPbmx5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBvbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUG9uZyAoZGF0YSwgbWFzaywgcmVhZE9ubHkpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgZmluOiB0cnVlLFxuICAgICAgcnN2MTogZmFsc2UsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICBtYXNrLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5iaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZSBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZCAoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICB2YXIgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICB2YXIgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG4gICAgdmFyIHJlYWRPbmx5ID0gdHJ1ZTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSB2aWV3VG9CdWZmZXIoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChyc3YxICYmIHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIHJzdjEgPSBkYXRhLmxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIHJzdjEsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9KSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yc3YxIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaCAoZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fZGVmbGF0aW5nID0gdHJ1ZTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUgKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgICAgcGFyYW1zWzBdLmFwcGx5KHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZSAocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUgKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgQXJyYXlCdWZmZXJgIHZpZXcgaW50byBhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0geyhEYXRhVmlld3xUeXBlZEFycmF5KX0gdmlldyBUaGUgdmlldyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IENvbnZlcnRlZCB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2aWV3VG9CdWZmZXIgKHZpZXcpIHtcbiAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20odmlldy5idWZmZXIpO1xuXG4gIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKHZpZXcuYnl0ZU9mZnNldCwgdmlldy5ieXRlT2Zmc2V0ICsgdmlldy5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG4iXSwibmFtZXMiOlsic2FmZUJ1ZmZlciIsInJlcXVpcmUiLCJjcnlwdG8iLCJQZXJNZXNzYWdlRGVmbGF0ZSIsImJ1ZmZlclV0aWwiLCJFcnJvckNvZGVzIiwiY29uc3RhbnRzIiwiQnVmZmVyIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiX2V4dGVuc2lvbnMiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9kZWZsYXRpbmciLCJfcXVldWUiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJsZW5ndGgiLCJtYXNrIiwicmVhZE9ubHkiLCJvZmZzZXQiLCJwYXlsb2FkTGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJmaW4iLCJvcGNvZGUiLCJyc3YxIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDMyQkUiLCJjb3B5IiwicmFuZG9tQnl0ZXMiLCJjbG9zZSIsImNvZGUiLCJjYiIsImJ1ZiIsInVuZGVmaW5lZCIsImlzVmFsaWRFcnJvckNvZGUiLCJFcnJvciIsIkVNUFRZX0JVRkZFUiIsImJ5dGVMZW5ndGgiLCJ3cml0ZSIsImVucXVldWUiLCJkb0Nsb3NlIiwic2VuZEZyYW1lIiwicGluZyIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJmcm9tIiwiaXNWaWV3Iiwidmlld1RvQnVmZmVyIiwiZG9QaW5nIiwicG9uZyIsImRvUG9uZyIsInNlbmQiLCJiaW5hcnkiLCJjb21wcmVzcyIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXh0ZW5zaW9uTmFtZSIsIl90aHJlc2hvbGQiLCJvcHRzIiwiZGlzcGF0Y2giLCJfIiwiZGVxdWV1ZSIsInBhcmFtcyIsInNoaWZ0IiwiYXBwbHkiLCJzbGljZSIsInB1c2giLCJsaXN0IiwibW9kdWxlIiwiZXhwb3J0cyIsInZpZXciLCJidWZmZXIiLCJieXRlT2Zmc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/Sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/Validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/Validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \ntry {\n    const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    module.exports = typeof isValidUTF8 === \"object\" ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n     : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n    module.exports = ()=>true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL1ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEO0FBRUEsSUFBSTtJQUNGLE1BQU1BLGNBQWNDLG1CQUFPQSxDQUFDO0lBRTVCQyxPQUFPQyxPQUFPLEdBQUcsT0FBT0gsZ0JBQWdCLFdBQ3BDQSxZQUFZSSxVQUFVLENBQUNKLFdBQVcsQ0FBQyx3QkFBd0I7T0FDM0RBO0FBQ04sRUFBRSxPQUFPSyxHQUFHLHdCQUF3QixHQUFHO0lBQ3JDSCxPQUFPQyxPQUFPLEdBQUcsSUFBTTtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvd3MvbGliL1ZhbGlkYXRpb24uanM/OGQ3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBpc1ZhbGlkVVRGOCA9PT0gJ29iamVjdCdcbiAgICA/IGlzVmFsaWRVVEY4LlZhbGlkYXRpb24uaXNWYWxpZFVURjggLy8gdXRmLTgtdmFsaWRhdGVAPDMuMC4wXG4gICAgOiBpc1ZhbGlkVVRGODtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoKSA9PiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbImlzVmFsaWRVVEY4IiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJWYWxpZGF0aW9uIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/Validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/WebSocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/WebSocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Ultron = __webpack_require__(/*! ultron */ \"(rsc)/./node_modules/ultron/index.js\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/ws/lib/PerMessageDeflate.js\");\nconst EventTarget = __webpack_require__(/*! ./EventTarget */ \"(rsc)/./node_modules/ws/lib/EventTarget.js\");\nconst Extensions = __webpack_require__(/*! ./Extensions */ \"(rsc)/./node_modules/ws/lib/Extensions.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/ws/lib/Constants.js\");\nconst Receiver = __webpack_require__(/*! ./Receiver */ \"(rsc)/./node_modules/ws/lib/Receiver.js\");\nconst Sender = __webpack_require__(/*! ./Sender */ \"(rsc)/./node_modules/ws/lib/Sender.js\");\nconst protocolVersions = [\n    8,\n    13\n];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */ class WebSocket extends EventEmitter {\n    /**\n   * Create a new `WebSocket`.\n   *\n   * @param {String} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */ constructor(address, protocols, options){\n        super();\n        if (!protocols) {\n            protocols = [];\n        } else if (typeof protocols === \"string\") {\n            protocols = [\n                protocols\n            ];\n        } else if (!Array.isArray(protocols)) {\n            options = protocols;\n            protocols = [];\n        }\n        this.readyState = WebSocket.CONNECTING;\n        this.bytesReceived = 0;\n        this.extensions = {};\n        this.protocol = \"\";\n        this._binaryType = constants.BINARY_TYPES[0];\n        this._finalize = this.finalize.bind(this);\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = \"\";\n        this._closeTimer = null;\n        this._finalized = false;\n        this._closeCode = 1006;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        this._ultron = null;\n        if (Array.isArray(address)) {\n            initAsServerClient.call(this, address[0], address[1], options);\n        } else {\n            initAsClient.call(this, address, protocols, options);\n        }\n    }\n    get CONNECTING() {\n        return WebSocket.CONNECTING;\n    }\n    get CLOSING() {\n        return WebSocket.CLOSING;\n    }\n    get CLOSED() {\n        return WebSocket.CLOSED;\n    }\n    get OPEN() {\n        return WebSocket.OPEN;\n    }\n    /**\n   * @type {Number}\n   */ get bufferedAmount() {\n        var amount = 0;\n        if (this._socket) {\n            amount = this._socket.bufferSize + this._sender._bufferedBytes;\n        }\n        return amount;\n    }\n    /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */ get binaryType() {\n        return this._binaryType;\n    }\n    set binaryType(type) {\n        if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n        this._binaryType = type;\n        //\n        // Allow to change `binaryType` on the fly.\n        //\n        if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @private\n   */ setSocket(socket, head) {\n        socket.setTimeout(0);\n        socket.setNoDelay();\n        this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n        this._sender = new Sender(socket, this.extensions);\n        this._ultron = new Ultron(socket);\n        this._socket = socket;\n        this._ultron.on(\"close\", this._finalize);\n        this._ultron.on(\"error\", this._finalize);\n        this._ultron.on(\"end\", this._finalize);\n        if (head.length > 0) socket.unshift(head);\n        this._ultron.on(\"data\", (data)=>{\n            this.bytesReceived += data.length;\n            this._receiver.add(data);\n        });\n        this._receiver.onmessage = (data)=>this.emit(\"message\", data);\n        this._receiver.onping = (data)=>{\n            this.pong(data, !this._isServer, true);\n            this.emit(\"ping\", data);\n        };\n        this._receiver.onpong = (data)=>this.emit(\"pong\", data);\n        this._receiver.onclose = (code, reason)=>{\n            this._closeFrameReceived = true;\n            this._closeMessage = reason;\n            this._closeCode = code;\n            if (!this._finalized) this.close(code, reason);\n        };\n        this._receiver.onerror = (error, code)=>{\n            this._closeMessage = \"\";\n            this._closeCode = code;\n            //\n            // Ensure that the error is emitted even if `WebSocket#finalize()` has\n            // already been called.\n            //\n            this.readyState = WebSocket.CLOSING;\n            this.emit(\"error\", error);\n            this.finalize(true);\n        };\n        this.readyState = WebSocket.OPEN;\n        this.emit(\"open\");\n    }\n    /**\n   * Clean up and release internal resources.\n   *\n   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n   * @private\n   */ finalize(error) {\n        if (this._finalized) return;\n        this.readyState = WebSocket.CLOSING;\n        this._finalized = true;\n        if (typeof error === \"object\") this.emit(\"error\", error);\n        if (!this._socket) return this.emitClose();\n        clearTimeout(this._closeTimer);\n        this._closeTimer = null;\n        this._ultron.destroy();\n        this._ultron = null;\n        this._socket.on(\"error\", constants.NOOP);\n        if (!error) this._socket.end();\n        else this._socket.destroy();\n        this._socket = null;\n        this._sender = null;\n        this._receiver.cleanup(()=>this.emitClose());\n        this._receiver = null;\n    }\n    /**\n   * Emit the `close` event.\n   *\n   * @private\n   */ emitClose() {\n        this.readyState = WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n        if (this.extensions[PerMessageDeflate.extensionName]) {\n            this.extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this.extensions = null;\n        this.removeAllListeners();\n    }\n    /**\n   * Pause the socket stream.\n   *\n   * @public\n   */ pause() {\n        if (this.readyState !== WebSocket.OPEN) throw new Error(\"not opened\");\n        this._socket.pause();\n    }\n    /**\n   * Resume the socket stream\n   *\n   * @public\n   */ resume() {\n        if (this.readyState !== WebSocket.OPEN) throw new Error(\"not opened\");\n        this._socket.resume();\n    }\n    /**\n   * Start a closing handshake.\n   *\n   *            +----------+     +-----------+   +----------+\n   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n   *            +----------+     +-----------+   +----------+       |\n   *     |      +----------+     +-----------+         |\n   *            |ws.close()|<----|close frame|<--------+            |\n   *            +----------+     +-----------+         |\n   *  CLOSING         |              +---+             |         CLOSING\n   *                  |          +---|fin|<------------+\n   *     |            |          |   +---+                          |\n   *                  |          |   +---+      +-------------+\n   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n   *                             |   +---+      +-------------+\n   *     |     +-------------+   |\n   *      - - -|ws.finalize()|<--+\n   *           +-------------+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */ close(code, data) {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            this._req.abort();\n            this.finalize(new Error(\"closed before the connection is established\"));\n            return;\n        }\n        if (this.readyState === WebSocket.CLOSING) {\n            if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n            return;\n        }\n        this.readyState = WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err)=>{\n            //\n            // This error is handled by the `'error'` listener on the socket. We only\n            // want to know if the close frame has been sent here.\n            //\n            if (err) return;\n            this._closeFrameSent = true;\n            if (!this._finalized) {\n                if (this._closeFrameReceived) this._socket.end();\n                //\n                // Ensure that the connection is cleaned up even when the closing\n                // handshake fails.\n                //\n                this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\n            }\n        });\n    }\n    /**\n   * Send a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */ ping(data, mask, failSilently) {\n        if (this.readyState !== WebSocket.OPEN) {\n            if (failSilently) return;\n            throw new Error(\"not opened\");\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.ping(data || constants.EMPTY_BUFFER, mask);\n    }\n    /**\n   * Send a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */ pong(data, mask, failSilently) {\n        if (this.readyState !== WebSocket.OPEN) {\n            if (failSilently) return;\n            throw new Error(\"not opened\");\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.pong(data || constants.EMPTY_BUFFER, mask);\n    }\n    /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */ send(data, options, cb) {\n        if (typeof options === \"function\") {\n            cb = options;\n            options = {};\n        }\n        if (this.readyState !== WebSocket.OPEN) {\n            if (cb) cb(new Error(\"not opened\"));\n            else throw new Error(\"not opened\");\n            return;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        const opts = Object.assign({\n            binary: typeof data !== \"string\",\n            mask: !this._isServer,\n            compress: true,\n            fin: true\n        }, options);\n        if (!this.extensions[PerMessageDeflate.extensionName]) {\n            opts.compress = false;\n        }\n        this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n    }\n    /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */ terminate() {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            this._req.abort();\n            this.finalize(new Error(\"closed before the connection is established\"));\n            return;\n        }\n        this.finalize(true);\n    }\n}\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n[\n    \"open\",\n    \"error\",\n    \"close\",\n    \"message\"\n].forEach((method)=>{\n    Object.defineProperty(WebSocket.prototype, `on${method}`, {\n        /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */ get () {\n            const listeners = this.listeners(method);\n            for(var i = 0; i < listeners.length; i++){\n                if (listeners[i]._listener) return listeners[i]._listener;\n            }\n        },\n        /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */ set (listener) {\n            const listeners = this.listeners(method);\n            for(var i = 0; i < listeners.length; i++){\n                //\n                // Remove only the listeners added via `addEventListener`.\n                //\n                if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n            }\n            this.addEventListener(method, listener);\n        }\n    });\n});\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket server client.\n *\n * @param {http.IncomingMessage} req The request object\n * @param {net.Socket} socket The network socket between the server and client\n * @param {Buffer} head The first packet of the upgraded stream\n * @param {Object} options WebSocket attributes\n * @param {Number} options.protocolVersion The WebSocket protocol version\n * @param {Object} options.extensions The negotiated extensions\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {String} options.protocol The chosen subprotocol\n * @private\n */ function initAsServerClient(socket, head, options) {\n    this.protocolVersion = options.protocolVersion;\n    this._maxPayload = options.maxPayload;\n    this.extensions = options.extensions;\n    this.protocol = options.protocol;\n    this._isServer = true;\n    this.setSocket(socket, head);\n}\n/**\n * Initialize a WebSocket client.\n *\n * @param {String} address The URL to which to connect\n * @param {String[]} protocols The list of subprotocols\n * @param {Object} options Connection options\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {String} options.localAddress Local interface to bind for network connections\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {Object} options.headers An object containing request headers\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @param {http.Agent} options.agent Use the specified Agent\n * @param {String} options.host Value of the `Host` header\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\n * @param {String} options.passphrase The passphrase for the private key or pfx\n * @param {String} options.ciphers The ciphers to use or exclude\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\n * @private\n */ function initAsClient(address, protocols, options) {\n    options = Object.assign({\n        protocolVersion: protocolVersions[1],\n        protocol: protocols.join(\",\"),\n        perMessageDeflate: true,\n        handshakeTimeout: null,\n        localAddress: null,\n        headers: null,\n        family: null,\n        origin: null,\n        agent: null,\n        host: null,\n        //\n        // SSL options.\n        //\n        checkServerIdentity: null,\n        rejectUnauthorized: null,\n        passphrase: null,\n        ciphers: null,\n        ecdhCurve: null,\n        cert: null,\n        key: null,\n        pfx: null,\n        ca: null\n    }, options);\n    if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n        throw new Error(`unsupported protocol version: ${options.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n    }\n    this.protocolVersion = options.protocolVersion;\n    this._isServer = false;\n    this.url = address;\n    const serverUrl = url.parse(address);\n    const isUnixSocket = serverUrl.protocol === \"ws+unix:\";\n    if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\n        throw new Error(\"invalid url\");\n    }\n    const isSecure = serverUrl.protocol === \"wss:\" || serverUrl.protocol === \"https:\";\n    const key = crypto.randomBytes(16).toString(\"base64\");\n    const httpObj = isSecure ? https : http;\n    var perMessageDeflate;\n    const requestOptions = {\n        port: serverUrl.port || (isSecure ? 443 : 80),\n        host: serverUrl.hostname,\n        path: \"/\",\n        headers: {\n            \"Sec-WebSocket-Version\": options.protocolVersion,\n            \"Sec-WebSocket-Key\": key,\n            \"Connection\": \"Upgrade\",\n            \"Upgrade\": \"websocket\"\n        }\n    };\n    if (options.headers) Object.assign(requestOptions.headers, options.headers);\n    if (options.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(options.perMessageDeflate !== true ? options.perMessageDeflate : {}, false);\n        requestOptions.headers[\"Sec-WebSocket-Extensions\"] = Extensions.format({\n            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n    }\n    if (options.protocol) {\n        requestOptions.headers[\"Sec-WebSocket-Protocol\"] = options.protocol;\n    }\n    if (options.origin) {\n        if (options.protocolVersion < 13) {\n            requestOptions.headers[\"Sec-WebSocket-Origin\"] = options.origin;\n        } else {\n            requestOptions.headers.Origin = options.origin;\n        }\n    }\n    if (options.host) requestOptions.headers.Host = options.host;\n    if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\n    if (options.localAddress) requestOptions.localAddress = options.localAddress;\n    if (options.family) requestOptions.family = options.family;\n    if (isUnixSocket) {\n        const parts = serverUrl.path.split(\":\");\n        requestOptions.socketPath = parts[0];\n        requestOptions.path = parts[1];\n    } else if (serverUrl.path) {\n        //\n        // Make sure that path starts with `/`.\n        //\n        if (serverUrl.path.charAt(0) !== \"/\") {\n            requestOptions.path = `/${serverUrl.path}`;\n        } else {\n            requestOptions.path = serverUrl.path;\n        }\n    }\n    var agent = options.agent;\n    //\n    // A custom agent is required for these options.\n    //\n    if (options.rejectUnauthorized != null || options.checkServerIdentity || options.passphrase || options.ciphers || options.ecdhCurve || options.cert || options.key || options.pfx || options.ca) {\n        if (options.passphrase) requestOptions.passphrase = options.passphrase;\n        if (options.ciphers) requestOptions.ciphers = options.ciphers;\n        if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\n        if (options.cert) requestOptions.cert = options.cert;\n        if (options.key) requestOptions.key = options.key;\n        if (options.pfx) requestOptions.pfx = options.pfx;\n        if (options.ca) requestOptions.ca = options.ca;\n        if (options.checkServerIdentity) {\n            requestOptions.checkServerIdentity = options.checkServerIdentity;\n        }\n        if (options.rejectUnauthorized != null) {\n            requestOptions.rejectUnauthorized = options.rejectUnauthorized;\n        }\n        if (!agent) agent = new httpObj.Agent(requestOptions);\n    }\n    if (agent) requestOptions.agent = agent;\n    this._req = httpObj.get(requestOptions);\n    if (options.handshakeTimeout) {\n        this._req.setTimeout(options.handshakeTimeout, ()=>{\n            this._req.abort();\n            this.finalize(new Error(\"opening handshake has timed out\"));\n        });\n    }\n    this._req.on(\"error\", (error)=>{\n        if (this._req.aborted) return;\n        this._req = null;\n        this.finalize(error);\n    });\n    this._req.on(\"response\", (res)=>{\n        if (!this.emit(\"unexpected-response\", this._req, res)) {\n            this._req.abort();\n            this.finalize(new Error(`unexpected server response (${res.statusCode})`));\n        }\n    });\n    this._req.on(\"upgrade\", (res, socket, head)=>{\n        this.emit(\"headers\", res.headers, res);\n        //\n        // The user may have closed the connection from a listener of the `headers`\n        // event.\n        //\n        if (this.readyState !== WebSocket.CONNECTING) return;\n        this._req = null;\n        const digest = crypto.createHash(\"sha1\").update(key + constants.GUID, \"binary\").digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n            socket.destroy();\n            return this.finalize(new Error(\"invalid server key\"));\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        const protList = (options.protocol || \"\").split(/, */);\n        var protError;\n        if (!options.protocol && serverProt) {\n            protError = \"server sent a subprotocol even though none requested\";\n        } else if (options.protocol && !serverProt) {\n            protError = \"server sent no subprotocol even though requested\";\n        } else if (serverProt && protList.indexOf(serverProt) === -1) {\n            protError = \"server responded with an invalid protocol\";\n        }\n        if (protError) {\n            socket.destroy();\n            return this.finalize(new Error(protError));\n        }\n        if (serverProt) this.protocol = serverProt;\n        if (perMessageDeflate) {\n            try {\n                const serverExtensions = Extensions.parse(res.headers[\"sec-websocket-extensions\"]);\n                if (serverExtensions[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n                    this.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                socket.destroy();\n                this.finalize(new Error(\"invalid Sec-WebSocket-Extensions header\"));\n                return;\n            }\n        }\n        this.setSocket(socket, head);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL1dlYlNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBRUQ7QUFFQSxNQUFNQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNSyxNQUFNTCxtQkFBT0EsQ0FBQztBQUVwQixNQUFNTSxvQkFBb0JOLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1PLGNBQWNQLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1TLFlBQVlULG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1VLFdBQVdWLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1XLFNBQVNYLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1ZLG1CQUFtQjtJQUFDO0lBQUc7Q0FBRztBQUNoQyxNQUFNQyxlQUFlLEtBQUssTUFBTSx3REFBd0Q7QUFFeEY7Ozs7Q0FJQyxHQUNELE1BQU1DLGtCQUFrQmY7SUFDdEI7Ozs7OztHQU1DLEdBQ0RnQixZQUFhQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsT0FBTyxDQUFFO1FBQ3hDLEtBQUs7UUFFTCxJQUFJLENBQUNELFdBQVc7WUFDZEEsWUFBWSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxPQUFPQSxjQUFjLFVBQVU7WUFDeENBLFlBQVk7Z0JBQUNBO2FBQVU7UUFDekIsT0FBTyxJQUFJLENBQUNFLE1BQU1DLE9BQU8sQ0FBQ0gsWUFBWTtZQUNwQ0MsVUFBVUQ7WUFDVkEsWUFBWSxFQUFFO1FBQ2hCO1FBRUEsSUFBSSxDQUFDSSxVQUFVLEdBQUdQLFVBQVVRLFVBQVU7UUFDdEMsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQztRQUNu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QUFDLEVBQUU7b0JBQ3JEeUMsa0JBQWtCZ0QsTUFBTSxDQUN0QkQsZ0JBQWdCLENBQUNySyxrQkFBa0I2RSxhQUFhLENBQUM7b0JBRW5ELElBQUksQ0FBQzNELFVBQVUsQ0FBQ2xCLGtCQUFrQjZFLGFBQWEsQ0FBQyxHQUFHeUM7Z0JBQ3JEO1lBQ0YsRUFBRSxPQUFPbEMsS0FBSztnQkFDWm5DLE9BQU93QixPQUFPO2dCQUNkLElBQUksQ0FBQ2xELFFBQVEsQ0FBQyxJQUFJeUQsTUFBTTtnQkFDeEI7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDaEMsU0FBUyxDQUFDQyxRQUFRQztJQUN6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0LWFuYWx5dGljcy8uL25vZGVfbW9kdWxlcy93cy9saWIvV2ViU29ja2V0LmpzPzIxMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB3czogYSBub2RlLmpzIHdlYnNvY2tldCBjbGllbnRcbiAqIENvcHlyaWdodChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgVWx0cm9uID0gcmVxdWlyZSgndWx0cm9uJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9QZXJNZXNzYWdlRGVmbGF0ZScpO1xuY29uc3QgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL0V2ZW50VGFyZ2V0Jyk7XG5jb25zdCBFeHRlbnNpb25zID0gcmVxdWlyZSgnLi9FeHRlbnNpb25zJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL1JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL1NlbmRlcicpO1xuXG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IGNsb3NlVGltZW91dCA9IDMwICogMTAwMDsgLy8gQWxsb3cgMzAgc2Vjb25kcyB0byB0ZXJtaW5hdGUgdGhlIGNvbm5lY3Rpb24gY2xlYW5seS5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICAgIHByb3RvY29scyA9IFtdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgIHByb3RvY29scyA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IGNvbnN0YW50cy5CSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZmluYWxpemUgPSB0aGlzLmZpbmFsaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcbiAgICB0aGlzLl9zZW5kZXIgPSBudWxsO1xuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgdGhpcy5fdWx0cm9uID0gbnVsbDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFkZHJlc3MpKSB7XG4gICAgICBpbml0QXNTZXJ2ZXJDbGllbnQuY2FsbCh0aGlzLCBhZGRyZXNzWzBdLCBhZGRyZXNzWzFdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdEFzQ2xpZW50LmNhbGwodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBnZXQgQ09OTkVDVElORyAoKSB7IHJldHVybiBXZWJTb2NrZXQuQ09OTkVDVElORzsgfVxuICBnZXQgQ0xPU0lORyAoKSB7IHJldHVybiBXZWJTb2NrZXQuQ0xPU0lORzsgfVxuICBnZXQgQ0xPU0VEICgpIHsgcmV0dXJuIFdlYlNvY2tldC5DTE9TRUQ7IH1cbiAgZ2V0IE9QRU4gKCkgeyByZXR1cm4gV2ViU29ja2V0Lk9QRU47IH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCAoKSB7XG4gICAgdmFyIGFtb3VudCA9IDA7XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICBhbW91bnQgPSB0aGlzLl9zb2NrZXQuYnVmZmVyU2l6ZSArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgICB9XG4gICAgcmV0dXJuIGFtb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGRldmlhdGVzIGZyb20gdGhlIFdIQVRXRyBpbnRlcmZhY2Ugc2luY2Ugd3MgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1aXJlZFxuICAgKiBkZWZhdWx0IFwiYmxvYlwiIHR5cGUgKGluc3RlYWQgd2UgZGVmaW5lIGEgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUpLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUgKHR5cGUpIHtcbiAgICBpZiAoY29uc3RhbnRzLkJJTkFSWV9UWVBFUy5pbmRleE9mKHR5cGUpIDwgMCkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQgKHNvY2tldCwgaGVhZCkge1xuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICB0aGlzLl9yZWNlaXZlciA9IG5ldyBSZWNlaXZlcih0aGlzLmV4dGVuc2lvbnMsIHRoaXMuX21heFBheWxvYWQsIHRoaXMuYmluYXJ5VHlwZSk7XG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuZXh0ZW5zaW9ucyk7XG4gICAgdGhpcy5fdWx0cm9uID0gbmV3IFVsdHJvbihzb2NrZXQpO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX3VsdHJvbi5vbignY2xvc2UnLCB0aGlzLl9maW5hbGl6ZSk7XG4gICAgdGhpcy5fdWx0cm9uLm9uKCdlcnJvcicsIHRoaXMuX2ZpbmFsaXplKTtcbiAgICB0aGlzLl91bHRyb24ub24oJ2VuZCcsIHRoaXMuX2ZpbmFsaXplKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgdGhpcy5fdWx0cm9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlY2VpdmVyLmFkZChkYXRhKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlY2VpdmVyLm9ubWVzc2FnZSA9IChkYXRhKSA9PiB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLl9yZWNlaXZlci5vbnBpbmcgPSAoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9O1xuICAgIHRoaXMuX3JlY2VpdmVyLm9ucG9uZyA9IChkYXRhKSA9PiB0aGlzLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbiAgICB0aGlzLl9yZWNlaXZlci5vbmNsb3NlID0gKGNvZGUsIHJlYXNvbikgPT4ge1xuICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgICAgIHRoaXMuX2Nsb3NlQ29kZSA9IGNvZGU7XG4gICAgICBpZiAoIXRoaXMuX2ZpbmFsaXplZCkgdGhpcy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgIH07XG4gICAgdGhpcy5fcmVjZWl2ZXIub25lcnJvciA9IChlcnJvciwgY29kZSkgPT4ge1xuICAgICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gJyc7XG4gICAgICB0aGlzLl9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGVycm9yIGlzIGVtaXR0ZWQgZXZlbiBpZiBgV2ViU29ja2V0I2ZpbmFsaXplKClgIGhhc1xuICAgICAgLy8gYWxyZWFkeSBiZWVuIGNhbGxlZC5cbiAgICAgIC8vXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICB0aGlzLmZpbmFsaXplKHRydWUpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbmQgcmVsZWFzZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58RXJyb3IpfSBlcnJvciBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgYW4gZXJyb3Igb2NjdXJyZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZpbmFsaXplIChlcnJvcikge1xuICAgIGlmICh0aGlzLl9maW5hbGl6ZWQpIHJldHVybjtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JykgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuZW1pdENsb3NlKCk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5fY2xvc2VUaW1lcik7XG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XG5cbiAgICB0aGlzLl91bHRyb24uZGVzdHJveSgpO1xuICAgIHRoaXMuX3VsdHJvbiA9IG51bGw7XG5cbiAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgY29uc3RhbnRzLk5PT1ApO1xuXG4gICAgaWYgKCFlcnJvcikgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgIGVsc2UgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcblxuICAgIHRoaXMuX3JlY2VpdmVyLmNsZWFudXAoKCkgPT4gdGhpcy5lbWl0Q2xvc2UoKSk7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGBjbG9zZWAgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UgKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG5cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuXG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgc29ja2V0IHN0cmVhbS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB0aHJvdyBuZXcgRXJyb3IoJ25vdCBvcGVuZWQnKTtcblxuICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0IHN0cmVhbVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUgKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB0aHJvdyBuZXcgRXJyb3IoJ25vdCBvcGVuZWQnKTtcblxuICAgIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgKyAtIC0gLXx3cy5jbG9zZSgpfC0tLS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtIC1cbiAgICogICAgICAgICAgICArLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgICAgfFxuICAgKiAgICAgfCAgICAgICstLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogICAgICAgICAgICB8d3MuY2xvc2UoKXw8LS0tLXxjbG9zZSBmcmFtZXw8LS0tLS0tLS0rICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogIENMT1NJTkcgICAgICAgICB8ICAgICAgICAgICAgICArLS0tKyAgICAgICAgICAgICB8ICAgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgKy0tLXxmaW58PC0tLS0tLS0tLS0tLStcbiAgICogICAgIHwgICAgICAgICAgICB8ICAgICAgICAgIHwgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICstLS0rICAgICAgKy0tLS0tLS0tLS0tLS0rXG4gICAqICAgICB8ICAgICAgICAgICAgKy0tLS0tLS0tLS0rLS0+fGZpbnwtLS0tLT58d3MuZmluYWxpemUoKXwgLSAtICtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICstLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgfCAgICAgKy0tLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICAgIC0gLSAtfHdzLmZpbmFsaXplKCl8PC0tK1xuICAgKiAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgQSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZSAoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG4gICAgICB0aGlzLmZpbmFsaXplKG5ldyBFcnJvcignY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCkgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLl9maW5hbGl6ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCkgdGhpcy5fc29ja2V0LmVuZCgpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjb25uZWN0aW9uIGlzIGNsZWFuZWQgdXAgZXZlbiB3aGVuIHRoZSBjbG9zaW5nXG4gICAgICAgIC8vIGhhbmRzaGFrZSBmYWlscy5cbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fZmluYWxpemUsIGNsb3NlVGltZW91dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZhaWxTaWxlbnRseSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gdGhyb3cgaWYgYHJlYWR5U3RhdGVgIGlzbid0IGBPUEVOYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nIChkYXRhLCBtYXNrLCBmYWlsU2lsZW50bHkpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgaWYgKGZhaWxTaWxlbnRseSkgcmV0dXJuO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgb3BlbmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgY29uc3RhbnRzLkVNUFRZX0JVRkZFUiwgbWFzayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZhaWxTaWxlbnRseSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gdGhyb3cgaWYgYHJlYWR5U3RhdGVgIGlzbid0IGBPUEVOYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nIChkYXRhLCBtYXNrLCBmYWlsU2lsZW50bHkpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgaWYgKGZhaWxTaWxlbnRseSkgcmV0dXJuO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgb3BlbmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgY29uc3RhbnRzLkVNUFRZX0JVRkZFUiwgbWFzayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZCAoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgaWYgKGNiKSBjYihuZXcgRXJyb3IoJ25vdCBvcGVuZWQnKSk7XG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignbm90IG9wZW5lZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXRoaXMuZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgY29uc3RhbnRzLkVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUgKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG4gICAgICB0aGlzLmZpbmFsaXplKG5ldyBFcnJvcignY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZpbmFsaXplKHRydWUpO1xuICB9XG59XG5cbldlYlNvY2tldC5DT05ORUNUSU5HID0gMDtcbldlYlNvY2tldC5PUEVOID0gMTtcbldlYlNvY2tldC5DTE9TSU5HID0gMjtcbldlYlNvY2tldC5DTE9TRUQgPSAzO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGlzdGVuZXIgb2YgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9ufHVuZGVmaW5lZCl9IFRoZSBldmVudCBsaXN0ZW5lciBvciBgdW5kZWZpbmVkYFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgKCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyKSByZXR1cm4gbGlzdGVuZXJzW2ldLl9saXN0ZW5lcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldCAobGlzdGVuZXIpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBSZW1vdmUgb25seSB0aGUgbGlzdGVuZXJzIGFkZGVkIHZpYSBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyKSB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IHNlcnZlciBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFdlYlNvY2tldCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcm90b2NvbFZlcnNpb24gVGhlIFdlYlNvY2tldCBwcm90b2NvbCB2ZXJzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5leHRlbnNpb25zIFRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnByb3RvY29sIFRoZSBjaG9zZW4gc3VicHJvdG9jb2xcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc1NlcnZlckNsaWVudCAoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gb3B0aW9ucy5wcm90b2NvbFZlcnNpb247XG4gIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQ7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucztcbiAgdGhpcy5wcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2w7XG5cbiAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuXG4gIHRoaXMuc2V0U29ja2V0KHNvY2tldCwgaGVhZCk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwcm90b2NvbHMgVGhlIGxpc3Qgb2Ygc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnByb3RvY29sIFZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgRW5hYmxlL2Rpc2FibGUgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmxvY2FsQWRkcmVzcyBMb2NhbCBpbnRlcmZhY2UgdG8gYmluZCBmb3IgbmV0d29yayBjb25uZWN0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uIFZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmhlYWRlcnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcmVxdWVzdCBoZWFkZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vcmlnaW4gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0ge2h0dHAuQWdlbnR9IG9wdGlvbnMuYWdlbnQgVXNlIHRoZSBzcGVjaWZpZWQgQWdlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvc3QgVmFsdWUgb2YgdGhlIGBIb3N0YCBoZWFkZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmZhbWlseSBJUCBhZGRyZXNzIGZhbWlseSB0byB1c2UgZHVyaW5nIGhvc3RuYW1lIGxvb2t1cCAoNCBvciA2KS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSBBIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIHRoZSBzZXJ2ZXIgaG9zdG5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgVmVyaWZ5IG9yIG5vdCB0aGUgc2VydmVyIGNlcnRpZmljYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wYXNzcGhyYXNlIFRoZSBwYXNzcGhyYXNlIGZvciB0aGUgcHJpdmF0ZSBrZXkgb3IgcGZ4XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jaXBoZXJzIFRoZSBjaXBoZXJzIHRvIHVzZSBvciBleGNsdWRlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5lY2RoQ3VydmUgVGhlIGN1cnZlcyBmb3IgRUNESCBrZXkgYWdyZWVtZW50IHRvIHVzZSBvciBleGNsdWRlXG4gKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW118QnVmZmVyfEJ1ZmZlcltdKX0gb3B0aW9ucy5jZXJ0IFRoZSBjZXJ0aWZpY2F0ZSBrZXlcbiAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXXxCdWZmZXJ8QnVmZmVyW10pfSBvcHRpb25zLmtleSBUaGUgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBvcHRpb25zLnBmeCBUaGUgcHJpdmF0ZSBrZXksIGNlcnRpZmljYXRlLCBhbmQgQ0EgY2VydHNcbiAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXXxCdWZmZXJ8QnVmZmVyW10pfSBvcHRpb25zLmNhIFRydXN0ZWQgY2VydGlmaWNhdGVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQgKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIHByb3RvY29sOiBwcm90b2NvbHMuam9pbignLCcpLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGhhbmRzaGFrZVRpbWVvdXQ6IG51bGwsXG4gICAgbG9jYWxBZGRyZXNzOiBudWxsLFxuICAgIGhlYWRlcnM6IG51bGwsXG4gICAgZmFtaWx5OiBudWxsLFxuICAgIG9yaWdpbjogbnVsbCxcbiAgICBhZ2VudDogbnVsbCxcbiAgICBob3N0OiBudWxsLFxuXG4gICAgLy9cbiAgICAvLyBTU0wgb3B0aW9ucy5cbiAgICAvL1xuICAgIGNoZWNrU2VydmVySWRlbnRpdHk6IG51bGwsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBudWxsLFxuICAgIHBhc3NwaHJhc2U6IG51bGwsXG4gICAgY2lwaGVyczogbnVsbCxcbiAgICBlY2RoQ3VydmU6IG51bGwsXG4gICAgY2VydDogbnVsbCxcbiAgICBrZXk6IG51bGwsXG4gICAgcGZ4OiBudWxsLFxuICAgIGNhOiBudWxsXG4gIH0sIG9wdGlvbnMpO1xuXG4gIGlmIChwcm90b2NvbFZlcnNpb25zLmluZGV4T2Yob3B0aW9ucy5wcm90b2NvbFZlcnNpb24pID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB1bnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdGlvbnMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICB0aGlzLnByb3RvY29sVmVyc2lvbiA9IG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uO1xuICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICB0aGlzLnVybCA9IGFkZHJlc3M7XG5cbiAgY29uc3Qgc2VydmVyVXJsID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICBjb25zdCBpc1VuaXhTb2NrZXQgPSBzZXJ2ZXJVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG5cbiAgaWYgKCFzZXJ2ZXJVcmwuaG9zdCAmJiAoIWlzVW5peFNvY2tldCB8fCAhc2VydmVyVXJsLnBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVybCcpO1xuICB9XG5cbiAgY29uc3QgaXNTZWN1cmUgPSBzZXJ2ZXJVcmwucHJvdG9jb2wgPT09ICd3c3M6JyB8fCBzZXJ2ZXJVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICBjb25zdCBrZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgaHR0cE9iaiA9IGlzU2VjdXJlID8gaHR0cHMgOiBodHRwO1xuICB2YXIgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgcG9ydDogc2VydmVyVXJsLnBvcnQgfHwgKGlzU2VjdXJlID8gNDQzIDogODApLFxuICAgIGhvc3Q6IHNlcnZlclVybC5ob3N0bmFtZSxcbiAgICBwYXRoOiAnLycsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uLFxuICAgICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgICAgJ0Nvbm5lY3Rpb24nOiAnVXBncmFkZScsXG4gICAgICAnVXBncmFkZSc6ICd3ZWJzb2NrZXQnXG4gICAgfVxuICB9O1xuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIE9iamVjdC5hc3NpZ24ocmVxdWVzdE9wdGlvbnMuaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBFeHRlbnNpb25zLmZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcm90b2NvbCkge1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IG9wdGlvbnMucHJvdG9jb2w7XG4gIH1cbiAgaWYgKG9wdGlvbnMub3JpZ2luKSB7XG4gICAgaWYgKG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRpb25zLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5PcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuaG9zdCkgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5Ib3N0ID0gb3B0aW9ucy5ob3N0O1xuICBpZiAoc2VydmVyVXJsLmF1dGgpIHJlcXVlc3RPcHRpb25zLmF1dGggPSBzZXJ2ZXJVcmwuYXV0aDtcblxuICBpZiAob3B0aW9ucy5sb2NhbEFkZHJlc3MpIHJlcXVlc3RPcHRpb25zLmxvY2FsQWRkcmVzcyA9IG9wdGlvbnMubG9jYWxBZGRyZXNzO1xuICBpZiAob3B0aW9ucy5mYW1pbHkpIHJlcXVlc3RPcHRpb25zLmZhbWlseSA9IG9wdGlvbnMuZmFtaWx5O1xuXG4gIGlmIChpc1VuaXhTb2NrZXQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHNlcnZlclVybC5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICByZXF1ZXN0T3B0aW9ucy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgcmVxdWVzdE9wdGlvbnMucGF0aCA9IHBhcnRzWzFdO1xuICB9IGVsc2UgaWYgKHNlcnZlclVybC5wYXRoKSB7XG4gICAgLy9cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBwYXRoIHN0YXJ0cyB3aXRoIGAvYC5cbiAgICAvL1xuICAgIGlmIChzZXJ2ZXJVcmwucGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgcmVxdWVzdE9wdGlvbnMucGF0aCA9IGAvJHtzZXJ2ZXJVcmwucGF0aH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0T3B0aW9ucy5wYXRoID0gc2VydmVyVXJsLnBhdGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFnZW50ID0gb3B0aW9ucy5hZ2VudDtcblxuICAvL1xuICAvLyBBIGN1c3RvbSBhZ2VudCBpcyByZXF1aXJlZCBmb3IgdGhlc2Ugb3B0aW9ucy5cbiAgLy9cbiAgaWYgKFxuICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9IG51bGwgfHxcbiAgICBvcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgfHxcbiAgICBvcHRpb25zLnBhc3NwaHJhc2UgfHxcbiAgICBvcHRpb25zLmNpcGhlcnMgfHxcbiAgICBvcHRpb25zLmVjZGhDdXJ2ZSB8fFxuICAgIG9wdGlvbnMuY2VydCB8fFxuICAgIG9wdGlvbnMua2V5IHx8XG4gICAgb3B0aW9ucy5wZnggfHxcbiAgICBvcHRpb25zLmNhXG4gICkge1xuICAgIGlmIChvcHRpb25zLnBhc3NwaHJhc2UpIHJlcXVlc3RPcHRpb25zLnBhc3NwaHJhc2UgPSBvcHRpb25zLnBhc3NwaHJhc2U7XG4gICAgaWYgKG9wdGlvbnMuY2lwaGVycykgcmVxdWVzdE9wdGlvbnMuY2lwaGVycyA9IG9wdGlvbnMuY2lwaGVycztcbiAgICBpZiAob3B0aW9ucy5lY2RoQ3VydmUpIHJlcXVlc3RPcHRpb25zLmVjZGhDdXJ2ZSA9IG9wdGlvbnMuZWNkaEN1cnZlO1xuICAgIGlmIChvcHRpb25zLmNlcnQpIHJlcXVlc3RPcHRpb25zLmNlcnQgPSBvcHRpb25zLmNlcnQ7XG4gICAgaWYgKG9wdGlvbnMua2V5KSByZXF1ZXN0T3B0aW9ucy5rZXkgPSBvcHRpb25zLmtleTtcbiAgICBpZiAob3B0aW9ucy5wZngpIHJlcXVlc3RPcHRpb25zLnBmeCA9IG9wdGlvbnMucGZ4O1xuICAgIGlmIChvcHRpb25zLmNhKSByZXF1ZXN0T3B0aW9ucy5jYSA9IG9wdGlvbnMuY2E7XG4gICAgaWYgKG9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkge1xuICAgICAgcmVxdWVzdE9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9IG9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3RPcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkO1xuICAgIH1cblxuICAgIGlmICghYWdlbnQpIGFnZW50ID0gbmV3IGh0dHBPYmouQWdlbnQocmVxdWVzdE9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGFnZW50KSByZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IGFnZW50O1xuXG4gIHRoaXMuX3JlcSA9IGh0dHBPYmouZ2V0KHJlcXVlc3RPcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0KSB7XG4gICAgdGhpcy5fcmVxLnNldFRpbWVvdXQob3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0LCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICAgIHRoaXMuZmluYWxpemUobmV3IEVycm9yKCdvcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0JykpO1xuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fcmVxLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgIGlmICh0aGlzLl9yZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5fcmVxID0gbnVsbDtcbiAgICB0aGlzLmZpbmFsaXplKGVycm9yKTtcbiAgfSk7XG5cbiAgdGhpcy5fcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICBpZiAoIXRoaXMuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHRoaXMuX3JlcSwgcmVzKSkge1xuICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG4gICAgICB0aGlzLmZpbmFsaXplKG5ldyBFcnJvcihgdW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7cmVzLnN0YXR1c0NvZGV9KWApKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuX3JlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIHJlcy5oZWFkZXJzLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgaGVhZGVyc2BcbiAgICAvLyBldmVudC5cbiAgICAvL1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBjb25zdGFudHMuR1VJRCwgJ2JpbmFyeScpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobmV3IEVycm9yKCdpbnZhbGlkIHNlcnZlciBrZXknKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgY29uc3QgcHJvdExpc3QgPSAob3B0aW9ucy5wcm90b2NvbCB8fCAnJykuc3BsaXQoLywgKi8pO1xuICAgIHZhciBwcm90RXJyb3I7XG5cbiAgICBpZiAoIW9wdGlvbnMucHJvdG9jb2wgJiYgc2VydmVyUHJvdCkge1xuICAgICAgcHJvdEVycm9yID0gJ3NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgZXZlbiB0aG91Z2ggbm9uZSByZXF1ZXN0ZWQnO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wcm90b2NvbCAmJiAhc2VydmVyUHJvdCkge1xuICAgICAgcHJvdEVycm9yID0gJ3NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sIGV2ZW4gdGhvdWdoIHJlcXVlc3RlZCc7XG4gICAgfSBlbHNlIGlmIChzZXJ2ZXJQcm90ICYmIHByb3RMaXN0LmluZGV4T2Yoc2VydmVyUHJvdCkgPT09IC0xKSB7XG4gICAgICBwcm90RXJyb3IgPSAnc2VydmVyIHJlc3BvbmRlZCB3aXRoIGFuIGludmFsaWQgcHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShuZXcgRXJyb3IocHJvdEVycm9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHRoaXMucHJvdG9jb2wgPSBzZXJ2ZXJQcm90O1xuXG4gICAgaWYgKHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJFeHRlbnNpb25zID0gRXh0ZW5zaW9ucy5wYXJzZShcbiAgICAgICAgICByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ11cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoc2VydmVyRXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChcbiAgICAgICAgICAgIHNlcnZlckV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZShuZXcgRXJyb3IoJ2ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U29ja2V0KHNvY2tldCwgaGVhZCk7XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJjcnlwdG8iLCJVbHRyb24iLCJodHRwcyIsImh0dHAiLCJ1cmwiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIkV2ZW50VGFyZ2V0IiwiRXh0ZW5zaW9ucyIsImNvbnN0YW50cyIsIlJlY2VpdmVyIiwiU2VuZGVyIiwicHJvdG9jb2xWZXJzaW9ucyIsImNsb3NlVGltZW91dCIsIldlYlNvY2tldCIsImNvbnN0cnVjdG9yIiwiYWRkcmVzcyIsInByb3RvY29scyIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsImJ5dGVzUmVjZWl2ZWQiLCJleHRlbnNpb25zIiwicHJvdG9jb2wiLCJfYmluYXJ5VHlwZSIsIkJJTkFSWV9UWVBFUyIsIl9maW5hbGl6ZSIsImZpbmFsaXplIiwiYmluZCIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJfY2xvc2VNZXNzYWdlIiwiX2Nsb3NlVGltZXIiLCJfZmluYWxpemVkIiwiX2Nsb3NlQ29kZSIsIl9yZWNlaXZlciIsIl9zZW5kZXIiLCJfc29ja2V0IiwiX3VsdHJvbiIsImluaXRBc1NlcnZlckNsaWVudCIsImNhbGwiLCJpbml0QXNDbGllbnQiLCJDTE9TSU5HIiwiQ0xPU0VEIiwiT1BFTiIsImJ1ZmZlcmVkQW1vdW50IiwiYW1vdW50IiwiYnVmZmVyU2l6ZSIsIl9idWZmZXJlZEJ5dGVzIiwiYmluYXJ5VHlwZSIsInR5cGUiLCJpbmRleE9mIiwic2V0U29ja2V0Iiwic29ja2V0IiwiaGVhZCIsInNldFRpbWVvdXQiLCJzZXROb0RlbGF5IiwiX21heFBheWxvYWQiLCJvbiIsImxlbmd0aCIsInVuc2hpZnQiLCJkYXRhIiwiYWRkIiwib25tZXNzYWdlIiwiZW1pdCIsIm9ucGluZyIsInBvbmciLCJfaXNTZXJ2ZXIiLCJvbnBvbmciLCJvbmNsb3NlIiwiY29kZSIsInJlYXNvbiIsImNsb3NlIiwib25lcnJvciIsImVycm9yIiwiZW1pdENsb3NlIiwiY2xlYXJUaW1lb3V0IiwiZGVzdHJveSIsIk5PT1AiLCJlbmQiLCJjbGVhbnVwIiwiZXh0ZW5zaW9uTmFtZSIsInJlbW92ZUFsbExpc3RlbmVycyIsInBhdXNlIiwiRXJyb3IiLCJyZXN1bWUiLCJfcmVxIiwiYWJvcnQiLCJlcnIiLCJwaW5nIiwibWFzayIsImZhaWxTaWxlbnRseSIsInRvU3RyaW5nIiwidW5kZWZpbmVkIiwiRU1QVFlfQlVGRkVSIiwic2VuZCIsImNiIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmFyeSIsImNvbXByZXNzIiwiZmluIiwidGVybWluYXRlIiwiZm9yRWFjaCIsIm1ldGhvZCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0IiwibGlzdGVuZXJzIiwiaSIsIl9saXN0ZW5lciIsInNldCIsImxpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJwcm90b2NvbFZlcnNpb24iLCJtYXhQYXlsb2FkIiwiam9pbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiaGFuZHNoYWtlVGltZW91dCIsImxvY2FsQWRkcmVzcyIsImhlYWRlcnMiLCJmYW1pbHkiLCJvcmlnaW4iLCJhZ2VudCIsImhvc3QiLCJjaGVja1NlcnZlcklkZW50aXR5IiwicmVqZWN0VW5hdXRob3JpemVkIiwicGFzc3BocmFzZSIsImNpcGhlcnMiLCJlY2RoQ3VydmUiLCJjZXJ0Iiwia2V5IiwicGZ4IiwiY2EiLCJzZXJ2ZXJVcmwiLCJwYXJzZSIsImlzVW5peFNvY2tldCIsInBhdGgiLCJpc1NlY3VyZSIsInJhbmRvbUJ5dGVzIiwiaHR0cE9iaiIsInJlcXVlc3RPcHRpb25zIiwicG9ydCIsImhvc3RuYW1lIiwiZm9ybWF0Iiwib2ZmZXIiLCJPcmlnaW4iLCJIb3N0IiwiYXV0aCIsInBhcnRzIiwic3BsaXQiLCJzb2NrZXRQYXRoIiwiY2hhckF0IiwiQWdlbnQiLCJhYm9ydGVkIiwicmVzIiwic3RhdHVzQ29kZSIsImRpZ2VzdCIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJHVUlEIiwic2VydmVyUHJvdCIsInByb3RMaXN0IiwicHJvdEVycm9yIiwic2VydmVyRXh0ZW5zaW9ucyIsImFjY2VwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/WebSocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/WebSocketServer.js":
/*!************************************************!*\
  !*** ./node_modules/ws/lib/WebSocketServer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */ \nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Ultron = __webpack_require__(/*! ultron */ \"(rsc)/./node_modules/ultron/index.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/ws/lib/PerMessageDeflate.js\");\nconst Extensions = __webpack_require__(/*! ./Extensions */ \"(rsc)/./node_modules/ws/lib/Extensions.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/ws/lib/Constants.js\");\nconst WebSocket = __webpack_require__(/*! ./WebSocket */ \"(rsc)/./node_modules/ws/lib/WebSocket.js\");\nconst Buffer = safeBuffer.Buffer;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */ class WebSocketServer extends EventEmitter {\n    /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */ constructor(options, callback){\n        super();\n        options = Object.assign({\n            maxPayload: 100 * 1024 * 1024,\n            perMessageDeflate: false,\n            handleProtocols: null,\n            clientTracking: true,\n            verifyClient: null,\n            noServer: false,\n            backlog: null,\n            server: null,\n            host: null,\n            path: null,\n            port: null\n        }, options);\n        if (options.port == null && !options.server && !options.noServer) {\n            throw new TypeError(\"missing or invalid options\");\n        }\n        if (options.port != null) {\n            this._server = http.createServer((req, res)=>{\n                const body = http.STATUS_CODES[426];\n                res.writeHead(426, {\n                    \"Content-Length\": body.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(body);\n            });\n            this._server.listen(options.port, options.host, options.backlog, callback);\n        } else if (options.server) {\n            this._server = options.server;\n        }\n        if (this._server) {\n            this._ultron = new Ultron(this._server);\n            this._ultron.on(\"listening\", ()=>this.emit(\"listening\"));\n            this._ultron.on(\"error\", (err)=>this.emit(\"error\", err));\n            this._ultron.on(\"upgrade\", (req, socket, head)=>{\n                this.handleUpgrade(req, socket, head, (client)=>{\n                    this.emit(\"connection\", client, req);\n                });\n            });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) this.clients = new Set();\n        this.options = options;\n    }\n    /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */ close(cb) {\n        //\n        // Terminate all associated clients.\n        //\n        if (this.clients) {\n            for (const client of this.clients)client.terminate();\n        }\n        const server = this._server;\n        if (server) {\n            this._ultron.destroy();\n            this._ultron = this._server = null;\n            //\n            // Close the http server if it was internally created.\n            //\n            if (this.options.port != null) return server.close(cb);\n        }\n        if (cb) cb();\n    }\n    /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */ shouldHandle(req) {\n        if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */ handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketError);\n        const version = +req.headers[\"sec-websocket-version\"];\n        const extensions = {};\n        if (req.method !== \"GET\" || req.headers.upgrade.toLowerCase() !== \"websocket\" || !req.headers[\"sec-websocket-key\"] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n            return abortConnection(socket, 400);\n        }\n        if (this.options.perMessageDeflate) {\n            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n            try {\n                const offers = Extensions.parse(req.headers[\"sec-websocket-extensions\"]);\n                if (offers[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                return abortConnection(socket, 400);\n            }\n        }\n        var protocol = (req.headers[\"sec-websocket-protocol\"] || \"\").split(/, */);\n        //\n        // Optionally call external protocol selection handler.\n        //\n        if (this.options.handleProtocols) {\n            protocol = this.options.handleProtocols(protocol, req);\n            if (protocol === false) return abortConnection(socket, 401);\n        } else {\n            protocol = protocol[0];\n        }\n        //\n        // Optionally call external client verification handler.\n        //\n        if (this.options.verifyClient) {\n            const info = {\n                origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                secure: !!(req.connection.authorized || req.connection.encrypted),\n                req\n            };\n            if (this.options.verifyClient.length === 2) {\n                this.options.verifyClient(info, (verified, code, message)=>{\n                    if (!verified) return abortConnection(socket, code || 401, message);\n                    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n                });\n                return;\n            }\n            if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n        }\n        this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n    }\n    /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */ completeUpgrade(protocol, extensions, version, req, socket, head, cb) {\n        //\n        // Destroy the socket if the client has already sent a FIN packet.\n        //\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        const key = crypto.createHash(\"sha1\").update(req.headers[\"sec-websocket-key\"] + constants.GUID, \"binary\").digest(\"base64\");\n        const headers = [\n            \"HTTP/1.1 101 Switching Protocols\",\n            \"Upgrade: websocket\",\n            \"Connection: Upgrade\",\n            `Sec-WebSocket-Accept: ${key}`\n        ];\n        if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        if (extensions[PerMessageDeflate.extensionName]) {\n            const params = extensions[PerMessageDeflate.extensionName].params;\n            const value = Extensions.format({\n                [PerMessageDeflate.extensionName]: [\n                    params\n                ]\n            });\n            headers.push(`Sec-WebSocket-Extensions: ${value}`);\n        }\n        //\n        // Allow external modification/inspection of handshake headers.\n        //\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        const client = new WebSocket([\n            socket,\n            head\n        ], null, {\n            maxPayload: this.options.maxPayload,\n            protocolVersion: version,\n            extensions,\n            protocol\n        });\n        if (this.clients) {\n            this.clients.add(client);\n            client.on(\"close\", ()=>this.clients.delete(client));\n        }\n        socket.removeListener(\"error\", socketError);\n        cb(client);\n    }\n}\nmodule.exports = WebSocketServer;\n/**\n * Handle premature socket errors.\n *\n * @private\n */ function socketError() {\n    this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */ function abortConnection(socket, code, message) {\n    if (socket.writable) {\n        message = message || http.STATUS_CODES[code];\n        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + `Content-Length: ${Buffer.byteLength(message)}\\r\\n` + \"\\r\\n\" + message);\n    }\n    socket.removeListener(\"error\", socketError);\n    socket.destroy();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL1dlYlNvY2tldFNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBRUQ7QUFFQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNSyxNQUFNTCxtQkFBT0EsQ0FBQztBQUVwQixNQUFNTSxvQkFBb0JOLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1PLGFBQWFQLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1RLFlBQVlSLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1TLFlBQVlULG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1VLFNBQVNYLFdBQVdXLE1BQU07QUFFaEM7Ozs7Q0FJQyxHQUNELE1BQU1DLHdCQUF3QlY7SUFDNUI7Ozs7Ozs7Ozs7Ozs7OztHQWVDLEdBQ0RXLFlBQWFDLE9BQU8sRUFBRUMsUUFBUSxDQUFFO1FBQzlCLEtBQUs7UUFFTEQsVUFBVUUsT0FBT0MsTUFBTSxDQUFDO1lBQ3RCQyxZQUFZLE1BQU0sT0FBTztZQUN6QkMsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLE1BQU07WUFDTkMsTUFBTTtRQUNSLEdBQUdkO1FBRUgsSUFBSUEsUUFBUWMsSUFBSSxJQUFJLFFBQVEsQ0FBQ2QsUUFBUVcsTUFBTSxJQUFJLENBQUNYLFFBQVFTLFFBQVEsRUFBRTtZQUNoRSxNQUFNLElBQUlNLFVBQVU7UUFDdEI7UUFFQSxJQUFJZixRQUFRYyxJQUFJLElBQUksTUFBTTtZQUN4QixJQUFJLENBQUNFLE9BQU8sR0FBR3pCLEtBQUswQixZQUFZLENBQUMsQ0FBQ0Ms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QUNGO0FBRUFtRCxPQUFPQyxPQUFPLEdBQUd2RjtBQUVqQjs7OztDQUlDLEdBQ0QsU0FBUzZDO0lBQ1AsSUFBSSxDQUFDSixPQUFPO0FBQ2Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1csZ0JBQWlCcEIsTUFBTSxFQUFFaUMsSUFBSSxFQUFFQyxPQUFPO0lBQzdDLElBQUlsQyxPQUFPcUMsUUFBUSxFQUFFO1FBQ25CSCxVQUFVQSxXQUFXekUsS0FBSzhCLFlBQVksQ0FBQzBDLEtBQUs7UUFDNUNqQyxPQUFPK0MsS0FBSyxDQUNWLENBQUMsU0FBUyxFQUFFZCxLQUFLLENBQUMsRUFBRXhFLEtBQUs4QixZQUFZLENBQUMwQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQ2pELDBCQUNBLGdDQUNBLENBQUMsZ0JBQWdCLEVBQUVsRSxPQUFPeUYsVUFBVSxDQUFDdEIsU0FBUyxJQUFJLENBQUMsR0FDbkQsU0FDQUE7SUFFSjtJQUVBbEMsT0FBT3FELGNBQWMsQ0FBQyxTQUFTeEM7SUFDL0JiLE9BQU9TLE9BQU87QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQtYW5hbHl0aWNzLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanM/YmExOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNhZmVCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IFVsdHJvbiA9IHJlcXVpcmUoJ3VsdHJvbicpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vUGVyTWVzc2FnZURlZmxhdGUnKTtcbmNvbnN0IEV4dGVuc2lvbnMgPSByZXF1aXJlKCcuL0V4dGVuc2lvbnMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL1dlYlNvY2tldCcpO1xuXG5jb25zdCBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlcjtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ob3N0IFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucG9ydCBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gb3B0aW9ucy5zZXJ2ZXIgQSBwcmUtY3JlYXRlZCBIVFRQL1Mgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnZlcmlmeUNsaWVudCBBbiBob29rIHRvIHJlamVjdCBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmhhbmRsZVByb3RvY29scyBBbiBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucGF0aCBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm5vU2VydmVyIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY2xpZW50VHJhY2tpbmcgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHRyYWNrIGNsaWVudHNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIEVuYWJsZS9kaXNhYmxlIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4ob3B0aW9ucy5wb3J0LCBvcHRpb25zLmhvc3QsIG9wdGlvbnMuYmFja2xvZywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3VsdHJvbiA9IG5ldyBVbHRyb24odGhpcy5fc2VydmVyKTtcbiAgICAgIHRoaXMuX3VsdHJvbi5vbignbGlzdGVuaW5nJywgKCkgPT4gdGhpcy5lbWl0KCdsaXN0ZW5pbmcnKSk7XG4gICAgICB0aGlzLl91bHRyb24ub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycikpO1xuICAgICAgdGhpcy5fdWx0cm9uLm9uKCd1cGdyYWRlJywgKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgKGNsaWVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIGNsaWVudCwgcmVxKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZSAoY2IpIHtcbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fdWx0cm9uLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3VsdHJvbiA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBDbG9zZSB0aGUgaHR0cCBzZXJ2ZXIgaWYgaXQgd2FzIGludGVybmFsbHkgY3JlYXRlZC5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBvcnQgIT0gbnVsbCkgcmV0dXJuIHNlcnZlci5jbG9zZShjYik7XG4gICAgfVxuXG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZSAocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoICYmIHVybC5wYXJzZShyZXEudXJsKS5wYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhbmRsZVVwZ3JhZGUgKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRFcnJvcik7XG5cbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG5cbiAgICBpZiAoXG4gICAgICByZXEubWV0aG9kICE9PSAnR0VUJyB8fCByZXEuaGVhZGVycy51cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnIHx8XG4gICAgICAhcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gfHwgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0Q29ubmVjdGlvbihzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IEV4dGVuc2lvbnMucGFyc2UoXG4gICAgICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydENvbm5lY3Rpb24oc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm90b2NvbCA9IChyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddIHx8ICcnKS5zcGxpdCgvLCAqLyk7XG5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKSB7XG4gICAgICBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2wsIHJlcSk7XG4gICAgICBpZiAocHJvdG9jb2wgPT09IGZhbHNlKSByZXR1cm4gYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgNDAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbFswXTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBjbGllbnQgdmVyaWZpY2F0aW9uIGhhbmRsZXIuXG4gICAgLy9cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudCkge1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5jb25uZWN0aW9uLmF1dGhvcml6ZWQgfHwgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSByZXR1cm4gYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIGNiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShwcm90b2NvbCwgZXh0ZW5zaW9ucywgdmVyc2lvbiwgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFRoZSBjaG9zZW4gc3VicHJvdG9jb2xcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gVGhlIFdlYlNvY2tldCBwcm90b2NvbCB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlIChwcm90b2NvbCwgZXh0ZW5zaW9ucywgdmVyc2lvbiwgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgLy9cbiAgICAvLyBEZXN0cm95IHRoZSBzb2NrZXQgaWYgdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBzZW50IGEgRklOIHBhY2tldC5cbiAgICAvL1xuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpIHJldHVybiBzb2NrZXQuZGVzdHJveSgpO1xuXG4gICAgY29uc3Qga2V5ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSArIGNvbnN0YW50cy5HVUlELCAnYmluYXJ5JylcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtrZXl9YFxuICAgIF07XG5cbiAgICBpZiAocHJvdG9jb2wpIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IEV4dGVuc2lvbnMuZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IFdlYlNvY2tldChbc29ja2V0LCBoZWFkXSwgbnVsbCwge1xuICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBwcm90b2NvbFZlcnNpb246IHZlcnNpb24sXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgcHJvdG9jb2xcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQoY2xpZW50KTtcbiAgICAgIGNsaWVudC5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmNsaWVudHMuZGVsZXRlKGNsaWVudCkpO1xuICAgIH1cblxuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRFcnJvcik7XG4gICAgY2IoY2xpZW50KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBIYW5kbGUgcHJlbWF0dXJlIHNvY2tldCBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0RXJyb3IgKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgSFRUUCByZXNwb25zZSBib2R5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydENvbm5lY3Rpb24gKHNvY2tldCwgY29kZSwgbWVzc2FnZSkge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgaHR0cC5TVEFUVVNfQ09ERVNbY29kZV07XG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICdDb25uZWN0aW9uOiBjbG9zZVxcclxcbicgK1xuICAgICAgJ0NvbnRlbnQtdHlwZTogdGV4dC9odG1sXFxyXFxuJyArXG4gICAgICBgQ29udGVudC1MZW5ndGg6ICR7QnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSl9XFxyXFxuYCArXG4gICAgICAnXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRFcnJvcik7XG4gIHNvY2tldC5kZXN0cm95KCk7XG59XG4iXSwibmFtZXMiOlsic2FmZUJ1ZmZlciIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJjcnlwdG8iLCJVbHRyb24iLCJodHRwIiwidXJsIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJFeHRlbnNpb25zIiwiY29uc3RhbnRzIiwiV2ViU29ja2V0IiwiQnVmZmVyIiwiV2ViU29ja2V0U2VydmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJPYmplY3QiLCJhc3NpZ24iLCJtYXhQYXlsb2FkIiwicGVyTWVzc2FnZURlZmxhdGUiLCJoYW5kbGVQcm90b2NvbHMiLCJjbGllbnRUcmFja2luZyIsInZlcmlmeUNsaWVudCIsIm5vU2VydmVyIiwiYmFja2xvZyIsInNlcnZlciIsImhvc3QiLCJwYXRoIiwicG9ydCIsIlR5cGVFcnJvciIsIl9zZXJ2ZXIiLCJjcmVhdGVTZXJ2ZXIiLCJyZXEiLCJyZXMiLCJib2R5IiwiU1RBVFVTX0NPREVTIiwid3JpdGVIZWFkIiwibGVuZ3RoIiwiZW5kIiwibGlzdGVuIiwiX3VsdHJvbiIsIm9uIiwiZW1pdCIsImVyciIsInNvY2tldCIsImhlYWQiLCJoYW5kbGVVcGdyYWRlIiwiY2xpZW50IiwiY2xpZW50cyIsIlNldCIsImNsb3NlIiwiY2IiLCJ0ZXJtaW5hdGUiLCJkZXN0cm95Iiwic2hvdWxkSGFuZGxlIiwicGFyc2UiLCJwYXRobmFtZSIsInNvY2tldEVycm9yIiwidmVyc2lvbiIsImhlYWRlcnMiLCJleHRlbnNpb25zIiwibWV0aG9kIiwidXBncmFkZSIsInRvTG93ZXJDYXNlIiwiYWJvcnRDb25uZWN0aW9uIiwib2ZmZXJzIiwiZXh0ZW5zaW9uTmFtZSIsImFjY2VwdCIsInByb3RvY29sIiwic3BsaXQiLCJpbmZvIiwib3JpZ2luIiwic2VjdXJlIiwiY29ubmVjdGlvbiIsImF1dGhvcml6ZWQiLCJlbmNyeXB0ZWQiLCJ2ZXJpZmllZCIsImNvZGUiLCJtZXNzYWdlIiwiY29tcGxldGVVcGdyYWRlIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsImtleSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJHVUlEIiwiZGlnZXN0IiwicHVzaCIsInBhcmFtcyIsInZhbHVlIiwiZm9ybWF0Iiwid3JpdGUiLCJjb25jYXQiLCJqb2luIiwicHJvdG9jb2xWZXJzaW9uIiwiYWRkIiwiZGVsZXRlIiwicmVtb3ZlTGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiYnl0ZUxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/WebSocketServer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ws/node_modules/safe-buffer/index.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-disable node/no-deprecated-api */ \nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar Buffer = buffer.Buffer;\n// alternative to using Object.keys for old browsers\nfunction copyProps(src, dst) {\n    for(var key in src){\n        dst[key] = src[key];\n    }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n    module.exports = buffer;\n} else {\n    // Copy properties from require('buffer')\n    copyProps(buffer, exports);\n    exports.Buffer = SafeBuffer;\n}\nfunction SafeBuffer(arg, encodingOrOffset, length) {\n    return Buffer(arg, encodingOrOffset, length);\n}\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer);\nSafeBuffer.from = function(arg, encodingOrOffset, length) {\n    if (typeof arg === \"number\") {\n        throw new TypeError(\"Argument must not be a number\");\n    }\n    return Buffer(arg, encodingOrOffset, length);\n};\nSafeBuffer.alloc = function(size, fill, encoding) {\n    if (typeof size !== \"number\") {\n        throw new TypeError(\"Argument must be a number\");\n    }\n    var buf = Buffer(size);\n    if (fill !== undefined) {\n        if (typeof encoding === \"string\") {\n            buf.fill(fill, encoding);\n        } else {\n            buf.fill(fill);\n        }\n    } else {\n        buf.fill(0);\n    }\n    return buf;\n};\nSafeBuffer.allocUnsafe = function(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError(\"Argument must be a number\");\n    }\n    return Buffer(size);\n};\nSafeBuffer.allocUnsafeSlow = function(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError(\"Argument must be a number\");\n    }\n    return buffer.SlowBuffer(size);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3Mvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QztBQUN6QyxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxTQUFTRixPQUFPRSxNQUFNO0FBRTFCLG9EQUFvRDtBQUNwRCxTQUFTQyxVQUFXQyxHQUFHLEVBQUVDLEdBQUc7SUFDMUIsSUFBSyxJQUFJQyxPQUFPRixJQUFLO1FBQ25CQyxHQUFHLENBQUNDLElBQUksR0FBR0YsR0FBRyxDQUFDRSxJQUFJO0lBQ3JCO0FBQ0Y7QUFDQSxJQUFJSixPQUFPSyxJQUFJLElBQUlMLE9BQU9NLEtBQUssSUFBSU4sT0FBT08sV0FBVyxJQUFJUCxPQUFPUSxlQUFlLEVBQUU7SUFDL0VDLE9BQU9DLE9BQU8sR0FBR1o7QUFDbkIsT0FBTztJQUNMLHlDQUF5QztJQUN6Q0csVUFBVUgsUUFBUVk7SUFDbEJBLGNBQWMsR0FBR0M7QUFDbkI7QUFFQSxTQUFTQSxXQUFZQyxHQUFHLEVBQUVDLGdCQUFnQixFQUFFQyxNQUFNO0lBQ2hELE9BQU9kLE9BQU9ZLEtBQUtDLGtCQUFrQkM7QUFDdkM7QUFFQSxrQ0FBa0M7QUFDbENiLFVBQVVELFFBQVFXO0FBRWxCQSxXQUFXTixJQUFJLEdBQUcsU0FBVU8sR0FBRyxFQUFFQyxnQkFBZ0IsRUFBRUMsTUFBTTtJQUN2RCxJQUFJLE9BQU9GLFFBQVEsVUFBVTtRQUMzQixNQUFNLElBQUlHLFVBQVU7SUFDdEI7SUFDQSxPQUFPZixPQUFPWSxLQUFLQyxrQkFBa0JDO0FBQ3ZDO0FBRUFILFdBQVdMLEtBQUssR0FBRyxTQUFVVSxJQUFJLEVBQUVDLElBQUksRUFBRUMsUUFBUTtJQUMvQyxJQUFJLE9BQU9GLFNBQVMsVUFBVTtRQUM1QixNQUFNLElBQUlELFVBQVU7SUFDdEI7SUFDQSxJQUFJSSxNQUFNbkIsT0FBT2dCO0lBQ2pCLElBQUlDLFNBQVNHLFdBQVc7UUFDdEIsSUFBSSxPQUFPRixhQUFhLFVBQVU7WUFDaENDLElBQUlGLElBQUksQ0FBQ0EsTUFBTUM7UUFDakIsT0FBTztZQUNMQyxJQUFJRixJQUFJLENBQUNBO1FBQ1g7SUFDRixPQUFPO1FBQ0xFLElBQUlGLElBQUksQ0FBQztJQUNYO0lBQ0EsT0FBT0U7QUFDVDtBQUVBUixXQUFXSixXQUFXLEdBQUcsU0FBVVMsSUFBSTtJQUNyQyxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QixNQUFNLElBQUlELFVBQVU7SUFDdEI7SUFDQSxPQUFPZixPQUFPZ0I7QUFDaEI7QUFFQUwsV0FBV0gsZUFBZSxHQUFHLFNBQVVRLElBQUk7SUFDekMsSUFBSSxPQUFPQSxTQUFTLFVBQVU7UUFDNUIsTUFBTSxJQUFJRCxVQUFVO0lBQ3RCO0lBQ0EsT0FBT2pCLE9BQU91QixVQUFVLENBQUNMO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0LWFuYWx5dGljcy8uL25vZGVfbW9kdWxlcy93cy9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanM/NWEzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIl0sIm5hbWVzIjpbImJ1ZmZlciIsInJlcXVpcmUiLCJCdWZmZXIiLCJjb3B5UHJvcHMiLCJzcmMiLCJkc3QiLCJrZXkiLCJmcm9tIiwiYWxsb2MiLCJhbGxvY1Vuc2FmZSIsImFsbG9jVW5zYWZlU2xvdyIsIm1vZHVsZSIsImV4cG9ydHMiLCJTYWZlQnVmZmVyIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImxlbmd0aCIsIlR5cGVFcnJvciIsInNpemUiLCJmaWxsIiwiZW5jb2RpbmciLCJidWYiLCJ1bmRlZmluZWQiLCJTbG93QnVmZmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/node_modules/safe-buffer/index.js\n");

/***/ })

};
;
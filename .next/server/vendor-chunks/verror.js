"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/verror";
exports.ids = ["vendor-chunks/verror"];
exports.modules = {

/***/ "(rsc)/./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * verror.js: richer JavaScript errors\n */ \nvar mod_assertplus = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"(rsc)/./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_isError = (__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\").isError);\nvar sprintf = mod_extsprintf.sprintf;\n/*\n * Public interface\n */ /* So you can 'var VError = require('verror')' */ module.exports = VError;\n/* For compatibility */ VError.VError = VError;\n/* Other exported classes */ VError.SError = SError;\nVError.WError = WError;\nVError.MultiError = MultiError;\n/*\n * Common function used to parse constructor arguments for VError, WError, and\n * SError.  Named arguments to this function:\n *\n *     strict\t\tforce strict interpretation of sprintf arguments, even\n *     \t\t\tif the options in \"argv\" don't say so\n *\n *     argv\t\terror's constructor arguments, which are to be\n *     \t\t\tinterpreted as described in README.md.  For quick\n *     \t\t\treference, \"argv\" has one of the following forms:\n *\n *          [ sprintf_args... ]           (argv[0] is a string)\n *          [ cause, sprintf_args... ]    (argv[0] is an Error)\n *          [ options, sprintf_args... ]  (argv[0] is an object)\n *\n * This function normalizes these forms, producing an object with the following\n * properties:\n *\n *    options           equivalent to \"options\" in third form.  This will never\n *    \t\t\tbe a direct reference to what the caller passed in\n *    \t\t\t(i.e., it may be a shallow copy), so it can be freely\n *    \t\t\tmodified.\n *\n *    shortmessage      result of sprintf(sprintf_args), taking options.strict\n *    \t\t\tinto account as described in README.md.\n */ function parseConstructorArguments(args) {\n    var argv, options, sprintf_args, shortmessage, k;\n    mod_assertplus.object(args, \"args\");\n    mod_assertplus.bool(args.strict, \"args.strict\");\n    mod_assertplus.array(args.argv, \"args.argv\");\n    argv = args.argv;\n    /*\n\t * First, figure out which form of invocation we've been given.\n\t */ if (argv.length === 0) {\n        options = {};\n        sprintf_args = [];\n    } else if (mod_isError(argv[0])) {\n        options = {\n            \"cause\": argv[0]\n        };\n        sprintf_args = argv.slice(1);\n    } else if (typeof argv[0] === \"object\") {\n        options = {};\n        for(k in argv[0]){\n            options[k] = argv[0][k];\n        }\n        sprintf_args = argv.slice(1);\n    } else {\n        mod_assertplus.string(argv[0], \"first argument to VError, SError, or WError \" + \"constructor must be a string, object, or Error\");\n        options = {};\n        sprintf_args = argv;\n    }\n    /*\n\t * Now construct the error's message.\n\t *\n\t * extsprintf (which we invoke here with our caller's arguments in order\n\t * to construct this Error's message) is strict in its interpretation of\n\t * values to be processed by the \"%s\" specifier.  The value passed to\n\t * extsprintf must actually be a string or something convertible to a\n\t * String using .toString().  Passing other values (notably \"null\" and\n\t * \"undefined\") is considered a programmer error.  The assumption is\n\t * that if you actually want to print the string \"null\" or \"undefined\",\n\t * then that's easy to do that when you're calling extsprintf; on the\n\t * other hand, if you did NOT want that (i.e., there's actually a bug\n\t * where the program assumes some variable is non-null and tries to\n\t * print it, which might happen when constructing a packet or file in\n\t * some specific format), then it's better to stop immediately than\n\t * produce bogus output.\n\t *\n\t * However, sometimes the bug is only in the code calling VError, and a\n\t * programmer might prefer to have the error message contain \"null\" or\n\t * \"undefined\" rather than have the bug in the error path crash the\n\t * program (making the first bug harder to identify).  For that reason,\n\t * by default VError converts \"null\" or \"undefined\" arguments to their\n\t * string representations and passes those to extsprintf.  Programmers\n\t * desiring the strict behavior can use the SError class or pass the\n\t * \"strict\" option to the VError constructor.\n\t */ mod_assertplus.object(options);\n    if (!options.strict && !args.strict) {\n        sprintf_args = sprintf_args.map(function(a) {\n            return a === null ? \"null\" : a === undefined ? \"undefined\" : a;\n        });\n    }\n    if (sprintf_args.length === 0) {\n        shortmessage = \"\";\n    } else {\n        shortmessage = sprintf.apply(null, sprintf_args);\n    }\n    return {\n        \"options\": options,\n        \"shortmessage\": shortmessage\n    };\n}\n/*\n * See README.md for reference documentation.\n */ function VError() {\n    var args, obj, parsed, cause, ctor, message, k;\n    args = Array.prototype.slice.call(arguments, 0);\n    /*\n\t * This is a regrettable pattern, but JavaScript's built-in Error class\n\t * is defined to work this way, so we allow the constructor to be called\n\t * without \"new\".\n\t */ if (!(this instanceof VError)) {\n        obj = Object.create(VError.prototype);\n        VError.apply(obj, arguments);\n        return obj;\n    }\n    /*\n\t * For convenience and backwards compatibility, we support several\n\t * different calling forms.  Normalize them here.\n\t */ parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    /*\n\t * If we've been given a name, apply it now.\n\t */ if (parsed.options.name) {\n        mod_assertplus.string(parsed.options.name, 'error\\'s \"name\" must be a string');\n        this.name = parsed.options.name;\n    }\n    /*\n\t * For debugging, we keep track of the original short message (attached\n\t * this Error particularly) separately from the complete message (which\n\t * includes the messages of our cause chain).\n\t */ this.jse_shortmsg = parsed.shortmessage;\n    message = parsed.shortmessage;\n    /*\n\t * If we've been given a cause, record a reference to it and update our\n\t * message appropriately.\n\t */ cause = parsed.options.cause;\n    if (cause) {\n        mod_assertplus.ok(mod_isError(cause), \"cause is not an Error\");\n        this.jse_cause = cause;\n        if (!parsed.options.skipCauseMessage) {\n            message += \": \" + cause.message;\n        }\n    }\n    /*\n\t * If we've been given an object with properties, shallow-copy that\n\t * here.  We don't want to use a deep copy in case there are non-plain\n\t * objects here, but we don't want to use the original object in case\n\t * the caller modifies it later.\n\t */ this.jse_info = {};\n    if (parsed.options.info) {\n        for(k in parsed.options.info){\n            this.jse_info[k] = parsed.options.info[k];\n        }\n    }\n    this.message = message;\n    Error.call(this, message);\n    if (Error.captureStackTrace) {\n        ctor = parsed.options.constructorOpt || this.constructor;\n        Error.captureStackTrace(this, ctor);\n    }\n    return this;\n}\nmod_util.inherits(VError, Error);\nVError.prototype.name = \"VError\";\nVError.prototype.toString = function ve_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    return str;\n};\n/*\n * This method is provided for compatibility.  New callers should use\n * VError.cause() instead.  That method also uses the saner `null` return value\n * when there is no cause.\n */ VError.prototype.cause = function ve_cause() {\n    var cause = VError.cause(this);\n    return cause === null ? undefined : cause;\n};\n/*\n * Static methods\n *\n * These class-level methods are provided so that callers can use them on\n * instances of Errors that are not VErrors.  New interfaces should be provided\n * only using static methods to eliminate the class of programming mistake where\n * people fail to check whether the Error object has the corresponding methods.\n */ VError.cause = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    return mod_isError(err.jse_cause) ? err.jse_cause : null;\n};\nVError.info = function(err) {\n    var rv, cause, k;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    cause = VError.cause(err);\n    if (cause !== null) {\n        rv = VError.info(cause);\n    } else {\n        rv = {};\n    }\n    if (typeof err.jse_info == \"object\" && err.jse_info !== null) {\n        for(k in err.jse_info){\n            rv[k] = err.jse_info[k];\n        }\n    }\n    return rv;\n};\nVError.findCauseByName = function(err, name) {\n    var cause;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.string(name, \"name\");\n    mod_assertplus.ok(name.length > 0, \"name cannot be empty\");\n    for(cause = err; cause !== null; cause = VError.cause(cause)){\n        mod_assertplus.ok(mod_isError(cause));\n        if (cause.name == name) {\n            return cause;\n        }\n    }\n    return null;\n};\nVError.hasCauseWithName = function(err, name) {\n    return VError.findCauseByName(err, name) !== null;\n};\nVError.fullStack = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    var cause = VError.cause(err);\n    if (cause) {\n        return err.stack + \"\\ncaused by: \" + VError.fullStack(cause);\n    }\n    return err.stack;\n};\nVError.errorFromList = function(errors) {\n    mod_assertplus.arrayOfObject(errors, \"errors\");\n    if (errors.length === 0) {\n        return null;\n    }\n    errors.forEach(function(e) {\n        mod_assertplus.ok(mod_isError(e));\n    });\n    if (errors.length == 1) {\n        return errors[0];\n    }\n    return new MultiError(errors);\n};\nVError.errorForEach = function(err, func) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.func(func, \"func\");\n    if (err instanceof MultiError) {\n        err.errors().forEach(function iterError(e) {\n            func(e);\n        });\n    } else {\n        func(err);\n    }\n};\n/*\n * SError is like VError, but stricter about types.  You cannot pass \"null\" or\n * \"undefined\" as string arguments to the formatter.\n */ function SError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof SError)) {\n        obj = Object.create(SError.prototype);\n        SError.apply(obj, arguments);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": true\n    });\n    options = parsed.options;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\n/*\n * We don't bother setting SError.prototype.name because once constructed,\n * SErrors are just like VErrors.\n */ mod_util.inherits(SError, VError);\n/*\n * Represents a collection of errors for the purpose of consumers that generally\n * only deal with one error.  Callers can extract the individual errors\n * contained in this object, but may also just treat it as a normal single\n * error, in which case a summary message will be printed.\n */ function MultiError(errors) {\n    mod_assertplus.array(errors, \"list of errors\");\n    mod_assertplus.ok(errors.length > 0, \"must be at least one error\");\n    this.ase_errors = errors;\n    VError.call(this, {\n        \"cause\": errors[0]\n    }, \"first of %d error%s\", errors.length, errors.length == 1 ? \"\" : \"s\");\n}\nmod_util.inherits(MultiError, VError);\nMultiError.prototype.name = \"MultiError\";\nMultiError.prototype.errors = function me_errors() {\n    return this.ase_errors.slice(0);\n};\n/*\n * See README.md for reference details.\n */ function WError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof WError)) {\n        obj = Object.create(WError.prototype);\n        WError.apply(obj, args);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    options = parsed.options;\n    options[\"skipCauseMessage\"] = true;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\nmod_util.inherits(WError, VError);\nWError.prototype.name = \"WError\";\nWError.prototype.toString = function we_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    if (this.jse_cause && this.jse_cause.message) str += \"; caused by \" + this.jse_cause.toString();\n    return str;\n};\n/*\n * For purely historical reasons, WError's cause() function allows you to set\n * the cause.\n */ WError.prototype.cause = function we_cause(c) {\n    if (mod_isError(c)) this.jse_cause = c;\n    return this.jse_cause;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmVycm9yL2xpYi92ZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7QUFFRCxJQUFJQSxpQkFBaUJDLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUcsY0FBY0gsa0dBQStCO0FBQ2pELElBQUlLLFVBQVVILGVBQWVHLE9BQU87QUFFcEM7O0NBRUMsR0FFRCwrQ0FBK0MsR0FDL0NDLE9BQU9DLE9BQU8sR0FBR0M7QUFDakIscUJBQXFCLEdBQ3JCQSxPQUFPQSxNQUFNLEdBQUdBO0FBQ2hCLDBCQUEwQixHQUMxQkEsT0FBT0MsTUFBTSxHQUFHQTtBQUNoQkQsT0FBT0UsTUFBTSxHQUFHQTtBQUNoQkYsT0FBT0csVUFBVSxHQUFHQTtBQUVwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELFNBQVNDLDBCQUEwQkMsSUFBSTtJQUV0QyxJQUFJQyxNQUFNQyxTQUFTQyxjQUFjQyxjQUFjQztJQUUvQ25CLGVBQWVvQixNQUFNLENBQUNOLE1BQU07SUFDNUJkLGVBQWVxQixJQUFJLENBQUNQLEtBQUtRLE1BQU0sRUFBRTtJQUNqQ3RCLGVBQWV1QixLQUFLLENBQUNULEtBQUtDLElBQUksRUFBRTtJQUNoQ0EsT0FBT0QsS0FBS0MsSUFBSTtJQUVoQjs7RUFFQyxHQUNELElBQUlBLEtBQUtTLE1BQU0sS0FBSyxHQUFHO1FBQ3RCUixVQUFVLENBQUM7UUFDWEMsZUFBZSxFQUFFO0lBQ2xCLE9BQU8sSUFBSWIsWUFBWVcsSUFBSSxDQUFDLEVBQUUsR0FBRztRQUNoQ0MsVUFBVTtZQUFFLFNBQVNELElBQUksQ0FBQyxFQUFFO1FBQUM7UUFDN0JFLGVBQWVGLEtBQUtVLEtBQUssQ0FBQztJQUMzQixPQUFPLElBQUksT0FBUVYsSUFBSSxDQUFDLEVBQUUsS0FBTSxVQUFVO1FBQ3pDQyxVQUFVLENBQUM7UUFDWCxJ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UUFBUSxHQUFHLFNBQVNxQjtJQUVwQyxJQUFJbkIsTUFBTyxJQUFJLENBQUNDLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQ2YsSUFBSSxJQUNsRCxJQUFJLENBQUNVLFdBQVcsQ0FBQ1YsSUFBSSxJQUFJLElBQUksQ0FBQ1UsV0FBVyxDQUFDZixTQUFTLENBQUNLLElBQUk7SUFDekQsSUFBSSxJQUFJLENBQUNQLE9BQU8sRUFDZnFCLE9BQU8sT0FBTyxJQUFJLENBQUNyQixPQUFPO0lBQzNCLElBQUksSUFBSSxDQUFDVSxTQUFTLElBQUksSUFBSSxDQUFDQSxTQUFTLENBQUNWLE9BQU8sRUFDM0NxQixPQUFPLGlCQUFpQixJQUFJLENBQUNYLFNBQVMsQ0FBQ1MsUUFBUTtJQUVoRCxPQUFRRTtBQUNUO0FBRUE7OztDQUdDLEdBQ0Q3QyxPQUFPMEIsU0FBUyxDQUFDSixLQUFLLEdBQUcsU0FBUzJDLFNBQVNDLENBQUM7SUFFM0MsSUFBSXpFLFlBQVl5RSxJQUNmLElBQUksQ0FBQ2hDLFNBQVMsR0FBR2dDO0lBRWxCLE9BQVEsSUFBSSxDQUFDaEMsU0FBUztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvdmVycm9yL2xpYi92ZXJyb3IuanM/ZjBhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogdmVycm9yLmpzOiByaWNoZXIgSmF2YVNjcmlwdCBlcnJvcnNcbiAqL1xuXG52YXIgbW9kX2Fzc2VydHBsdXMgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIG1vZF91dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgbW9kX2V4dHNwcmludGYgPSByZXF1aXJlKCdleHRzcHJpbnRmJyk7XG52YXIgbW9kX2lzRXJyb3IgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKS5pc0Vycm9yO1xudmFyIHNwcmludGYgPSBtb2RfZXh0c3ByaW50Zi5zcHJpbnRmO1xuXG4vKlxuICogUHVibGljIGludGVyZmFjZVxuICovXG5cbi8qIFNvIHlvdSBjYW4gJ3ZhciBWRXJyb3IgPSByZXF1aXJlKCd2ZXJyb3InKScgKi9cbm1vZHVsZS5leHBvcnRzID0gVkVycm9yO1xuLyogRm9yIGNvbXBhdGliaWxpdHkgKi9cblZFcnJvci5WRXJyb3IgPSBWRXJyb3I7XG4vKiBPdGhlciBleHBvcnRlZCBjbGFzc2VzICovXG5WRXJyb3IuU0Vycm9yID0gU0Vycm9yO1xuVkVycm9yLldFcnJvciA9IFdFcnJvcjtcblZFcnJvci5NdWx0aUVycm9yID0gTXVsdGlFcnJvcjtcblxuLypcbiAqIENvbW1vbiBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIGNvbnN0cnVjdG9yIGFyZ3VtZW50cyBmb3IgVkVycm9yLCBXRXJyb3IsIGFuZFxuICogU0Vycm9yLiAgTmFtZWQgYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb246XG4gKlxuICogICAgIHN0cmljdFx0XHRmb3JjZSBzdHJpY3QgaW50ZXJwcmV0YXRpb24gb2Ygc3ByaW50ZiBhcmd1bWVudHMsIGV2ZW5cbiAqICAgICBcdFx0XHRpZiB0aGUgb3B0aW9ucyBpbiBcImFyZ3ZcIiBkb24ndCBzYXkgc29cbiAqXG4gKiAgICAgYXJndlx0XHRlcnJvcidzIGNvbnN0cnVjdG9yIGFyZ3VtZW50cywgd2hpY2ggYXJlIHRvIGJlXG4gKiAgICAgXHRcdFx0aW50ZXJwcmV0ZWQgYXMgZGVzY3JpYmVkIGluIFJFQURNRS5tZC4gIEZvciBxdWlja1xuICogICAgIFx0XHRcdHJlZmVyZW5jZSwgXCJhcmd2XCIgaGFzIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxuICpcbiAqICAgICAgICAgIFsgc3ByaW50Zl9hcmdzLi4uIF0gICAgICAgICAgIChhcmd2WzBdIGlzIGEgc3RyaW5nKVxuICogICAgICAgICAgWyBjYXVzZSwgc3ByaW50Zl9hcmdzLi4uIF0gICAgKGFyZ3ZbMF0gaXMgYW4gRXJyb3IpXG4gKiAgICAgICAgICBbIG9wdGlvbnMsIHNwcmludGZfYXJncy4uLiBdICAoYXJndlswXSBpcyBhbiBvYmplY3QpXG4gKlxuICogVGhpcyBmdW5jdGlvbiBub3JtYWxpemVzIHRoZXNlIGZvcm1zLCBwcm9kdWNpbmcgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgICBvcHRpb25zICAgICAgICAgICBlcXVpdmFsZW50IHRvIFwib3B0aW9uc1wiIGluIHRoaXJkIGZvcm0uICBUaGlzIHdpbGwgbmV2ZXJcbiAqICAgIFx0XHRcdGJlIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB3aGF0IHRoZSBjYWxsZXIgcGFzc2VkIGluXG4gKiAgICBcdFx0XHQoaS5lLiwgaXQgbWF5IGJlIGEgc2hhbGxvdyBjb3B5KSwgc28gaXQgY2FuIGJlIGZyZWVseVxuICogICAgXHRcdFx0bW9kaWZpZWQuXG4gKlxuICogICAgc2hvcnRtZXNzYWdlICAgICAgcmVzdWx0IG9mIHNwcmludGYoc3ByaW50Zl9hcmdzKSwgdGFraW5nIG9wdGlvbnMuc3RyaWN0XG4gKiAgICBcdFx0XHRpbnRvIGFjY291bnQgYXMgZGVzY3JpYmVkIGluIFJFQURNRS5tZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyhhcmdzKVxue1xuXHR2YXIgYXJndiwgb3B0aW9ucywgc3ByaW50Zl9hcmdzLCBzaG9ydG1lc3NhZ2UsIGs7XG5cblx0bW9kX2Fzc2VydHBsdXMub2JqZWN0KGFyZ3MsICdhcmdzJyk7XG5cdG1vZF9hc3NlcnRwbHVzLmJvb2woYXJncy5zdHJpY3QsICdhcmdzLnN0cmljdCcpO1xuXHRtb2RfYXNzZXJ0cGx1cy5hcnJheShhcmdzLmFyZ3YsICdhcmdzLmFyZ3YnKTtcblx0YXJndiA9IGFyZ3MuYXJndjtcblxuXHQvKlxuXHQgKiBGaXJzdCwgZmlndXJlIG91dCB3aGljaCBmb3JtIG9mIGludm9jYXRpb24gd2UndmUgYmVlbiBnaXZlbi5cblx0ICovXG5cdGlmIChhcmd2Lmxlbmd0aCA9PT0gMCkge1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRzcHJpbnRmX2FyZ3MgPSBbXTtcblx0fSBlbHNlIGlmIChtb2RfaXNFcnJvcihhcmd2WzBdKSkge1xuXHRcdG9wdGlvbnMgPSB7ICdjYXVzZSc6IGFyZ3ZbMF0gfTtcblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2LnNsaWNlKDEpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiAoYXJndlswXSkgPT09ICdvYmplY3QnKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvciAoayBpbiBhcmd2WzBdKSB7XG5cdFx0XHRvcHRpb25zW2tdID0gYXJndlswXVtrXTtcblx0XHR9XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndi5zbGljZSgxKTtcblx0fSBlbHNlIHtcblx0XHRtb2RfYXNzZXJ0cGx1cy5zdHJpbmcoYXJndlswXSxcblx0XHQgICAgJ2ZpcnN0IGFyZ3VtZW50IHRvIFZFcnJvciwgU0Vycm9yLCBvciBXRXJyb3IgJyArXG5cdFx0ICAgICdjb25zdHJ1Y3RvciBtdXN0IGJlIGEgc3RyaW5nLCBvYmplY3QsIG9yIEVycm9yJyk7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Y7XG5cdH1cblxuXHQvKlxuXHQgKiBOb3cgY29uc3RydWN0IHRoZSBlcnJvcidzIG1lc3NhZ2UuXG5cdCAqXG5cdCAqIGV4dHNwcmludGYgKHdoaWNoIHdlIGludm9rZSBoZXJlIHdpdGggb3VyIGNhbGxlcidzIGFyZ3VtZW50cyBpbiBvcmRlclxuXHQgKiB0byBjb25zdHJ1Y3QgdGhpcyBFcnJvcidzIG1lc3NhZ2UpIGlzIHN0cmljdCBpbiBpdHMgaW50ZXJwcmV0YXRpb24gb2Zcblx0ICogdmFsdWVzIHRvIGJlIHByb2Nlc3NlZCBieSB0aGUgXCIlc1wiIHNwZWNpZmllci4gIFRoZSB2YWx1ZSBwYXNzZWQgdG9cblx0ICogZXh0c3ByaW50ZiBtdXN0IGFjdHVhbGx5IGJlIGEgc3RyaW5nIG9yIHNvbWV0aGluZyBjb252ZXJ0aWJsZSB0byBhXG5cdCAqIFN0cmluZyB1c2luZyAudG9TdHJpbmcoKS4gIFBhc3Npbmcgb3RoZXIgdmFsdWVzIChub3RhYmx5IFwibnVsbFwiIGFuZFxuXHQgKiBcInVuZGVmaW5lZFwiKSBpcyBjb25zaWRlcmVkIGEgcHJvZ3JhbW1lciBlcnJvci4gIFRoZSBhc3N1bXB0aW9uIGlzXG5cdCAqIHRoYXQgaWYgeW91IGFjdHVhbGx5IHdhbnQgdG8gcHJpbnQgdGhlIHN0cmluZyBcIm51bGxcIiBvciBcInVuZGVmaW5lZFwiLFxuXHQgKiB0aGVuIHRoYXQncyBlYXN5IHRvIGRvIHRoYXQgd2hlbiB5b3UncmUgY2FsbGluZyBleHRzcHJpbnRmOyBvbiB0aGVcblx0ICogb3RoZXIgaGFuZCwgaWYgeW91IGRpZCBOT1Qgd2FudCB0aGF0IChpLmUuLCB0aGVyZSdzIGFjdHVhbGx5IGEgYnVnXG5cdCAqIHdoZXJlIHRoZSBwcm9ncmFtIGFzc3VtZXMgc29tZSB2YXJpYWJsZSBpcyBub24tbnVsbCBhbmQgdHJpZXMgdG9cblx0ICogcHJpbnQgaXQsIHdoaWNoIG1pZ2h0IGhhcHBlbiB3aGVuIGNvbnN0cnVjdGluZyBhIHBhY2tldCBvciBmaWxlIGluXG5cdCAqIHNvbWUgc3BlY2lmaWMgZm9ybWF0KSwgdGhlbiBpdCdzIGJldHRlciB0byBzdG9wIGltbWVkaWF0ZWx5IHRoYW5cblx0ICogcHJvZHVjZSBib2d1cyBvdXRwdXQuXG5cdCAqXG5cdCAqIEhvd2V2ZXIsIHNvbWV0aW1lcyB0aGUgYnVnIGlzIG9ubHkgaW4gdGhlIGNvZGUgY2FsbGluZyBWRXJyb3IsIGFuZCBhXG5cdCAqIHByb2dyYW1tZXIgbWlnaHQgcHJlZmVyIHRvIGhhdmUgdGhlIGVycm9yIG1lc3NhZ2UgY29udGFpbiBcIm51bGxcIiBvclxuXHQgKiBcInVuZGVmaW5lZFwiIHJhdGhlciB0aGFuIGhhdmUgdGhlIGJ1ZyBpbiB0aGUgZXJyb3IgcGF0aCBjcmFzaCB0aGVcblx0ICogcHJvZ3JhbSAobWFraW5nIHRoZSBmaXJzdCBidWcgaGFyZGVyIHRvIGlkZW50aWZ5KS4gIEZvciB0aGF0IHJlYXNvbixcblx0ICogYnkgZGVmYXVsdCBWRXJyb3IgY29udmVydHMgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIiBhcmd1bWVudHMgdG8gdGhlaXJcblx0ICogc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBhbmQgcGFzc2VzIHRob3NlIHRvIGV4dHNwcmludGYuICBQcm9ncmFtbWVyc1xuXHQgKiBkZXNpcmluZyB0aGUgc3RyaWN0IGJlaGF2aW9yIGNhbiB1c2UgdGhlIFNFcnJvciBjbGFzcyBvciBwYXNzIHRoZVxuXHQgKiBcInN0cmljdFwiIG9wdGlvbiB0byB0aGUgVkVycm9yIGNvbnN0cnVjdG9yLlxuXHQgKi9cblx0bW9kX2Fzc2VydHBsdXMub2JqZWN0KG9wdGlvbnMpO1xuXHRpZiAoIW9wdGlvbnMuc3RyaWN0ICYmICFhcmdzLnN0cmljdCkge1xuXHRcdHNwcmludGZfYXJncyA9IHNwcmludGZfYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcblx0XHRcdHJldHVybiAoYSA9PT0gbnVsbCA/ICdudWxsJyA6XG5cdFx0XHQgICAgYSA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBhKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmIChzcHJpbnRmX2FyZ3MubGVuZ3RoID09PSAwKSB7XG5cdFx0c2hvcnRtZXNzYWdlID0gJyc7XG5cdH0gZWxzZSB7XG5cdFx0c2hvcnRtZXNzYWdlID0gc3ByaW50Zi5hcHBseShudWxsLCBzcHJpbnRmX2FyZ3MpO1xuXHR9XG5cblx0cmV0dXJuICh7XG5cdCAgICAnb3B0aW9ucyc6IG9wdGlvbnMsXG5cdCAgICAnc2hvcnRtZXNzYWdlJzogc2hvcnRtZXNzYWdlXG5cdH0pO1xufVxuXG4vKlxuICogU2VlIFJFQURNRS5tZCBmb3IgcmVmZXJlbmNlIGRvY3VtZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIFZFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgY2F1c2UsIGN0b3IsIG1lc3NhZ2UsIGs7XG5cblx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cblx0Lypcblx0ICogVGhpcyBpcyBhIHJlZ3JldHRhYmxlIHBhdHRlcm4sIGJ1dCBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gRXJyb3IgY2xhc3Ncblx0ICogaXMgZGVmaW5lZCB0byB3b3JrIHRoaXMgd2F5LCBzbyB3ZSBhbGxvdyB0aGUgY29uc3RydWN0b3IgdG8gYmUgY2FsbGVkXG5cdCAqIHdpdGhvdXQgXCJuZXdcIi5cblx0ICovXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBWRXJyb3IpKSB7XG5cdFx0b2JqID0gT2JqZWN0LmNyZWF0ZShWRXJyb3IucHJvdG90eXBlKTtcblx0XHRWRXJyb3IuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdC8qXG5cdCAqIEZvciBjb252ZW5pZW5jZSBhbmQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIHN1cHBvcnQgc2V2ZXJhbFxuXHQgKiBkaWZmZXJlbnQgY2FsbGluZyBmb3Jtcy4gIE5vcm1hbGl6ZSB0aGVtIGhlcmUuXG5cdCAqL1xuXHRwYXJzZWQgPSBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKHtcblx0ICAgICdhcmd2JzogYXJncyxcblx0ICAgICdzdHJpY3QnOiBmYWxzZVxuXHR9KTtcblxuXHQvKlxuXHQgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgbmFtZSwgYXBwbHkgaXQgbm93LlxuXHQgKi9cblx0aWYgKHBhcnNlZC5vcHRpb25zLm5hbWUpIHtcblx0XHRtb2RfYXNzZXJ0cGx1cy5zdHJpbmcocGFyc2VkLm9wdGlvbnMubmFtZSxcblx0XHQgICAgJ2Vycm9yXFwncyBcIm5hbWVcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0dGhpcy5uYW1lID0gcGFyc2VkLm9wdGlvbnMubmFtZTtcblx0fVxuXG5cdC8qXG5cdCAqIEZvciBkZWJ1Z2dpbmcsIHdlIGtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIHNob3J0IG1lc3NhZ2UgKGF0dGFjaGVkXG5cdCAqIHRoaXMgRXJyb3IgcGFydGljdWxhcmx5KSBzZXBhcmF0ZWx5IGZyb20gdGhlIGNvbXBsZXRlIG1lc3NhZ2UgKHdoaWNoXG5cdCAqIGluY2x1ZGVzIHRoZSBtZXNzYWdlcyBvZiBvdXIgY2F1c2UgY2hhaW4pLlxuXHQgKi9cblx0dGhpcy5qc2Vfc2hvcnRtc2cgPSBwYXJzZWQuc2hvcnRtZXNzYWdlO1xuXHRtZXNzYWdlID0gcGFyc2VkLnNob3J0bWVzc2FnZTtcblxuXHQvKlxuXHQgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgY2F1c2UsIHJlY29yZCBhIHJlZmVyZW5jZSB0byBpdCBhbmQgdXBkYXRlIG91clxuXHQgKiBtZXNzYWdlIGFwcHJvcHJpYXRlbHkuXG5cdCAqL1xuXHRjYXVzZSA9IHBhcnNlZC5vcHRpb25zLmNhdXNlO1xuXHRpZiAoY2F1c2UpIHtcblx0XHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihjYXVzZSksICdjYXVzZSBpcyBub3QgYW4gRXJyb3InKTtcblx0XHR0aGlzLmpzZV9jYXVzZSA9IGNhdXNlO1xuXG5cdFx0aWYgKCFwYXJzZWQub3B0aW9ucy5za2lwQ2F1c2VNZXNzYWdlKSB7XG5cdFx0XHRtZXNzYWdlICs9ICc6ICcgKyBjYXVzZS5tZXNzYWdlO1xuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcywgc2hhbGxvdy1jb3B5IHRoYXRcblx0ICogaGVyZS4gIFdlIGRvbid0IHdhbnQgdG8gdXNlIGEgZGVlcCBjb3B5IGluIGNhc2UgdGhlcmUgYXJlIG5vbi1wbGFpblxuXHQgKiBvYmplY3RzIGhlcmUsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIHVzZSB0aGUgb3JpZ2luYWwgb2JqZWN0IGluIGNhc2Vcblx0ICogdGhlIGNhbGxlciBtb2RpZmllcyBpdCBsYXRlci5cblx0ICovXG5cdHRoaXMuanNlX2luZm8gPSB7fTtcblx0aWYgKHBhcnNlZC5vcHRpb25zLmluZm8pIHtcblx0XHRmb3IgKGsgaW4gcGFyc2VkLm9wdGlvbnMuaW5mbykge1xuXHRcdFx0dGhpcy5qc2VfaW5mb1trXSA9IHBhcnNlZC5vcHRpb25zLmluZm9ba107XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0RXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcblx0XHRjdG9yID0gcGFyc2VkLm9wdGlvbnMuY29uc3RydWN0b3JPcHQgfHwgdGhpcy5jb25zdHJ1Y3Rvcjtcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBjdG9yKTtcblx0fVxuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbm1vZF91dGlsLmluaGVyaXRzKFZFcnJvciwgRXJyb3IpO1xuVkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZFcnJvcic7XG5cblZFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB2ZV90b1N0cmluZygpXG57XG5cdHZhciBzdHIgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmIHRoaXMubmFtZSB8fFxuXHRcdHRoaXMuY29uc3RydWN0b3IubmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lKTtcblx0aWYgKHRoaXMubWVzc2FnZSlcblx0XHRzdHIgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblxuXHRyZXR1cm4gKHN0cik7XG59O1xuXG4vKlxuICogVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgZm9yIGNvbXBhdGliaWxpdHkuICBOZXcgY2FsbGVycyBzaG91bGQgdXNlXG4gKiBWRXJyb3IuY2F1c2UoKSBpbnN0ZWFkLiAgVGhhdCBtZXRob2QgYWxzbyB1c2VzIHRoZSBzYW5lciBgbnVsbGAgcmV0dXJuIHZhbHVlXG4gKiB3aGVuIHRoZXJlIGlzIG5vIGNhdXNlLlxuICovXG5WRXJyb3IucHJvdG90eXBlLmNhdXNlID0gZnVuY3Rpb24gdmVfY2F1c2UoKVxue1xuXHR2YXIgY2F1c2UgPSBWRXJyb3IuY2F1c2UodGhpcyk7XG5cdHJldHVybiAoY2F1c2UgPT09IG51bGwgPyB1bmRlZmluZWQgOiBjYXVzZSk7XG59O1xuXG4vKlxuICogU3RhdGljIG1ldGhvZHNcbiAqXG4gKiBUaGVzZSBjbGFzcy1sZXZlbCBtZXRob2RzIGFyZSBwcm92aWRlZCBzbyB0aGF0IGNhbGxlcnMgY2FuIHVzZSB0aGVtIG9uXG4gKiBpbnN0YW5jZXMgb2YgRXJyb3JzIHRoYXQgYXJlIG5vdCBWRXJyb3JzLiAgTmV3IGludGVyZmFjZXMgc2hvdWxkIGJlIHByb3ZpZGVkXG4gKiBvbmx5IHVzaW5nIHN0YXRpYyBtZXRob2RzIHRvIGVsaW1pbmF0ZSB0aGUgY2xhc3Mgb2YgcHJvZ3JhbW1pbmcgbWlzdGFrZSB3aGVyZVxuICogcGVvcGxlIGZhaWwgdG8gY2hlY2sgd2hldGhlciB0aGUgRXJyb3Igb2JqZWN0IGhhcyB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuICovXG5cblZFcnJvci5jYXVzZSA9IGZ1bmN0aW9uIChlcnIpXG57XG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRyZXR1cm4gKG1vZF9pc0Vycm9yKGVyci5qc2VfY2F1c2UpID8gZXJyLmpzZV9jYXVzZSA6IG51bGwpO1xufTtcblxuVkVycm9yLmluZm8gPSBmdW5jdGlvbiAoZXJyKVxue1xuXHR2YXIgcnYsIGNhdXNlLCBrO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRjYXVzZSA9IFZFcnJvci5jYXVzZShlcnIpO1xuXHRpZiAoY2F1c2UgIT09IG51bGwpIHtcblx0XHRydiA9IFZFcnJvci5pbmZvKGNhdXNlKTtcblx0fSBlbHNlIHtcblx0XHRydiA9IHt9O1xuXHR9XG5cblx0aWYgKHR5cGVvZiAoZXJyLmpzZV9pbmZvKSA9PSAnb2JqZWN0JyAmJiBlcnIuanNlX2luZm8gIT09IG51bGwpIHtcblx0XHRmb3IgKGsgaW4gZXJyLmpzZV9pbmZvKSB7XG5cdFx0XHRydltrXSA9IGVyci5qc2VfaW5mb1trXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKHJ2KTtcbn07XG5cblZFcnJvci5maW5kQ2F1c2VCeU5hbWUgPSBmdW5jdGlvbiAoZXJyLCBuYW1lKVxue1xuXHR2YXIgY2F1c2U7XG5cblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdG1vZF9hc3NlcnRwbHVzLnN0cmluZyhuYW1lLCAnbmFtZScpO1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhuYW1lLmxlbmd0aCA+IDAsICduYW1lIGNhbm5vdCBiZSBlbXB0eScpO1xuXG5cdGZvciAoY2F1c2UgPSBlcnI7IGNhdXNlICE9PSBudWxsOyBjYXVzZSA9IFZFcnJvci5jYXVzZShjYXVzZSkpIHtcblx0XHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihjYXVzZSkpO1xuXHRcdGlmIChjYXVzZS5uYW1lID09IG5hbWUpIHtcblx0XHRcdHJldHVybiAoY2F1c2UpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAobnVsbCk7XG59O1xuXG5WRXJyb3IuaGFzQ2F1c2VXaXRoTmFtZSA9IGZ1bmN0aW9uIChlcnIsIG5hbWUpXG57XG5cdHJldHVybiAoVkVycm9yLmZpbmRDYXVzZUJ5TmFtZShlcnIsIG5hbWUpICE9PSBudWxsKTtcbn07XG5cblZFcnJvci5mdWxsU3RhY2sgPSBmdW5jdGlvbiAoZXJyKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblxuXHR2YXIgY2F1c2UgPSBWRXJyb3IuY2F1c2UoZXJyKTtcblxuXHRpZiAoY2F1c2UpIHtcblx0XHRyZXR1cm4gKGVyci5zdGFjayArICdcXG5jYXVzZWQgYnk6ICcgKyBWRXJyb3IuZnVsbFN0YWNrKGNhdXNlKSk7XG5cdH1cblxuXHRyZXR1cm4gKGVyci5zdGFjayk7XG59O1xuXG5WRXJyb3IuZXJyb3JGcm9tTGlzdCA9IGZ1bmN0aW9uIChlcnJvcnMpXG57XG5cdG1vZF9hc3NlcnRwbHVzLmFycmF5T2ZPYmplY3QoZXJyb3JzLCAnZXJyb3JzJyk7XG5cblx0aWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gKG51bGwpO1xuXHR9XG5cblx0ZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0XHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlKSk7XG5cdH0pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID09IDEpIHtcblx0XHRyZXR1cm4gKGVycm9yc1swXSk7XG5cdH1cblxuXHRyZXR1cm4gKG5ldyBNdWx0aUVycm9yKGVycm9ycykpO1xufTtcblxuVkVycm9yLmVycm9yRm9yRWFjaCA9IGZ1bmN0aW9uIChlcnIsIGZ1bmMpXG57XG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRtb2RfYXNzZXJ0cGx1cy5mdW5jKGZ1bmMsICdmdW5jJyk7XG5cblx0aWYgKGVyciBpbnN0YW5jZW9mIE11bHRpRXJyb3IpIHtcblx0XHRlcnIuZXJyb3JzKCkuZm9yRWFjaChmdW5jdGlvbiBpdGVyRXJyb3IoZSkgeyBmdW5jKGUpOyB9KTtcblx0fSBlbHNlIHtcblx0XHRmdW5jKGVycik7XG5cdH1cbn07XG5cblxuLypcbiAqIFNFcnJvciBpcyBsaWtlIFZFcnJvciwgYnV0IHN0cmljdGVyIGFib3V0IHR5cGVzLiAgWW91IGNhbm5vdCBwYXNzIFwibnVsbFwiIG9yXG4gKiBcInVuZGVmaW5lZFwiIGFzIHN0cmluZyBhcmd1bWVudHMgdG8gdGhlIGZvcm1hdHRlci5cbiAqL1xuZnVuY3Rpb24gU0Vycm9yKClcbntcblx0dmFyIGFyZ3MsIG9iaiwgcGFyc2VkLCBvcHRpb25zO1xuXG5cdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgU0Vycm9yKSkge1xuXHRcdG9iaiA9IE9iamVjdC5jcmVhdGUoU0Vycm9yLnByb3RvdHlwZSk7XG5cdFx0U0Vycm9yLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHRwYXJzZWQgPSBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKHtcblx0ICAgICdhcmd2JzogYXJncyxcblx0ICAgICdzdHJpY3QnOiB0cnVlXG5cdH0pO1xuXG5cdG9wdGlvbnMgPSBwYXJzZWQub3B0aW9ucztcblx0VkVycm9yLmNhbGwodGhpcywgb3B0aW9ucywgJyVzJywgcGFyc2VkLnNob3J0bWVzc2FnZSk7XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxuLypcbiAqIFdlIGRvbid0IGJvdGhlciBzZXR0aW5nIFNFcnJvci5wcm90b3R5cGUubmFtZSBiZWNhdXNlIG9uY2UgY29uc3RydWN0ZWQsXG4gKiBTRXJyb3JzIGFyZSBqdXN0IGxpa2UgVkVycm9ycy5cbiAqL1xubW9kX3V0aWwuaW5oZXJpdHMoU0Vycm9yLCBWRXJyb3IpO1xuXG5cbi8qXG4gKiBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBlcnJvcnMgZm9yIHRoZSBwdXJwb3NlIG9mIGNvbnN1bWVycyB0aGF0IGdlbmVyYWxseVxuICogb25seSBkZWFsIHdpdGggb25lIGVycm9yLiAgQ2FsbGVycyBjYW4gZXh0cmFjdCB0aGUgaW5kaXZpZHVhbCBlcnJvcnNcbiAqIGNvbnRhaW5lZCBpbiB0aGlzIG9iamVjdCwgYnV0IG1heSBhbHNvIGp1c3QgdHJlYXQgaXQgYXMgYSBub3JtYWwgc2luZ2xlXG4gKiBlcnJvciwgaW4gd2hpY2ggY2FzZSBhIHN1bW1hcnkgbWVzc2FnZSB3aWxsIGJlIHByaW50ZWQuXG4gKi9cbmZ1bmN0aW9uIE11bHRpRXJyb3IoZXJyb3JzKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5hcnJheShlcnJvcnMsICdsaXN0IG9mIGVycm9ycycpO1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhlcnJvcnMubGVuZ3RoID4gMCwgJ211c3QgYmUgYXQgbGVhc3Qgb25lIGVycm9yJyk7XG5cdHRoaXMuYXNlX2Vycm9ycyA9IGVycm9ycztcblxuXHRWRXJyb3IuY2FsbCh0aGlzLCB7XG5cdCAgICAnY2F1c2UnOiBlcnJvcnNbMF1cblx0fSwgJ2ZpcnN0IG9mICVkIGVycm9yJXMnLCBlcnJvcnMubGVuZ3RoLCBlcnJvcnMubGVuZ3RoID09IDEgPyAnJyA6ICdzJyk7XG59XG5cbm1vZF91dGlsLmluaGVyaXRzKE11bHRpRXJyb3IsIFZFcnJvcik7XG5NdWx0aUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ011bHRpRXJyb3InO1xuXG5NdWx0aUVycm9yLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbiBtZV9lcnJvcnMoKVxue1xuXHRyZXR1cm4gKHRoaXMuYXNlX2Vycm9ycy5zbGljZSgwKSk7XG59O1xuXG5cbi8qXG4gKiBTZWUgUkVBRE1FLm1kIGZvciByZWZlcmVuY2UgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gV0Vycm9yKClcbntcblx0dmFyIGFyZ3MsIG9iaiwgcGFyc2VkLCBvcHRpb25zO1xuXG5cdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgV0Vycm9yKSkge1xuXHRcdG9iaiA9IE9iamVjdC5jcmVhdGUoV0Vycm9yLnByb3RvdHlwZSk7XG5cdFx0V0Vycm9yLmFwcGx5KG9iaiwgYXJncyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogZmFsc2Vcblx0fSk7XG5cblx0b3B0aW9ucyA9IHBhcnNlZC5vcHRpb25zO1xuXHRvcHRpb25zWydza2lwQ2F1c2VNZXNzYWdlJ10gPSB0cnVlO1xuXHRWRXJyb3IuY2FsbCh0aGlzLCBvcHRpb25zLCAnJXMnLCBwYXJzZWQuc2hvcnRtZXNzYWdlKTtcblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhXRXJyb3IsIFZFcnJvcik7XG5XRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnV0Vycm9yJztcblxuV0Vycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHdlX3RvU3RyaW5nKClcbntcblx0dmFyIHN0ciA9ICh0aGlzLmhhc093blByb3BlcnR5KCduYW1lJykgJiYgdGhpcy5uYW1lIHx8XG5cdFx0dGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWUpO1xuXHRpZiAodGhpcy5tZXNzYWdlKVxuXHRcdHN0ciArPSAnOiAnICsgdGhpcy5tZXNzYWdlO1xuXHRpZiAodGhpcy5qc2VfY2F1c2UgJiYgdGhpcy5qc2VfY2F1c2UubWVzc2FnZSlcblx0XHRzdHIgKz0gJzsgY2F1c2VkIGJ5ICcgKyB0aGlzLmpzZV9jYXVzZS50b1N0cmluZygpO1xuXG5cdHJldHVybiAoc3RyKTtcbn07XG5cbi8qXG4gKiBGb3IgcHVyZWx5IGhpc3RvcmljYWwgcmVhc29ucywgV0Vycm9yJ3MgY2F1c2UoKSBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldFxuICogdGhlIGNhdXNlLlxuICovXG5XRXJyb3IucHJvdG90eXBlLmNhdXNlID0gZnVuY3Rpb24gd2VfY2F1c2UoYylcbntcblx0aWYgKG1vZF9pc0Vycm9yKGMpKVxuXHRcdHRoaXMuanNlX2NhdXNlID0gYztcblxuXHRyZXR1cm4gKHRoaXMuanNlX2NhdXNlKTtcbn07XG4iXSwibmFtZXMiOlsibW9kX2Fzc2VydHBsdXMiLCJyZXF1aXJlIiwibW9kX3V0aWwiLCJtb2RfZXh0c3ByaW50ZiIsIm1vZF9pc0Vycm9yIiwiaXNFcnJvciIsInNwcmludGYiLCJtb2R1bGUiLCJleHBvcnRzIiwiVkVycm9yIiwiU0Vycm9yIiwiV0Vycm9yIiwiTXVsdGlFcnJvciIsInBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMiLCJhcmdzIiwiYXJndiIsIm9wdGlvbnMiLCJzcHJpbnRmX2FyZ3MiLCJzaG9ydG1lc3NhZ2UiLCJrIiwib2JqZWN0IiwiYm9vbCIsInN0cmljdCIsImFycmF5IiwibGVuZ3RoIiwic2xpY2UiLCJzdHJpbmciLCJtYXAiLCJhIiwidW5kZWZpbmVkIiwiYXBwbHkiLCJvYmoiLCJwYXJzZWQiLCJjYXVzZSIsImN0b3IiLCJtZXNzYWdlIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiT2JqZWN0IiwiY3JlYXRlIiwibmFtZSIsImpzZV9zaG9ydG1zZyIsIm9rIiwianNlX2NhdXNlIiwic2tpcENhdXNlTWVzc2FnZSIsImpzZV9pbmZvIiwiaW5mbyIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjb25zdHJ1Y3Rvck9wdCIsImNvbnN0cnVjdG9yIiwiaW5oZXJpdHMiLCJ0b1N0cmluZyIsInZlX3RvU3RyaW5nIiwic3RyIiwiaGFzT3duUHJvcGVydHkiLCJ2ZV9jYXVzZSIsImVyciIsInJ2IiwiZmluZENhdXNlQnlOYW1lIiwiaGFzQ2F1c2VXaXRoTmFtZSIsImZ1bGxTdGFjayIsInN0YWNrIiwiZXJyb3JGcm9tTGlzdCIsImVycm9ycyIsImFycmF5T2ZPYmplY3QiLCJmb3JFYWNoIiwiZSIsImVycm9yRm9yRWFjaCIsImZ1bmMiLCJpdGVyRXJyb3IiLCJhc2VfZXJyb3JzIiwibWVfZXJyb3JzIiwid2VfdG9TdHJpbmciLCJ3ZV9jYXVzZSIsImMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/verror/lib/verror.js\n");

/***/ })

};
;
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/extsprintf";
exports.ids = ["vendor-chunks/extsprintf"];
exports.modules = {

/***/ "(rsc)/./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * extsprintf.js: extended POSIX-style sprintf\n */ var mod_assert = __webpack_require__(/*! assert */ \"assert\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\n/*\n * Public interface\n */ exports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */ function jsSprintf(fmt) {\n    var regex = [\n        \"([^%]*)\",\n        /* normal text */ \"%\",\n        /* start of format */ \"(['\\\\-+ #0]*?)\",\n        /* flags (optional) */ \"([1-9]\\\\d*)?\",\n        /* width (optional) */ \"(\\\\.([1-9]\\\\d*))?\",\n        /* precision (optional) */ \"[lhjztL]*?\",\n        /* length mods (ignored) */ \"([diouxXfFeEgGaAcCsSp%jr])\" /* conversion */ \n    ].join(\"\");\n    var re = new RegExp(regex);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var flags, width, precision, conversion;\n    var left, pad, sign, arg, match;\n    var ret = \"\";\n    var argn = 1;\n    mod_assert.equal(\"string\", typeof fmt);\n    while((match = re.exec(fmt)) !== null){\n        ret += match[1];\n        fmt = fmt.substring(match[0].length);\n        flags = match[2] || \"\";\n        width = match[3] || 0;\n        precision = match[4] || \"\";\n        conversion = match[6];\n        left = false;\n        sign = false;\n        pad = \" \";\n        if (conversion == \"%\") {\n            ret += \"%\";\n            continue;\n        }\n        if (args.length === 0) throw new Error(\"too few args to sprintf\");\n        arg = args.shift();\n        argn++;\n        if (flags.match(/[\\' #]/)) throw new Error(\"unsupported flags: \" + flags);\n        if (precision.length > 0) throw new Error(\"non-zero precision not supported\");\n        if (flags.match(/-/)) left = true;\n        if (flags.match(/0/)) pad = \"0\";\n        if (flags.match(/\\+/)) sign = true;\n        switch(conversion){\n            case \"s\":\n                if (arg === undefined || arg === null) throw new Error(\"argument \" + argn + \": attempted to print undefined or null \" + \"as a string\");\n                ret += doPad(pad, width, left, arg.toString());\n                break;\n            case \"d\":\n                arg = Math.floor(arg);\n            /*jsl:fallthru*/ case \"f\":\n                sign = sign && arg > 0 ? \"+\" : \"\";\n                ret += sign + doPad(pad, width, left, arg.toString());\n                break;\n            case \"x\":\n                ret += doPad(pad, width, left, arg.toString(16));\n                break;\n            case \"j\":\n                /* non-standard */ if (width === 0) width = 10;\n                ret += mod_util.inspect(arg, false, width);\n                break;\n            case \"r\":\n                /* non-standard */ ret += dumpException(arg);\n                break;\n            default:\n                throw new Error(\"unsupported conversion: \" + conversion);\n        }\n    }\n    ret += fmt;\n    return ret;\n}\nfunction jsPrintf() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift(process.stdout);\n    jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n    var ret = str;\n    while(ret.length < width){\n        if (left) ret += chr;\n        else ret = chr + ret;\n    }\n    return ret;\n}\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */ function dumpException(ex) {\n    var ret;\n    if (!(ex instanceof Error)) throw new Error(jsSprintf(\"invalid type for %%r: %j\", ex));\n    /* Note that V8 prepends \"ex.stack\" with ex.toString(). */ ret = \"EXCEPTION: \" + ex.constructor.name + \": \" + ex.stack;\n    if (ex.cause && typeof ex.cause === \"function\") {\n        var cex = ex.cause();\n        if (cex) {\n            ret += \"\\nCaused by: \" + dumpException(cex);\n        }\n    }\n    return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXh0c3ByaW50Zi9saWIvZXh0c3ByaW50Zi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCOztDQUVDLEdBQ0RFLGVBQWUsR0FBR0U7QUFDbEJGLGNBQWMsR0FBR0k7QUFDakJKLGVBQWUsR0FBR007QUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0QsU0FBU0osVUFBVUssR0FBRztJQUVyQixJQUFJQyxRQUFRO1FBQ1I7UUFBYyxlQUFlLEdBQzdCO1FBQVEsbUJBQW1CLEdBQzNCO1FBQXFCLG9CQUFvQixHQUN6QztRQUFrQixvQkFBb0IsR0FDdEM7UUFBc0Isd0JBQXdCLEdBQzlDO1FBQWdCLHlCQUF5QixHQUN6Qyw2QkFBNkIsY0FBYztLQUM5QyxDQUFDQyxJQUFJLENBQUM7SUFFUCxJQUFJQyxLQUFLLElBQUlDLE9BQU9IO0lBQ3BCLElBQUlJLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNDLFdBQVc7SUFDakQsSUFBSUMsT0FBT0MsT0FBT0MsV0FBV0M7SUFDN0IsSUFBSUMsTUFBTUMsS0FBS0MsTUFBTUMsS0FBS0M7SUFDMUIsSUFBSUMsTUFBTTtJQUNWLElBQUlDLE9BQU87SUFFWC9CLFdBQVdnQyxLQUFLLENBQUMsVUFBVSxPQUFRdEI7SUFFbkMsTUFBTyxDQUFDbUIsUUFBUWhCLEdBQUdvQixJQUFJLENBQUN2QixJQUFHLE1BQU8sS0FBTTtRQUN2Q29CLE9BQU9ELEtBQUssQ0FBQyxFQUFFO1FBQ2ZuQixNQUFNQSxJQUFJd0IsU0FBUyxDQUFDTCxLQUFLLENBQUMsRUFBRSxDQUFDTSxNQUFNO1FBRW5DZCxRQUFRUSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCUCxRQUFRTyxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCTixZQUFZTSxLQUFLLENBQUMsRUFBRSxJ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QmMsY0FBY2M7UUFDeEM7SUFDRDtJQUVBLE9BQVE1QjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0LWFuYWx5dGljcy8uL25vZGVfbW9kdWxlcy9leHRzcHJpbnRmL2xpYi9leHRzcHJpbnRmLmpzPzgzNGIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGV4dHNwcmludGYuanM6IGV4dGVuZGVkIFBPU0lYLXN0eWxlIHNwcmludGZcbiAqL1xuXG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIG1vZF91dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKlxuICogUHVibGljIGludGVyZmFjZVxuICovXG5leHBvcnRzLnNwcmludGYgPSBqc1NwcmludGY7XG5leHBvcnRzLnByaW50ZiA9IGpzUHJpbnRmO1xuZXhwb3J0cy5mcHJpbnRmID0ganNGcHJpbnRmO1xuXG4vKlxuICogU3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIHNbbl1wcmludGYoM2MpLiAgV2UgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHRocm93IGFuXG4gKiBleGNlcHRpb24gd2hlbiBnaXZlbiBhIGZvcm1hdCBzdHJpbmcgd2UgZG9uJ3QgdW5kZXJzdGFuZCwgcmF0aGVyIHRoYW5cbiAqIGlnbm9yaW5nIGl0LCBzbyB0aGF0IHdlIHdvbid0IGJyZWFrIGV4aXN0aW5nIHByb2dyYW1zIGlmL3doZW4gd2UgZ28gaW1wbGVtZW50XG4gKiB0aGUgcmVzdCBvZiB0aGlzLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IHN1cHBvcnRzIHNwZWNpZnlpbmdcbiAqXHQtIGZpZWxkIGFsaWdubWVudCAoJy0nIGZsYWcpLFxuICogXHQtIHplcm8tcGFkICgnMCcgZmxhZylcbiAqXHQtIGFsd2F5cyBzaG93IG51bWVyaWMgc2lnbiAoJysnIGZsYWcpLFxuICpcdC0gZmllbGQgd2lkdGhcbiAqXHQtIGNvbnZlcnNpb25zIGZvciBzdHJpbmdzLCBkZWNpbWFsIGludGVnZXJzLCBhbmQgZmxvYXRzIChudW1iZXJzKS5cbiAqXHQtIGFyZ3VtZW50IHNpemUgc3BlY2lmaWVycy4gIFRoZXNlIGFyZSBhbGwgYWNjZXB0ZWQgYnV0IGlnbm9yZWQsIHNpbmNlXG4gKlx0ICBKYXZhc2NyaXB0IGhhcyBubyBub3Rpb24gb2YgdGhlIHBoeXNpY2FsIHNpemUgb2YgYW4gYXJndW1lbnQuXG4gKlxuICogRXZlcnl0aGluZyBlbHNlIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZCwgbW9zdCBub3RhYmx5IHByZWNpc2lvbiwgdW5zaWduZWRcbiAqIG51bWJlcnMsIG5vbi1kZWNpbWFsIG51bWJlcnMsIGFuZCBjaGFyYWN0ZXJzLlxuICovXG5mdW5jdGlvbiBqc1NwcmludGYoZm10KVxue1xuXHR2YXIgcmVnZXggPSBbXG5cdCAgICAnKFteJV0qKScsXHRcdFx0XHQvKiBub3JtYWwgdGV4dCAqL1xuXHQgICAgJyUnLFx0XHRcdFx0Lyogc3RhcnQgb2YgZm9ybWF0ICovXG5cdCAgICAnKFtcXCdcXFxcLSsgIzBdKj8pJyxcdFx0XHQvKiBmbGFncyAob3B0aW9uYWwpICovXG5cdCAgICAnKFsxLTldXFxcXGQqKT8nLFx0XHRcdC8qIHdpZHRoIChvcHRpb25hbCkgKi9cblx0ICAgICcoXFxcXC4oWzEtOV1cXFxcZCopKT8nLFx0XHQvKiBwcmVjaXNpb24gKG9wdGlvbmFsKSAqL1xuXHQgICAgJ1tsaGp6dExdKj8nLFx0XHRcdC8qIGxlbmd0aCBtb2RzIChpZ25vcmVkKSAqL1xuXHQgICAgJyhbZGlvdXhYZkZlRWdHYUFjQ3NTcCVqcl0pJ1x0LyogY29udmVyc2lvbiAqL1xuXHRdLmpvaW4oJycpO1xuXG5cdHZhciByZSA9IG5ldyBSZWdFeHAocmVnZXgpO1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdHZhciBmbGFncywgd2lkdGgsIHByZWNpc2lvbiwgY29udmVyc2lvbjtcblx0dmFyIGxlZnQsIHBhZCwgc2lnbiwgYXJnLCBtYXRjaDtcblx0dmFyIHJldCA9ICcnO1xuXHR2YXIgYXJnbiA9IDE7XG5cblx0bW9kX2Fzc2VydC5lcXVhbCgnc3RyaW5nJywgdHlwZW9mIChmbXQpKTtcblxuXHR3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmbXQpKSAhPT0gbnVsbCkge1xuXHRcdHJldCArPSBtYXRjaFsxXTtcblx0XHRmbXQgPSBmbXQuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG5cblx0XHRmbGFncyA9IG1hdGNoWzJdIHx8ICcnO1xuXHRcdHdpZHRoID0gbWF0Y2hbM10gfHwgMDtcblx0XHRwcmVjaXNpb24gPSBtYXRjaFs0XSB8fCAnJztcblx0XHRjb252ZXJzaW9uID0gbWF0Y2hbNl07XG5cdFx0bGVmdCA9IGZhbHNlO1xuXHRcdHNpZ24gPSBmYWxzZTtcblx0XHRwYWQgPSAnICc7XG5cblx0XHRpZiAoY29udmVyc2lvbiA9PSAnJScpIHtcblx0XHRcdHJldCArPSAnJSc7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoYXJncy5sZW5ndGggPT09IDApXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCd0b28gZmV3IGFyZ3MgdG8gc3ByaW50ZicpKTtcblxuXHRcdGFyZyA9IGFyZ3Muc2hpZnQoKTtcblx0XHRhcmduKys7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goL1tcXCcgI10vKSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoXG5cdFx0XHQgICAgJ3Vuc3VwcG9ydGVkIGZsYWdzOiAnICsgZmxhZ3MpKTtcblxuXHRcdGlmIChwcmVjaXNpb24ubGVuZ3RoID4gMClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoXG5cdFx0XHQgICAgJ25vbi16ZXJvIHByZWNpc2lvbiBub3Qgc3VwcG9ydGVkJykpO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC8tLykpXG5cdFx0XHRsZWZ0ID0gdHJ1ZTtcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvMC8pKVxuXHRcdFx0cGFkID0gJzAnO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC9cXCsvKSlcblx0XHRcdHNpZ24gPSB0cnVlO1xuXG5cdFx0c3dpdGNoIChjb252ZXJzaW9uKSB7XG5cdFx0Y2FzZSAncyc6XG5cdFx0XHRpZiAoYXJnID09PSB1bmRlZmluZWQgfHwgYXJnID09PSBudWxsKVxuXHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdhcmd1bWVudCAnICsgYXJnbiArXG5cdFx0XHRcdCAgICAnOiBhdHRlbXB0ZWQgdG8gcHJpbnQgdW5kZWZpbmVkIG9yIG51bGwgJyArXG5cdFx0XHRcdCAgICAnYXMgYSBzdHJpbmcnKSk7XG5cdFx0XHRyZXQgKz0gZG9QYWQocGFkLCB3aWR0aCwgbGVmdCwgYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdkJzpcblx0XHRcdGFyZyA9IE1hdGguZmxvb3IoYXJnKTtcblx0XHRcdC8qanNsOmZhbGx0aHJ1Ki9cblx0XHRjYXNlICdmJzpcblx0XHRcdHNpZ24gPSBzaWduICYmIGFyZyA+IDAgPyAnKycgOiAnJztcblx0XHRcdHJldCArPSBzaWduICsgZG9QYWQocGFkLCB3aWR0aCwgbGVmdCxcblx0XHRcdCAgICBhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3gnOlxuXHRcdFx0cmV0ICs9IGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsIGFyZy50b1N0cmluZygxNikpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdqJzogLyogbm9uLXN0YW5kYXJkICovXG5cdFx0XHRpZiAod2lkdGggPT09IDApXG5cdFx0XHRcdHdpZHRoID0gMTA7XG5cdFx0XHRyZXQgKz0gbW9kX3V0aWwuaW5zcGVjdChhcmcsIGZhbHNlLCB3aWR0aCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3InOiAvKiBub24tc3RhbmRhcmQgKi9cblx0XHRcdHJldCArPSBkdW1wRXhjZXB0aW9uKGFyZyk7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCd1bnN1cHBvcnRlZCBjb252ZXJzaW9uOiAnICtcblx0XHRcdCAgICBjb252ZXJzaW9uKSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0ICs9IGZtdDtcblx0cmV0dXJuIChyZXQpO1xufVxuXG5mdW5jdGlvbiBqc1ByaW50ZigpIHtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRhcmdzLnVuc2hpZnQocHJvY2Vzcy5zdGRvdXQpO1xuXHRqc0ZwcmludGYuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzRnByaW50ZihzdHJlYW0pIHtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRyZXR1cm4gKHN0cmVhbS53cml0ZShqc1NwcmludGYuYXBwbHkodGhpcywgYXJncykpKTtcbn1cblxuZnVuY3Rpb24gZG9QYWQoY2hyLCB3aWR0aCwgbGVmdCwgc3RyKVxue1xuXHR2YXIgcmV0ID0gc3RyO1xuXG5cdHdoaWxlIChyZXQubGVuZ3RoIDwgd2lkdGgpIHtcblx0XHRpZiAobGVmdClcblx0XHRcdHJldCArPSBjaHI7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0ID0gY2hyICsgcmV0O1xuXHR9XG5cblx0cmV0dXJuIChyZXQpO1xufVxuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBkdW1wcyBsb25nIHN0YWNrIHRyYWNlcyBmb3IgZXhjZXB0aW9ucyBoYXZpbmcgYSBjYXVzZSgpIG1ldGhvZC5cbiAqIFNlZSBub2RlLXZlcnJvciBmb3IgYW4gZXhhbXBsZS5cbiAqL1xuZnVuY3Rpb24gZHVtcEV4Y2VwdGlvbihleClcbntcblx0dmFyIHJldDtcblxuXHRpZiAoIShleCBpbnN0YW5jZW9mIEVycm9yKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKGpzU3ByaW50ZignaW52YWxpZCB0eXBlIGZvciAlJXI6ICVqJywgZXgpKSk7XG5cblx0LyogTm90ZSB0aGF0IFY4IHByZXBlbmRzIFwiZXguc3RhY2tcIiB3aXRoIGV4LnRvU3RyaW5nKCkuICovXG5cdHJldCA9ICdFWENFUFRJT046ICcgKyBleC5jb25zdHJ1Y3Rvci5uYW1lICsgJzogJyArIGV4LnN0YWNrO1xuXG5cdGlmIChleC5jYXVzZSAmJiB0eXBlb2YgKGV4LmNhdXNlKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBjZXggPSBleC5jYXVzZSgpO1xuXHRcdGlmIChjZXgpIHtcblx0XHRcdHJldCArPSAnXFxuQ2F1c2VkIGJ5OiAnICsgZHVtcEV4Y2VwdGlvbihjZXgpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn1cbiJdLCJuYW1lcyI6WyJtb2RfYXNzZXJ0IiwicmVxdWlyZSIsIm1vZF91dGlsIiwiZXhwb3J0cyIsInNwcmludGYiLCJqc1NwcmludGYiLCJwcmludGYiLCJqc1ByaW50ZiIsImZwcmludGYiLCJqc0ZwcmludGYiLCJmbXQiLCJyZWdleCIsImpvaW4iLCJyZSIsIlJlZ0V4cCIsImFyZ3MiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImZsYWdzIiwid2lkdGgiLCJwcmVjaXNpb24iLCJjb252ZXJzaW9uIiwibGVmdCIsInBhZCIsInNpZ24iLCJhcmciLCJtYXRjaCIsInJldCIsImFyZ24iLCJlcXVhbCIsImV4ZWMiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJFcnJvciIsInNoaWZ0IiwidW5kZWZpbmVkIiwiZG9QYWQiLCJ0b1N0cmluZyIsIk1hdGgiLCJmbG9vciIsImluc3BlY3QiLCJkdW1wRXhjZXB0aW9uIiwidW5zaGlmdCIsInByb2Nlc3MiLCJzdGRvdXQiLCJhcHBseSIsInN0cmVhbSIsIndyaXRlIiwiY2hyIiwic3RyIiwiZXgiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJzdGFjayIsImNhdXNlIiwiY2V4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/extsprintf/lib/extsprintf.js\n");

/***/ })

};
;
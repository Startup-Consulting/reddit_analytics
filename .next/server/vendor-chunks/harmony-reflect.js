/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/harmony-reflect";
exports.ids = ["vendor-chunks/harmony-reflect"];
exports.modules = {

/***/ "(rsc)/./node_modules/harmony-reflect/reflect.js":
/*!*************************************************!*\
  !*** ./node_modules/harmony-reflect/reflect.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */ // ----------------------------------------------------------------------------\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n// Direct proxies can be created via Proxy(target, handler)\n// ----------------------------------------------------------------------------\n(function(global1) {\n    \"use strict\";\n    // === Direct Proxies: Invariant Enforcement ===\n    // Direct proxies build on non-direct proxies by automatically wrapping\n    // all user-defined proxy handlers in a Validator handler that checks and\n    // enforces ES5 invariants.\n    // A direct proxy is a proxy for an existing object called the target object.\n    // A Validator handler is a wrapper for a target proxy handler H.\n    // The Validator forwards all operations to H, but additionally\n    // performs a number of integrity checks on the results of some traps,\n    // to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n    // properties and non-extensible, sealed or frozen objects.\n    // For each property that H exposes as own, non-configurable\n    // (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n    // the Validator handler defines those properties on the target object.\n    // When the proxy becomes non-extensible, also configurable own properties\n    // are checked against the target.\n    // We will call properties that are defined on the target object\n    // \"fixed properties\".\n    // We will name fixed non-configurable properties \"sealed properties\".\n    // We will name fixed non-configurable non-writable properties \"frozen\n    // properties\".\n    // The Validator handler upholds the following invariants w.r.t. non-configurability:\n    // - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n    // - getOwnPropertyDescriptor cannot report incompatible changes to the\n    //   attributes of a sealed property (e.g. reporting a non-configurable\n    //   property as configurable, or reporting a non-configurable, non-writable\n    //   property as writable)\n    // - getPropertyDescriptor cannot report sealed properties as non-existent\n    // - getPropertyDescriptor cannot report incompatible changes to the\n    //   attributes of a sealed property. It _can_ report incompatible changes\n    //   to the attributes of non-own, inherited properties.\n    // - defineProperty cannot make incompatible changes to the attributes of\n    //   sealed properties\n    // - deleteProperty cannot report a successful deletion of a sealed property\n    // - hasOwn cannot report a sealed property as non-existent\n    // - has cannot report a sealed property as non-existent\n    // - get cannot report inconsistent values for frozen data\n    //   properties, and must report undefined for sealed accessors with an\n    //   undefined getter\n    // - set cannot report a successful assignment for frozen data\n    //   properties or sealed accessors with an undefined setter.\n    // - get{Own}PropertyNames lists all sealed properties of the target.\n    // - keys lists all enumerable sealed properties of the target.\n    // - enumerate lists all enumerable sealed properties of the target.\n    // - if a property of a non-extensible proxy is reported as non-existent,\n    //   then it must forever be reported as non-existent. This applies to\n    //   own and inherited properties and is enforced in the\n    //   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n    //   get{Own}PropertyNames, keys and enumerate traps\n    // Violation of any of these invariants by H will result in TypeError being\n    // thrown.\n    // Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n    // is invoked on the proxy, the set of own property names for the proxy is\n    // fixed. Any property name that is not fixed is called a 'new' property.\n    // The Validator upholds the following invariants regarding extensibility:\n    // - getOwnPropertyDescriptor cannot report new properties as existent\n    //   (it must report them as non-existent by returning undefined)\n    // - defineProperty cannot successfully add a new property (it must reject)\n    // - getOwnPropertyNames cannot list new properties\n    // - hasOwn cannot report true for new properties (it must report false)\n    // - keys cannot list new properties\n    // Invariants currently not enforced:\n    // - getOwnPropertyNames lists only own property names\n    // - keys lists only enumerable own property names\n    // Both traps may list more property names than are actually defined on the\n    // target.\n    // Invariants with regard to inheritance are currently not enforced.\n    // - a non-configurable potentially inherited property on a proxy with\n    //   non-mutable ancestry cannot be reported as non-existent\n    // (An object with non-mutable ancestry is a non-extensible object whose\n    // [[Prototype]] is either null or an object with non-mutable ancestry.)\n    // Changes in Handler API compared to previous harmony:proxies, see:\n    // http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n    // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n    // ----------------------------------------------------------------------------\n    // ---- WeakMap polyfill ----\n    // TODO: find a proper WeakMap polyfill\n    // define an empty WeakMap so that at least the Reflect module code\n    // will work in the absence of WeakMaps. Proxy emulation depends on\n    // actual WeakMaps, so will not work with this little shim.\n    if (typeof WeakMap === \"undefined\") {\n        global1.WeakMap = function() {};\n        global1.WeakMap.prototype = {\n            get: function(k) {\n                return undefined;\n            },\n            set: function(k, v) {\n                throw new Error(\"WeakMap not supported\");\n            }\n        };\n    }\n    // ---- Normalization functions for property descriptors ----\n    function isStandardAttribute(name) {\n        return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n    }\n    // Adapted from ES5 section 8.10.5\n    function toPropertyDescriptor(obj) {\n        if (Object(obj) !== obj) {\n            throw new TypeError(\"property descriptor should be an Object, given: \" + obj);\n        }\n        var desc = {};\n        if (\"enumerable\" in obj) {\n            desc.enumerable = !!obj.enumerable;\n        }\n        if (\"configurable\" in obj) {\n            desc.configurable = !!obj.configurable;\n        }\n        if (\"value\" in obj) {\n            desc.value = obj.value;\n        }\n        if (\"writable\" in obj) {\n            desc.writable = !!obj.writable;\n        }\n        if (\"get\" in obj) {\n            var getter = obj.get;\n            if (getter !== undefined && typeof getter !== \"function\") {\n                throw new TypeError(\"property descriptor 'get' attribute must be \" + \"callable or undefined, given: \" + getter);\n            }\n            desc.get = getter;\n        }\n        if (\"set\" in obj) {\n            var setter = obj.set;\n            if (setter !== undefined && typeof setter !== \"function\") {\n                throw new TypeError(\"property descriptor 'set' attribute must be \" + \"callable or undefined, given: \" + setter);\n            }\n            desc.set = setter;\n        }\n        if (\"get\" in desc || \"set\" in desc) {\n            if (\"value\" in desc || \"writable\" in desc) {\n                throw new TypeError(\"property descriptor cannot be both a data and an \" + \"accessor descriptor: \" + obj);\n            }\n        }\n        return desc;\n    }\n    function isAccessorDescriptor(desc) {\n        if (desc === undefined) return false;\n        return \"get\" in desc || \"set\" in desc;\n    }\n    function isDataDescriptor(desc) {\n        if (desc === undefined) return false;\n        return \"value\" in desc || \"writable\" in desc;\n    }\n    function isGenericDescriptor(desc) {\n        if (desc === undefined) return false;\n        return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n    }\n    function toCompletePropertyDescriptor(desc) {\n        var internalDesc = toPropertyDescriptor(desc);\n        if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n            if (!(\"value\" in internalDesc)) {\n                internalDesc.value = undefined;\n            }\n            if (!(\"writable\" in internalDesc)) {\n                internalDesc.writable = false;\n            }\n        } else {\n            if (!(\"get\" in internalDesc)) {\n                internalDesc.get = undefined;\n            }\n            if (!(\"set\" in internalDesc)) {\n                internalDesc.set = undefined;\n            }\n        }\n        if (!(\"enumerable\" in internalDesc)) {\n            internalDesc.enumerable = false;\n        }\n        if (!(\"configurable\" in internalDesc)) {\n            internalDesc.configurable = false;\n        }\n        return internalDesc;\n    }\n    function isEmptyDescriptor(desc) {\n        return !(\"get\" in desc) && !(\"set\" in desc) && !(\"value\" in desc) && !(\"writable\" in desc) && !(\"enumerable\" in desc) && !(\"configurable\" in desc);\n    }\n    function isEquivalentDescriptor(desc1, desc2) {\n        return sameValue(desc1.get, desc2.get) && sameValue(desc1.set, desc2.set) && sameValue(desc1.value, desc2.value) && sameValue(desc1.writable, desc2.writable) && sameValue(desc1.enumerable, desc2.enumerable) && sameValue(desc1.configurable, desc2.configurable);\n    }\n    // copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n    function sameValue(x, y) {\n        if (x === y) {\n            // 0 === -0, but they are not identical\n            return x !== 0 || 1 / x === 1 / y;\n        }\n        // NaN !== NaN, but they are identical.\n        // NaNs are the only non-reflexive value, i.e., if x !== x,\n        // then x is a NaN.\n        // isNaN is broken: it converts its argument to number, so\n        // isNaN(\"foo\") => true\n        return x !== x && y !== y;\n    }\n    /**\n * Returns a fresh property descriptor that is guaranteed\n * to be complete (i.e. contain all the standard attributes).\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, returns undefined.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */ function normalizeAndCompletePropertyDescriptor(attributes) {\n        if (attributes === undefined) {\n            return undefined;\n        }\n        var desc = toCompletePropertyDescriptor(attributes);\n        // Note: no need to call FromPropertyDescriptor(desc), as we represent\n        // \"internal\" property descriptors as proper Objects from the start\n        for(var name in attributes){\n            if (!isStandardAttribute(name)) {\n                Object.defineProperty(desc, name, {\n                    value: attributes[name],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        return desc;\n    }\n    /**\n * Returns a fresh property descriptor whose standard\n * attributes are guaranteed to be data properties of the right type.\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, will throw a TypeError.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */ function normalizePropertyDescriptor(attributes) {\n        var desc = toPropertyDescriptor(attributes);\n        // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n        // \"internal\" property descriptors as proper Objects from the start\n        for(var name in attributes){\n            if (!isStandardAttribute(name)) {\n                Object.defineProperty(desc, name, {\n                    value: attributes[name],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        return desc;\n    }\n    // store a reference to the real ES5 primitives before patching them later\n    var prim_preventExtensions = Object.preventExtensions, prim_seal = Object.seal, prim_freeze = Object.freeze, prim_isExtensible = Object.isExtensible, prim_isSealed = Object.isSealed, prim_isFrozen = Object.isFrozen, prim_getPrototypeOf = Object.getPrototypeOf, prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, prim_defineProperty = Object.defineProperty, prim_defineProperties = Object.defineProperties, prim_keys = Object.keys, prim_getOwnPropertyNames = Object.getOwnPropertyNames, prim_getOwnPropertySymbols = Object.getOwnPropertySymbols, prim_assign = Object.assign, prim_isArray = Array.isArray, prim_concat = Array.prototype.concat, prim_isPrototypeOf = Object.prototype.isPrototypeOf, prim_hasOwnProperty = Object.prototype.hasOwnProperty;\n    // these will point to the patched versions of the respective methods on\n    // Object. They are used within this module as the \"intrinsic\" bindings\n    // of these methods (i.e. the \"original\" bindings as defined in the spec)\n    var Object_isFrozen, Object_isSealed, Object_isExtensible, Object_getPrototypeOf, Object_getOwnPropertyNames;\n    /**\n * A property 'name' is fixed if it is an own property of the target.\n */ function isFixed(name, target) {\n        return ({}).hasOwnProperty.call(target, name);\n    }\n    function isSealed(name, target) {\n        var desc = Object.getOwnPropertyDescriptor(target, name);\n        if (desc === undefined) {\n            return false;\n        }\n        return desc.configurable === false;\n    }\n    function isSealedDesc(desc) {\n        return desc !== undefined && desc.configurable === false;\n    }\n    /**\n * Performs all validation that Object.defineProperty performs,\n * without actually defining the property. Returns a boolean\n * indicating whether validation succeeded.\n *\n * Implementation transliterated from ES5.1 section 8.12.9\n */ function isCompatibleDescriptor(extensible, current, desc) {\n        if (current === undefined && extensible === false) {\n            return false;\n        }\n        if (current === undefined && extensible === true) {\n            return true;\n        }\n        if (isEmptyDescriptor(desc)) {\n            return true;\n        }\n        if (isEquivalentDescriptor(current, desc)) {\n            return true;\n        }\n        if (current.configurable === false) {\n            if (desc.configurable === true) {\n                return false;\n            }\n            if (\"enumerable\" in desc && desc.enumerable !== current.enumerable) {\n                return false;\n            }\n        }\n        if (isGenericDescriptor(desc)) {\n            return true;\n        }\n        if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n            if (current.configurable === false) {\n                return false;\n            }\n            return true;\n        }\n        if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n            if (current.configurable === false) {\n                if (current.writable === false && desc.writable === true) {\n                    return false;\n                }\n                if (current.writable === false) {\n                    if (\"value\" in desc && !sameValue(desc.value, current.value)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n            if (current.configurable === false) {\n                if (\"set\" in desc && !sameValue(desc.set, current.set)) {\n                    return false;\n                }\n                if (\"get\" in desc && !sameValue(desc.get, current.get)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    // ES6 7.3.11 SetIntegrityLevel\n    // level is one of \"sealed\" or \"frozen\"\n    function setIntegrityLevel(target, level) {\n        var ownProps = Object_getOwnPropertyNames(target);\n        var pendingException = undefined;\n        if (level === \"sealed\") {\n            var l = +ownProps.length;\n            var k;\n            for(var i = 0; i < l; i++){\n                k = String(ownProps[i]);\n                try {\n                    Object.defineProperty(target, k, {\n                        configurable: false\n                    });\n                } catch (e) {\n                    if (pendingException === undefined) {\n                        pendingException = e;\n                    }\n                }\n            }\n        } else {\n            // level === \"frozen\"\n            var l = +ownProps.length;\n            var k;\n            for(var i = 0; i < l; i++){\n                k = String(ownProps[i]);\n                try {\n                    var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n                    if (currentDesc !== undefined) {\n                        var desc;\n                        if (isAccessorDescriptor(currentDesc)) {\n                            desc = {\n                                configurable: false\n                            };\n                        } else {\n                            desc = {\n                                configurable: false,\n                                writable: false\n                            };\n                        }\n                        Object.defineProperty(target, k, desc);\n                    }\n                } catch (e) {\n                    if (pendingException === undefined) {\n                        pendingException = e;\n                    }\n                }\n            }\n        }\n        if (pendingException !== undefined) {\n            throw pendingException;\n        }\n        return Reflect.preventExtensions(target);\n    }\n    // ES6 7.3.12 TestIntegrityLevel\n    // level is one of \"sealed\" or \"frozen\"\n    function testIntegrityLevel(target, level) {\n        var isExtensible = Object_isExtensible(target);\n        if (isExtensible) return false;\n        var ownProps = Object_getOwnPropertyNames(target);\n        var pendingException = undefined;\n        var configurable = false;\n        var writable = false;\n        var l = +ownProps.length;\n        var k;\n        var currentDesc;\n        for(var i = 0; i < l; i++){\n            k = String(ownProps[i]);\n            try {\n                currentDesc = Object.getOwnPropertyDescriptor(target, k);\n                configurable = configurable || currentDesc.configurable;\n                if (isDataDescriptor(currentDesc)) {\n                    writable = writable || currentDesc.writable;\n                }\n            } catch (e) {\n                if (pendingException === undefined) {\n                    pendingException = e;\n                    configurable = true;\n                }\n            }\n        }\n        if (pendingException !== undefined) {\n            throw pendingException;\n        }\n        if (level === \"frozen\" && writable === true) {\n            return false;\n        }\n        if (configurable === true) {\n            return false;\n        }\n        return true;\n    }\n    // ---- The Validator handler wrapper around user handlers ----\n    /**\n * @param target the object wrapped by this proxy.\n * As long as the proxy is extensible, only non-configurable properties\n * are checked against the target. Once the proxy becomes non-extensible,\n * invariants w.r.t. non-extensibility are also enforced.\n *\n * @param handler the handler of the direct proxy. The object emulated by\n * this handler is validated against the target object of the direct proxy.\n * Any violations that the handler makes against the invariants\n * of the target will cause a TypeError to be thrown.\n *\n * Both target and handler must be proper Objects at initialization time.\n */ function Validator(target, handler) {\n        // for non-revokable proxies, these are const references\n        // for revokable proxies, on revocation:\n        // - this.target is set to null\n        // - this.handler is set to a handler that throws on all traps\n        this.target = target;\n        this.handler = handler;\n    }\n    Validator.prototype = {\n        /**\n   * If getTrap returns undefined, the caller should perform the\n   * default forwarding behavior.\n   * If getTrap returns normally otherwise, the return value\n   * will be a callable trap function. When calling the trap function,\n   * the caller is responsible for binding its |this| to |this.handler|.\n   */ getTrap: function(trapName) {\n            var trap = this.handler[trapName];\n            if (trap === undefined) {\n                // the trap was not defined,\n                // perform the default forwarding behavior\n                return undefined;\n            }\n            if (typeof trap !== \"function\") {\n                throw new TypeError(trapName + \" trap is not callable: \" + trap);\n            }\n            return trap;\n        },\n        // === fundamental traps ===\n        /**\n   * If name denotes a fixed property, check:\n   *   - whether targetHandler reports it as existent\n   *   - whether the returned descriptor is compatible with the fixed property\n   * If the proxy is non-extensible, check:\n   *   - whether name is not a new property\n   * Additionally, the returned descriptor is normalized and completed.\n   */ getOwnPropertyDescriptor: function(name) {\n            \"use strict\";\n            var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n            if (trap === undefined) {\n                return Reflect.getOwnPropertyDescriptor(this.target, name);\n            }\n            name = String(name);\n            var desc = trap.call(this.handler, this.target, name);\n            desc = normalizeAndCompletePropertyDescriptor(desc);\n            var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n            var extensible = Object.isExtensible(this.target);\n            if (desc === undefined) {\n                if (isSealedDesc(targetDesc)) {\n                    throw new TypeError(\"cannot report non-configurable property '\" + name + \"' as non-existent\");\n                }\n                if (!extensible && targetDesc !== undefined) {\n                    // if handler is allowed to return undefined, we cannot guarantee\n                    // that it will not return a descriptor for this property later.\n                    // Once a property has been reported as non-existent on a non-extensible\n                    // object, it should forever be reported as non-existent\n                    throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n                }\n                return undefined;\n            }\n            // at this point, we know (desc !== undefined), i.e.\n            // targetHandler reports 'name' as an existing property\n            // Note: we could collapse the following two if-tests into a single\n            // test. Separating out the cases to improve error reporting.\n            if (!extensible) {\n                if (targetDesc === undefined) {\n                    throw new TypeError(\"cannot report a new own property '\" + name + \"' on a non-extensible object\");\n                }\n            }\n            if (name !== undefined) {\n                if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n                    throw new TypeError(\"cannot report incompatible property descriptor \" + \"for property '\" + name + \"'\");\n                }\n            }\n            if (desc.configurable === false) {\n                if (targetDesc === undefined || targetDesc.configurable === true) {\n                    // if the property is configurable or non-existent on the target,\n                    // but is reported as a non-configurable property, it may later be\n                    // reported as configurable or non-existent, which violates the\n                    // invariant that if the property might change or disappear, the\n                    // configurable attribute must be true.\n                    throw new TypeError(\"cannot report a non-configurable descriptor \" + \"for configurable or non-existent property '\" + name + \"'\");\n                }\n                if (\"writable\" in desc && desc.writable === false) {\n                    if (targetDesc.writable === true) {\n                        // if the property is non-configurable, writable on the target,\n                        // but is reported as non-configurable, non-writable, it may later\n                        // be reported as non-configurable, writable again, which violates\n                        // the invariant that a non-configurable, non-writable property\n                        // may not change state.\n                        throw new TypeError(\"cannot report non-configurable, writable property '\" + name + \"' as non-configurable, non-writable\");\n                    }\n                }\n            }\n            return desc;\n        },\n        /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, instead\n   * of calling this trap, the get, set, has or enumerate traps are\n   * called instead.\n   *\n   * In this implementation, we \"abuse\" getPropertyDescriptor to\n   * support trapping the get or set traps for proxies-as-prototypes.\n   * We do this by returning a getter/setter pair that invokes\n   * the corresponding traps.\n   *\n   * While this hack works for inherited property access, it has some\n   * quirks:\n   *\n   * In Firefox, this trap is only called after a prior invocation\n   * of the 'has' trap has returned true. Hence, expect the following\n   * behavior:\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * child[name] // triggers handler.has(target, name)\n   * // if that returns true, triggers handler.get(target, name, child)\n   * </code>\n   *\n   * On v8, the 'in' operator, when applied to an object that inherits\n   * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n   * That calls the below getPropertyDescriptor trap on the proxy. The\n   * result of the 'in'-operator is then determined by whether this trap\n   * returns undefined or a property descriptor object. That is why\n   * we first explicitly trigger the 'has' trap to determine whether\n   * the property exists.\n   *\n   * This has the side-effect that when enumerating properties on\n   * an object that inherits from a proxy in v8, only properties\n   * for which 'has' returns true are returned:\n   *\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n   * </code>\n   */ getPropertyDescriptor: function(name) {\n            var handler = this;\n            if (!handler.has(name)) return undefined;\n            return {\n                get: function() {\n                    return handler.get(this, name);\n                },\n                set: function(val) {\n                    if (handler.set(this, name, val)) {\n                        return val;\n                    } else {\n                        throw new TypeError(\"failed assignment to \" + name);\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            };\n        },\n        /**\n   * If name denotes a fixed property, check for incompatible changes.\n   * If the proxy is non-extensible, check that new properties are rejected.\n   */ defineProperty: function(name, desc) {\n            // TODO(tvcutsem): the current tracemonkey implementation of proxies\n            // auto-completes 'desc', which is not correct. 'desc' should be\n            // normalized, but not completed. Consider:\n            // Object.defineProperty(proxy, 'foo', {enumerable:false})\n            // This trap will receive desc =\n            //  {value:undefined,writable:false,enumerable:false,configurable:false}\n            // This will also set all other attributes to their default value,\n            // which is unexpected and different from [[DefineOwnProperty]].\n            // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n            var trap = this.getTrap(\"defineProperty\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.defineProperty(this.target, name, desc);\n            }\n            name = String(name);\n            var descObj = normalizePropertyDescriptor(desc);\n            var success = trap.call(this.handler, this.target, name, descObj);\n            success = !!success; // coerce to Boolean\n            if (success === true) {\n                var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                var extensible = Object.isExtensible(this.target);\n                // Note: we could collapse the following two if-tests into a single\n                // test. Separating out the cases to improve error reporting.\n                if (!extensible) {\n                    if (targetDesc === undefined) {\n                        throw new TypeError(\"cannot successfully add a new property '\" + name + \"' to a non-extensible object\");\n                    }\n                }\n                if (targetDesc !== undefined) {\n                    if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n                        throw new TypeError(\"cannot define incompatible property \" + \"descriptor for property '\" + name + \"'\");\n                    }\n                    if (isDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === true) {\n                        if (desc.configurable === false && desc.writable === false) {\n                            // if the property is non-configurable, writable on the target\n                            // but was successfully reported to be updated to\n                            // non-configurable, non-writable, it can later be reported\n                            // again as non-configurable, writable, which violates\n                            // the invariant that non-configurable, non-writable properties\n                            // cannot change state\n                            throw new TypeError(\"cannot successfully define non-configurable, writable \" + \" property '\" + name + \"' as non-configurable, non-writable\");\n                        }\n                    }\n                }\n                if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n                    // if the property is configurable or non-existent on the target,\n                    // but is successfully being redefined as a non-configurable property,\n                    // it may later be reported as configurable or non-existent, which violates\n                    // the invariant that if the property might change or disappear, the\n                    // configurable attribute must be true.\n                    throw new TypeError(\"cannot successfully define a non-configurable \" + \"descriptor for configurable or non-existent property '\" + name + \"'\");\n                }\n            }\n            return success;\n        },\n        /**\n   * On success, check whether the target object is indeed non-extensible.\n   */ preventExtensions: function() {\n            var trap = this.getTrap(\"preventExtensions\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.preventExtensions(this.target);\n            }\n            var success = trap.call(this.handler, this.target);\n            success = !!success; // coerce to Boolean\n            if (success) {\n                if (Object_isExtensible(this.target)) {\n                    throw new TypeError(\"can't report extensible object as non-extensible: \" + this.target);\n                }\n            }\n            return success;\n        },\n        /**\n   * If name denotes a sealed property, check whether handler rejects.\n   */ delete: function(name) {\n            \"use strict\";\n            var trap = this.getTrap(\"deleteProperty\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.deleteProperty(this.target, name);\n            }\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name);\n            res = !!res; // coerce to Boolean\n            var targetDesc;\n            if (res === true) {\n                targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                if (targetDesc !== undefined && targetDesc.configurable === false) {\n                    throw new TypeError(\"property '\" + name + \"' is non-configurable \" + \"and can't be deleted\");\n                }\n                if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n                    // if the property still exists on a non-extensible target but\n                    // is reported as successfully deleted, it may later be reported\n                    // as present, which violates the invariant that an own property,\n                    // deleted from a non-extensible object cannot reappear.\n                    throw new TypeError(\"cannot successfully delete existing property '\" + name + \"' on a non-extensible object\");\n                }\n            }\n            return res;\n        },\n        /**\n   * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n   * which now also returns an array (of strings or symbols) and\n   * which performs the same rigorous invariant checks as getOwnPropertyNames\n   *\n   * See issue #48 on how this trap can still get invoked by external libs\n   * that don't use the patched Object.getOwnPropertyNames function.\n   */ getOwnPropertyNames: function() {\n            // Note: removed deprecation warning to avoid dependency on 'console'\n            // (and on node, should anyway use util.deprecate). Deprecation warnings\n            // can also be annoying when they are outside of the user's control, e.g.\n            // when an external library calls unpatched Object.getOwnPropertyNames.\n            // Since there is a clean fallback to `ownKeys`, the fact that the\n            // deprecated method is still called is mostly harmless anyway.\n            // See also issues #65 and #66.\n            // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n            return this.ownKeys();\n        },\n        /**\n   * Checks whether the trap result does not contain any new properties\n   * if the proxy is non-extensible.\n   *\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * Additionally, the trap result is normalized.\n   * Instead of returning the trap result directly:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to a String\n   *\n   * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n   * and Object.keys (the latter filters out only the enumerable own properties).\n   */ ownKeys: function() {\n            var trap = this.getTrap(\"ownKeys\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.ownKeys(this.target);\n            }\n            var trapResult = trap.call(this.handler, this.target);\n            // propNames is used as a set of strings\n            var propNames = Object.create(null);\n            var numProps = +trapResult.length;\n            var result = new Array(numProps);\n            for(var i = 0; i < numProps; i++){\n                var s = String(trapResult[i]);\n                if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n                    // non-extensible proxies don't tolerate new own property names\n                    throw new TypeError(\"ownKeys trap cannot list a new \" + \"property '\" + s + \"' on a non-extensible object\");\n                }\n                propNames[s] = true;\n                result[i] = s;\n            }\n            var ownProps = Object_getOwnPropertyNames(this.target);\n            var target = this.target;\n            ownProps.forEach(function(ownProp) {\n                if (!propNames[ownProp]) {\n                    if (isSealed(ownProp, target)) {\n                        throw new TypeError(\"ownKeys trap failed to include \" + \"non-configurable property '\" + ownProp + \"'\");\n                    }\n                    if (!Object.isExtensible(target) && isFixed(ownProp, target)) {\n                        // if handler is allowed to report ownProp as non-existent,\n                        // we cannot guarantee that it will never later report it as\n                        // existent. Once a property has been reported as non-existent\n                        // on a non-extensible object, it should forever be reported as\n                        // non-existent\n                        throw new TypeError(\"ownKeys trap cannot report existing own property '\" + ownProp + \"' as non-existent on a non-extensible object\");\n                    }\n                }\n            });\n            return result;\n        },\n        /**\n   * Checks whether the trap result is consistent with the state of the\n   * wrapped target.\n   */ isExtensible: function() {\n            var trap = this.getTrap(\"isExtensible\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.isExtensible(this.target);\n            }\n            var result = trap.call(this.handler, this.target);\n            result = !!result; // coerce to Boolean\n            var state = Object_isExtensible(this.target);\n            if (result !== state) {\n                if (result) {\n                    throw new TypeError(\"cannot report non-extensible object as extensible: \" + this.target);\n                } else {\n                    throw new TypeError(\"cannot report extensible object as non-extensible: \" + this.target);\n                }\n            }\n            return state;\n        },\n        /**\n   * Check whether the trap result corresponds to the target's [[Prototype]]\n   */ getPrototypeOf: function() {\n            var trap = this.getTrap(\"getPrototypeOf\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.getPrototypeOf(this.target);\n            }\n            var allegedProto = trap.call(this.handler, this.target);\n            if (!Object_isExtensible(this.target)) {\n                var actualProto = Object_getPrototypeOf(this.target);\n                if (!sameValue(allegedProto, actualProto)) {\n                    throw new TypeError(\"prototype value does not match: \" + this.target);\n                }\n            }\n            return allegedProto;\n        },\n        /**\n   * If target is non-extensible and setPrototypeOf trap returns true,\n   * check whether the trap result corresponds to the target's [[Prototype]]\n   */ setPrototypeOf: function(newProto) {\n            var trap = this.getTrap(\"setPrototypeOf\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.setPrototypeOf(this.target, newProto);\n            }\n            var success = trap.call(this.handler, this.target, newProto);\n            success = !!success;\n            if (success && !Object_isExtensible(this.target)) {\n                var actualProto = Object_getPrototypeOf(this.target);\n                if (!sameValue(newProto, actualProto)) {\n                    throw new TypeError(\"prototype value does not match: \" + this.target);\n                }\n            }\n            return success;\n        },\n        /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, for-in will\n   * call the enumerate() trap. If that trap is not defined, the\n   * operation is forwarded to the target, no more fallback on this\n   * fundamental trap.\n   */ getPropertyNames: function() {\n            throw new TypeError(\"getPropertyNames trap is deprecated\");\n        },\n        // === derived traps ===\n        /**\n   * If name denotes a fixed property, check whether the trap returns true.\n   */ has: function(name) {\n            var trap = this.getTrap(\"has\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.has(this.target, name);\n            }\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name);\n            res = !!res; // coerce to Boolean\n            if (res === false) {\n                if (isSealed(name, this.target)) {\n                    throw new TypeError(\"cannot report existing non-configurable own \" + \"property '\" + name + \"' as a non-existent \" + \"property\");\n                }\n                if (!Object.isExtensible(this.target) && isFixed(name, this.target)) {\n                    // if handler is allowed to return false, we cannot guarantee\n                    // that it will not return true for this property later.\n                    // Once a property has been reported as non-existent on a non-extensible\n                    // object, it should forever be reported as non-existent\n                    throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n                }\n            }\n            // if res === true, we don't need to check for extensibility\n            // even for a non-extensible proxy that has no own name property,\n            // the property may have been inherited\n            return res;\n        },\n        /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check its return value against the previously asserted value of the\n   * fixed property.\n   */ get: function(receiver, name) {\n            // experimental support for invoke() trap on platforms that\n            // support __noSuchMethod__\n            /*\n    if (name === '__noSuchMethod__') {\n      var handler = this;\n      return function(name, args) {\n        return handler.invoke(receiver, name, args);\n      }\n    }\n    */ var trap = this.getTrap(\"get\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.get(this.target, name, receiver);\n            }\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name, receiver);\n            var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n            // check consistency of the returned value\n            if (fixedDesc !== undefined) {\n                if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n                    if (!sameValue(res, fixedDesc.value)) {\n                        throw new TypeError(\"cannot report inconsistent value for \" + \"non-writable, non-configurable property '\" + name + \"'\");\n                    }\n                } else {\n                    if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.get === undefined) {\n                        if (res !== undefined) {\n                            throw new TypeError(\"must report undefined for non-configurable \" + \"accessor property '\" + name + \"' without getter\");\n                        }\n                    }\n                }\n            }\n            return res;\n        },\n        /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check that the trap rejects the assignment.\n   */ set: function(receiver, name, val) {\n            var trap = this.getTrap(\"set\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                return Reflect.set(this.target, name, val, receiver);\n            }\n            name = String(name);\n            var res = trap.call(this.handler, this.target, name, val, receiver);\n            res = !!res; // coerce to Boolean\n            // if success is reported, check whether property is truly assignable\n            if (res === true) {\n                var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n                if (fixedDesc !== undefined) {\n                    if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n                        if (!sameValue(val, fixedDesc.value)) {\n                            throw new TypeError(\"cannot successfully assign to a \" + \"non-writable, non-configurable property '\" + name + \"'\");\n                        }\n                    } else {\n                        if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && // non-configurable\n                        fixedDesc.set === undefined) {\n                            throw new TypeError(\"setting a property '\" + name + \"' that has \" + \" only a getter\");\n                        }\n                    }\n                }\n            }\n            return res;\n        },\n        /**\n   * Any own enumerable non-configurable properties of the target that are not\n   * included in the trap result give rise to a TypeError. As such, we check\n   * whether the returned result contains at least all sealed enumerable properties\n   * of the target object.\n   *\n   * The trap should return an iterator.\n   *\n   * However, as implementations of pre-direct proxies still expect enumerate\n   * to return an array of strings, we convert the iterator into an array.\n   */ enumerate: function() {\n            var trap = this.getTrap(\"enumerate\");\n            if (trap === undefined) {\n                // default forwarding behavior\n                var trapResult = Reflect.enumerate(this.target);\n                var result = [];\n                var nxt = trapResult.next();\n                while(!nxt.done){\n                    result.push(String(nxt.value));\n                    nxt = trapResult.next();\n                }\n                return result;\n            }\n            var trapResult = trap.call(this.handler, this.target);\n            if (trapResult === null || trapResult === undefined || trapResult.next === undefined) {\n                throw new TypeError(\"enumerate trap should return an iterator, got: \" + trapResult);\n            }\n            // propNames is used as a set of strings\n            var propNames = Object.create(null);\n            // var numProps = +trapResult.length;\n            var result = []; // new Array(numProps);\n            // trapResult is supposed to be an iterator\n            // drain iterator to array as current implementations still expect\n            // enumerate to return an array of strings\n            var nxt = trapResult.next();\n            while(!nxt.done){\n                var s = String(nxt.value);\n                if (propNames[s]) {\n                    throw new TypeError(\"enumerate trap cannot list a \" + \"duplicate property '\" + s + \"'\");\n                }\n                propNames[s] = true;\n                result.push(s);\n                nxt = trapResult.next();\n            }\n            /*for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    } */ var ownEnumerableProps = Object.keys(this.target);\n            var target = this.target;\n            ownEnumerableProps.forEach(function(ownEnumerableProp) {\n                if (!propNames[ownEnumerableProp]) {\n                    if (isSealed(ownEnumerableProp, target)) {\n                        throw new TypeError(\"enumerate trap failed to include \" + \"non-configurable enumerable property '\" + ownEnumerableProp + \"'\");\n                    }\n                    if (!Object.isExtensible(target) && isFixed(ownEnumerableProp, target)) {\n                        // if handler is allowed not to report ownEnumerableProp as an own\n                        // property, we cannot guarantee that it will never report it as\n                        // an own property later. Once a property has been reported as\n                        // non-existent on a non-extensible object, it should forever be\n                        // reported as non-existent\n                        throw new TypeError(\"cannot report existing own property '\" + ownEnumerableProp + \"' as non-existent on a \" + \"non-extensible object\");\n                    }\n                }\n            });\n            return result;\n        },\n        /**\n   * The iterate trap is deprecated by the enumerate trap.\n   */ iterate: Validator.prototype.enumerate,\n        /**\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * The trap result is normalized.\n   * The trap result is not returned directly. Instead:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to String,\n   *  - which does not contain duplicates\n   *\n   * FIXME: keys trap is deprecated\n   */ /*\n  keys: function() {\n    var trap = this.getTrap(\"keys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.keys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n     var s = String(trapResult[i]);\n     if (propNames[s]) {\n       throw new TypeError(\"keys trap cannot list a \"+\n                           \"duplicate property '\"+s+\"'\");\n     }\n     if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n       // non-extensible proxies don't tolerate new own property names\n       throw new TypeError(\"keys trap cannot list a new \"+\n                           \"property '\"+s+\"' on a non-extensible object\");\n     }\n\n     propNames[s] = true;\n     result[i] = s;\n    }\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"keys trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n  */ /**\n   * New trap that reifies [[Call]].\n   * If the target is a function, then a call to\n   *   proxy(...args)\n   * Triggers this trap\n   */ apply: function(target, thisBinding, args) {\n            var trap = this.getTrap(\"apply\");\n            if (trap === undefined) {\n                return Reflect.apply(target, thisBinding, args);\n            }\n            if (typeof this.target === \"function\") {\n                return trap.call(this.handler, target, thisBinding, args);\n            } else {\n                throw new TypeError(\"apply: \" + target + \" is not a function\");\n            }\n        },\n        /**\n   * New trap that reifies [[Construct]].\n   * If the target is a function, then a call to\n   *   new proxy(...args)\n   * Triggers this trap\n   */ construct: function(target, args, newTarget) {\n            var trap = this.getTrap(\"construct\");\n            if (trap === undefined) {\n                return Reflect.construct(target, args, newTarget);\n            }\n            if (typeof target !== \"function\") {\n                throw new TypeError(\"new: \" + target + \" is not a function\");\n            }\n            if (newTarget === undefined) {\n                newTarget = target;\n            } else {\n                if (typeof newTarget !== \"function\") {\n                    throw new TypeError(\"new: \" + newTarget + \" is not a function\");\n                }\n            }\n            return trap.call(this.handler, target, args, newTarget);\n        }\n    };\n    // ---- end of the Validator handler wrapper handler ----\n    // In what follows, a 'direct proxy' is a proxy\n    // whose handler is a Validator. Such proxies can be made non-extensible,\n    // sealed or frozen without losing the ability to trap.\n    // maps direct proxies to their Validator handlers\n    var directProxies = new WeakMap();\n    // patch Object.{preventExtensions,seal,freeze} so that\n    // they recognize fixable proxies and act accordingly\n    Object.preventExtensions = function(subject) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            if (vhandler.preventExtensions()) {\n                return subject;\n            } else {\n                throw new TypeError(\"preventExtensions on \" + subject + \" rejected\");\n            }\n        } else {\n            return prim_preventExtensions(subject);\n        }\n    };\n    Object.seal = function(subject) {\n        setIntegrityLevel(subject, \"sealed\");\n        return subject;\n    };\n    Object.freeze = function(subject) {\n        setIntegrityLevel(subject, \"frozen\");\n        return subject;\n    };\n    Object.isExtensible = Object_isExtensible = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.isExtensible();\n        } else {\n            return prim_isExtensible(subject);\n        }\n    };\n    Object.isSealed = Object_isSealed = function(subject) {\n        return testIntegrityLevel(subject, \"sealed\");\n    };\n    Object.isFrozen = Object_isFrozen = function(subject) {\n        return testIntegrityLevel(subject, \"frozen\");\n    };\n    Object.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.getPrototypeOf();\n        } else {\n            return prim_getPrototypeOf(subject);\n        }\n    };\n    // patch Object.getOwnPropertyDescriptor to directly call\n    // the Validator.prototype.getOwnPropertyDescriptor trap\n    // This is to circumvent an assertion in the built-in Proxy\n    // trapping mechanism of v8, which disallows that trap to\n    // return non-configurable property descriptors (as per the\n    // old Proxy design)\n    Object.getOwnPropertyDescriptor = function(subject, name) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            return vhandler.getOwnPropertyDescriptor(name);\n        } else {\n            return prim_getOwnPropertyDescriptor(subject, name);\n        }\n    };\n    // patch Object.defineProperty to directly call\n    // the Validator.prototype.defineProperty trap\n    // This is to circumvent two issues with the built-in\n    // trap mechanism:\n    // 1) the current tracemonkey implementation of proxies\n    // auto-completes 'desc', which is not correct. 'desc' should be\n    // normalized, but not completed. Consider:\n    // Object.defineProperty(proxy, 'foo', {enumerable:false})\n    // This trap will receive desc =\n    //  {value:undefined,writable:false,enumerable:false,configurable:false}\n    // This will also set all other attributes to their default value,\n    // which is unexpected and different from [[DefineOwnProperty]].\n    // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n    // 2) the current spidermonkey implementation does not\n    // throw an exception when this trap returns 'false', but instead silently\n    // ignores the operation (this is regardless of strict-mode)\n    // 2a) v8 does throw an exception for this case, but includes the rather\n    //     unhelpful error message:\n    // 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n    Object.defineProperty = function(subject, name, desc) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            var normalizedDesc = normalizePropertyDescriptor(desc);\n            var success = vhandler.defineProperty(name, normalizedDesc);\n            if (success === false) {\n                throw new TypeError(\"can't redefine property '\" + name + \"'\");\n            }\n            return subject;\n        } else {\n            return prim_defineProperty(subject, name, desc);\n        }\n    };\n    Object.defineProperties = function(subject, descs) {\n        var vhandler = directProxies.get(subject);\n        if (vhandler !== undefined) {\n            var names = Object.keys(descs);\n            for(var i = 0; i < names.length; i++){\n                var name = names[i];\n                var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n                var success = vhandler.defineProperty(name, normalizedDesc);\n                if (success === false) {\n                    throw new TypeError(\"can't redefine property '\" + name + \"'\");\n                }\n            }\n            return subject;\n        } else {\n            return prim_defineProperties(subject, descs);\n        }\n    };\n    Object.keys = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            var ownKeys = vHandler.ownKeys();\n            var result = [];\n            for(var i = 0; i < ownKeys.length; i++){\n                var k = String(ownKeys[i]);\n                var desc = Object.getOwnPropertyDescriptor(subject, k);\n                if (desc !== undefined && desc.enumerable === true) {\n                    result.push(k);\n                }\n            }\n            return result;\n        } else {\n            return prim_keys(subject);\n        }\n    };\n    Object.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n        var vHandler = directProxies.get(subject);\n        if (vHandler !== undefined) {\n            return vHandler.ownKeys();\n        } else {\n            return prim_getOwnPropertyNames(subject);\n        }\n    };\n    // fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n    // throws an error)\n    if (prim_getOwnPropertySymbols !== undefined) {\n        Object.getOwnPropertySymbols = function(subject) {\n            var vHandler = directProxies.get(subject);\n            if (vHandler !== undefined) {\n                // as this shim does not support symbols, a Proxy never advertises\n                // any symbol-valued own properties\n                return [];\n            } else {\n                return prim_getOwnPropertySymbols(subject);\n            }\n        };\n    }\n    // fixes issue #72 ('Illegal access' error when using Object.assign)\n    // Object.assign polyfill based on a polyfill posted on MDN: \n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n    //  Global_Objects/Object/assign\n    // Note that this polyfill does not support Symbols, but this Proxy Shim\n    // does not support Symbols anyway.\n    if (prim_assign !== undefined) {\n        Object.assign = function(target) {\n            // check if any argument is a proxy object\n            var noProxies = true;\n            for(var i = 0; i < arguments.length; i++){\n                var vHandler = directProxies.get(arguments[i]);\n                if (vHandler !== undefined) {\n                    noProxies = false;\n                    break;\n                }\n            }\n            if (noProxies) {\n                // not a single argument is a proxy, perform built-in algorithm\n                return prim_assign.apply(Object, arguments);\n            }\n            // there is at least one proxy argument, use the polyfill\n            if (target === undefined || target === null) {\n                throw new TypeError(\"Cannot convert undefined or null to object\");\n            }\n            var output = Object(target);\n            for(var index = 1; index < arguments.length; index++){\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for(var nextKey in source){\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    }\n    // returns whether an argument is a reference to an object,\n    // which is legal as a WeakMap key.\n    function isObject(arg) {\n        var type = typeof arg;\n        return type === \"object\" && arg !== null || type === \"function\";\n    }\n    ;\n    // a wrapper for WeakMap.get which returns the undefined value\n    // for keys that are not objects (in which case the underlying\n    // WeakMap would have thrown a TypeError).\n    function safeWeakMapGet(map, key) {\n        return isObject(key) ? map.get(key) : undefined;\n    }\n    ;\n    // returns a new function of zero arguments that recursively\n    // unwraps any proxies specified as the |this|-value.\n    // The primitive is assumed to be a zero-argument method\n    // that uses its |this|-binding.\n    function makeUnwrapping0ArgMethod(primitive) {\n        return function builtin() {\n            var vHandler = safeWeakMapGet(directProxies, this);\n            if (vHandler !== undefined) {\n                return builtin.call(vHandler.target);\n            } else {\n                return primitive.call(this);\n            }\n        };\n    }\n    ;\n    // returns a new function of 1 arguments that recursively\n    // unwraps any proxies specified as the |this|-value.\n    // The primitive is assumed to be a 1-argument method\n    // that uses its |this|-binding.\n    function makeUnwrapping1ArgMethod(primitive) {\n        return function builtin(arg) {\n            var vHandler = safeWeakMapGet(directProxies, this);\n            if (vHandler !== undefined) {\n                return builtin.call(vHandler.target, arg);\n            } else {\n                return primitive.call(this, arg);\n            }\n        };\n    }\n    ;\n    Object.prototype.valueOf = makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n    Object.prototype.toString = makeUnwrapping0ArgMethod(Object.prototype.toString);\n    Function.prototype.toString = makeUnwrapping0ArgMethod(Function.prototype.toString);\n    Date.prototype.toString = makeUnwrapping0ArgMethod(Date.prototype.toString);\n    Object.prototype.isPrototypeOf = function builtin(arg) {\n        // bugfix thanks to Bill Mark:\n        // built-in isPrototypeOf does not unwrap proxies used\n        // as arguments. So, we implement the builtin ourselves,\n        // based on the ECMAScript 6 spec. Our encoding will\n        // make sure that if a proxy is used as an argument,\n        // its getPrototypeOf trap will be called.\n        while(true){\n            var vHandler2 = safeWeakMapGet(directProxies, arg);\n            if (vHandler2 !== undefined) {\n                arg = vHandler2.getPrototypeOf();\n                if (arg === null) {\n                    return false;\n                } else if (sameValue(arg, this)) {\n                    return true;\n                }\n            } else {\n                return prim_isPrototypeOf.call(this, arg);\n            }\n        }\n    };\n    Array.isArray = function(subject) {\n        var vHandler = safeWeakMapGet(directProxies, subject);\n        if (vHandler !== undefined) {\n            return Array.isArray(vHandler.target);\n        } else {\n            return prim_isArray(subject);\n        }\n    };\n    function isProxyArray(arg) {\n        var vHandler = safeWeakMapGet(directProxies, arg);\n        if (vHandler !== undefined) {\n            return Array.isArray(vHandler.target);\n        }\n        return false;\n    }\n    // Array.prototype.concat internally tests whether one of its\n    // arguments is an Array, by checking whether [[Class]] == \"Array\"\n    // As such, it will fail to recognize proxies-for-arrays as arrays.\n    // We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n    // by making a copy. This will trigger the exact same sequence of\n    // traps on the proxy-for-array as if we would not have unwrapped it.\n    // See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n    Array.prototype.concat = function() {\n        var length;\n        for(var i = 0; i < arguments.length; i++){\n            if (isProxyArray(arguments[i])) {\n                length = arguments[i].length;\n                arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n            }\n        }\n        return prim_concat.apply(this, arguments);\n    };\n    // setPrototypeOf support on platforms that support __proto__\n    var prim_setPrototypeOf = Object.setPrototypeOf;\n    // patch and extract original __proto__ setter\n    var __proto__setter = function() {\n        var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n        if (protoDesc === undefined || typeof protoDesc.set !== \"function\") {\n            return function() {\n                throw new TypeError(\"setPrototypeOf not supported on this platform\");\n            };\n        }\n        // see if we can actually mutate a prototype with the generic setter\n        // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n        try {\n            protoDesc.set.call({}, {});\n        } catch (e) {\n            return function() {\n                throw new TypeError(\"setPrototypeOf not supported on this platform\");\n            };\n        }\n        prim_defineProperty(Object.prototype, \"__proto__\", {\n            set: function(newProto) {\n                return Object.setPrototypeOf(this, Object(newProto));\n            }\n        });\n        return protoDesc.set;\n    }();\n    Object.setPrototypeOf = function(target, newProto) {\n        var handler = directProxies.get(target);\n        if (handler !== undefined) {\n            if (handler.setPrototypeOf(newProto)) {\n                return target;\n            } else {\n                throw new TypeError(\"proxy rejected prototype mutation\");\n            }\n        } else {\n            if (!Object_isExtensible(target)) {\n                throw new TypeError(\"can't set prototype on non-extensible object: \" + target);\n            }\n            if (prim_setPrototypeOf) return prim_setPrototypeOf(target, newProto);\n            if (Object(newProto) !== newProto || newProto === null) {\n                throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n            // throw new TypeError(\"prototype must be an object or null\")\n            }\n            __proto__setter.call(target, newProto);\n            return target;\n        }\n    };\n    Object.prototype.hasOwnProperty = function(name) {\n        var handler = safeWeakMapGet(directProxies, this);\n        if (handler !== undefined) {\n            var desc = handler.getOwnPropertyDescriptor(name);\n            return desc !== undefined;\n        } else {\n            return prim_hasOwnProperty.call(this, name);\n        }\n    };\n    // ============= Reflection module =============\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n    var Reflect = {\n        getOwnPropertyDescriptor: function(target, name) {\n            return Object.getOwnPropertyDescriptor(target, name);\n        },\n        defineProperty: function(target, name, desc) {\n            // if target is a proxy, invoke its \"defineProperty\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.defineProperty(target, name, desc);\n            }\n            // Implementation transliterated from [[DefineOwnProperty]]\n            // see ES5.1 section 8.12.9\n            // this is the _exact same algorithm_ as the isCompatibleDescriptor\n            // algorithm defined above, except that at every place it\n            // returns true, this algorithm actually does define the property.\n            var current = Object.getOwnPropertyDescriptor(target, name);\n            var extensible = Object.isExtensible(target);\n            if (current === undefined && extensible === false) {\n                return false;\n            }\n            if (current === undefined && extensible === true) {\n                Object.defineProperty(target, name, desc); // should never fail\n                return true;\n            }\n            if (isEmptyDescriptor(desc)) {\n                return true;\n            }\n            if (isEquivalentDescriptor(current, desc)) {\n                return true;\n            }\n            if (current.configurable === false) {\n                if (desc.configurable === true) {\n                    return false;\n                }\n                if (\"enumerable\" in desc && desc.enumerable !== current.enumerable) {\n                    return false;\n                }\n            }\n            if (isGenericDescriptor(desc)) {\n            // no further validation necessary\n            } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n                if (current.configurable === false) {\n                    return false;\n                }\n            } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n                if (current.configurable === false) {\n                    if (current.writable === false && desc.writable === true) {\n                        return false;\n                    }\n                    if (current.writable === false) {\n                        if (\"value\" in desc && !sameValue(desc.value, current.value)) {\n                            return false;\n                        }\n                    }\n                }\n            } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n                if (current.configurable === false) {\n                    if (\"set\" in desc && !sameValue(desc.set, current.set)) {\n                        return false;\n                    }\n                    if (\"get\" in desc && !sameValue(desc.get, current.get)) {\n                        return false;\n                    }\n                }\n            }\n            Object.defineProperty(target, name, desc); // should never fail\n            return true;\n        },\n        deleteProperty: function(target, name) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.delete(name);\n            }\n            var desc = Object.getOwnPropertyDescriptor(target, name);\n            if (desc === undefined) {\n                return true;\n            }\n            if (desc.configurable === true) {\n                delete target[name];\n                return true;\n            }\n            return false;\n        },\n        getPrototypeOf: function(target) {\n            return Object.getPrototypeOf(target);\n        },\n        setPrototypeOf: function(target, newProto) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.setPrototypeOf(newProto);\n            }\n            if (Object(newProto) !== newProto || newProto === null) {\n                throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n            }\n            if (!Object_isExtensible(target)) {\n                return false;\n            }\n            var current = Object.getPrototypeOf(target);\n            if (sameValue(current, newProto)) {\n                return true;\n            }\n            if (prim_setPrototypeOf) {\n                try {\n                    prim_setPrototypeOf(target, newProto);\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            __proto__setter.call(target, newProto);\n            return true;\n        },\n        preventExtensions: function(target) {\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.preventExtensions();\n            }\n            prim_preventExtensions(target);\n            return true;\n        },\n        isExtensible: function(target) {\n            return Object.isExtensible(target);\n        },\n        has: function(target, name) {\n            return name in target;\n        },\n        get: function(target, name, receiver) {\n            receiver = receiver || target;\n            // if target is a proxy, invoke its \"get\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.get(receiver, name);\n            }\n            var desc = Object.getOwnPropertyDescriptor(target, name);\n            if (desc === undefined) {\n                var proto = Object.getPrototypeOf(target);\n                if (proto === null) {\n                    return undefined;\n                }\n                return Reflect.get(proto, name, receiver);\n            }\n            if (isDataDescriptor(desc)) {\n                return desc.value;\n            }\n            var getter = desc.get;\n            if (getter === undefined) {\n                return undefined;\n            }\n            return desc.get.call(receiver);\n        },\n        // Reflect.set implementation based on latest version of [[SetP]] at\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n        set: function(target, name, value, receiver) {\n            receiver = receiver || target;\n            // if target is a proxy, invoke its \"set\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.set(receiver, name, value);\n            }\n            // first, check whether target has a non-writable property\n            // shadowing name on receiver\n            var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n            if (ownDesc === undefined) {\n                // name is not defined in target, search target's prototype\n                var proto = Object.getPrototypeOf(target);\n                if (proto !== null) {\n                    // continue the search in target's prototype\n                    return Reflect.set(proto, name, value, receiver);\n                }\n                // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n                // target was the last prototype, now we know that 'name' is not shadowed\n                // by an existing (accessor or data) property, so we can add the property\n                // to the initial receiver object\n                // (this branch will intentionally fall through to the code below)\n                ownDesc = {\n                    value: undefined,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                };\n            }\n            // we now know that ownDesc !== undefined\n            if (isAccessorDescriptor(ownDesc)) {\n                var setter = ownDesc.set;\n                if (setter === undefined) return false;\n                setter.call(receiver, value); // assumes Function.prototype.call\n                return true;\n            }\n            // otherwise, isDataDescriptor(ownDesc) must be true\n            if (ownDesc.writable === false) return false;\n            // we found an existing writable data property on the prototype chain.\n            // Now update or add the data property on the receiver, depending on\n            // whether the receiver already defines the property or not.\n            var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n            if (existingDesc !== undefined) {\n                var updateDesc = {\n                    value: value,\n                    // FIXME: it should not be necessary to describe the following\n                    // attributes. Added to circumvent a bug in tracemonkey:\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n                    writable: existingDesc.writable,\n                    enumerable: existingDesc.enumerable,\n                    configurable: existingDesc.configurable\n                };\n                Object.defineProperty(receiver, name, updateDesc);\n                return true;\n            } else {\n                if (!Object.isExtensible(receiver)) return false;\n                var newDesc = {\n                    value: value,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                };\n                Object.defineProperty(receiver, name, newDesc);\n                return true;\n            }\n        },\n        /*invoke: function(target, name, args, receiver) {\n    receiver = receiver || target;\n\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.invoke(receiver, name, args);\n    }\n\n    var fun = Reflect.get(target, name, receiver);\n    return Function.prototype.apply.call(fun, receiver, args);\n  },*/ enumerate: function(target) {\n            var handler = directProxies.get(target);\n            var result;\n            if (handler !== undefined) {\n                // handler.enumerate should return an iterator directly, but the\n                // iterator gets converted to an array for backward-compat reasons,\n                // so we must re-iterate over the array\n                result = handler.enumerate(handler.target);\n            } else {\n                result = [];\n                for(var name in target){\n                    result.push(name);\n                }\n                ;\n            }\n            var l = +result.length;\n            var idx = 0;\n            return {\n                next: function() {\n                    if (idx === l) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: result[idx++]\n                    };\n                }\n            };\n        },\n        // imperfect ownKeys implementation: in ES6, should also include\n        // symbol-keyed properties.\n        ownKeys: function(target) {\n            return Object_getOwnPropertyNames(target);\n        },\n        apply: function(target, receiver, args) {\n            // target.apply(receiver, args)\n            return Function.prototype.apply.call(target, receiver, args);\n        },\n        construct: function(target, args, newTarget) {\n            // return new target(...args);\n            // if target is a proxy, invoke its \"construct\" trap\n            var handler = directProxies.get(target);\n            if (handler !== undefined) {\n                return handler.construct(handler.target, args, newTarget);\n            }\n            if (typeof target !== \"function\") {\n                throw new TypeError(\"target is not a function: \" + target);\n            }\n            if (newTarget === undefined || newTarget === target) {\n                // If newTarget is undefined, then newTarget is set to `target` and\n                // `Reflect.construct(target, ...args)` becomes equivalent to\n                // `new target(...args)`\n                // if `target` is an ES2015 Class constructor, it must be called using\n                // the `new` operator. Hence we use the new operator on a bound function\n                // to trigger the [[Construct]] internal method. This technique will work \n                // for both plain constructor functions and ES2015 classes\n                return new (Function.prototype.bind.apply(target, [\n                    null\n                ].concat(args)));\n            } else {\n                if (typeof newTarget !== \"function\") {\n                    throw new TypeError(\"newTarget is not a function: \" + target);\n                }\n                // if newTarget is a *different* constructor function, we need to\n                // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n                // new instance inheriting from newTarget.prototype\n                // Unfortunately this won't work if target is an ES2015 Constructor\n                // function, whose [[Call]] method throws an error (it must be invoked\n                // using the `new` operator)\n                var proto = newTarget.prototype;\n                var instance = Object(proto) === proto ? Object.create(proto) : {};\n                var result = Function.prototype.apply.call(target, instance, args);\n                return Object(result) === result ? result : instance;\n            }\n        }\n    };\n    // feature-test whether the Reflect global exists\n    if (global1.Reflect !== undefined) {\n        // Reflect exists, add/override the shimmed methods\n        Object.getOwnPropertyNames(Reflect).forEach(function(key) {\n            global1.Reflect[key] = Reflect[key];\n        });\n    } else {\n        // Reflect doesn't exist, define it as the shimmed Reflect object\n        global1.Reflect = Reflect;\n    }\n    // feature-test whether the Proxy global exists, with\n    // the harmony-era Proxy.create API\n    if (typeof Proxy !== \"undefined\" && typeof Proxy.create !== \"undefined\") {\n        var primCreate = Proxy.create, primCreateFunction = Proxy.createFunction;\n        var revokedHandler = primCreate({\n            get: function() {\n                throw new TypeError(\"proxy is revoked\");\n            }\n        });\n        global1.Proxy = function(target, handler) {\n            // check that target is an Object\n            if (Object(target) !== target) {\n                throw new TypeError(\"Proxy target must be an Object, given \" + target);\n            }\n            // check that handler is an Object\n            if (Object(handler) !== handler) {\n                throw new TypeError(\"Proxy handler must be an Object, given \" + handler);\n            }\n            var vHandler = new Validator(target, handler);\n            var proxy;\n            if (typeof target === \"function\") {\n                proxy = primCreateFunction(vHandler, // call trap\n                function() {\n                    var args = Array.prototype.slice.call(arguments);\n                    return vHandler.apply(target, this, args);\n                }, // construct trap\n                function() {\n                    var args = Array.prototype.slice.call(arguments);\n                    return vHandler.construct(target, args);\n                });\n            } else {\n                proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n            }\n            directProxies.set(proxy, vHandler);\n            return proxy;\n        };\n        global1.Proxy.revocable = function(target, handler) {\n            var proxy = new Proxy(target, handler);\n            var revoke = function() {\n                var vHandler = directProxies.get(proxy);\n                if (vHandler !== null) {\n                    vHandler.target = null;\n                    vHandler.handler = revokedHandler;\n                }\n                return undefined;\n            };\n            return {\n                proxy: proxy,\n                revoke: revoke\n            };\n        };\n        // add the old Proxy.create and Proxy.createFunction methods\n        // so old code that still depends on the harmony-era Proxy object\n        // is not broken. Also ensures that multiple versions of this\n        // library should load fine\n        global1.Proxy.create = primCreate;\n        global1.Proxy.createFunction = primCreateFunction;\n    } else {\n        // Proxy global not defined, or old API not available\n        if (typeof Proxy === \"undefined\") {\n            // Proxy global not defined, add a Proxy function stub\n            global1.Proxy = function(_target, _handler) {\n                throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n            };\n        }\n    // Proxy global defined but old API not available\n    // presumably Proxy global already supports new API, leave untouched\n    }\n    // for node.js modules, export every property in the Reflect object\n    // as part of the module interface\n    if (true) {\n        Object.keys(Reflect).forEach(function(key) {\n            exports[key] = Reflect[key];\n        });\n    }\n// function-as-module pattern\n})(typeof exports !== \"undefined\" ? global : this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGFybW9ueS1yZWZsZWN0L3JlZmxlY3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkVBQTZFO0FBQzdFLHVFQUF1RTtBQUV2RSxrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0YsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBRWpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FFQSwrRUFBK0U7QUFFL0UsbUVBQW1FO0FBQ25FLGlFQUFpRTtBQUNqRSw2REFBNkQ7QUFDN0QsZ0VBQWdFO0FBRWhFLCtFQUErRTtBQUMvRSxvRUFBb0U7QUFFcEUsMERBQTBEO0FBQzFELDRFQUE0RTtBQUU1RSxtREFBbUQ7QUFDcEQscUVBQXFFO0FBQ3BFLG1DQUFtQztBQUNuQyx1REFBdUQ7QUFFdkQseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qiw2Q0FBNkM7QUFDN0Msc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWCw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQywyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCLFdBQVc7QUFDWCxvQkFBb0I7QUFDcEIsYUFBYTtBQUViLDJEQUEyRDtBQUUzRCwrRUFBK0U7QUFFL0UsVUFBU0EsT0FBTTtJQUNoQjtJQUVBLGdEQUFnRDtJQUVoRCx1RUFBdUU7SUFDdkUseUVBQXlFO0lBQ3pFLDJCQUEyQjtJ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TCxLQUFLLENBQUNNLFNBQVMsR0FBRyxTQUFTN0csTUFBTSxFQUFFbUIsT0FBTztZQUMvQyxJQUFJeUYsUUFBUSxJQUFJTCxNQUFNdkcsUUFBUW1CO1lBQzlCLElBQUkyRixTQUFTO2dCQUNYLElBQUk3QyxXQUFXSCxjQUFjNUksR0FBRyxDQUFDMEw7Z0JBQ2pDLElBQUkzQyxhQUFhLE1BQU07b0JBQ3JCQSxTQUFTakUsTUFBTSxHQUFJO29CQUNuQmlFLFNBQVM5QyxPQUFPLEdBQUd3RjtnQkFDckI7Z0JBQ0EsT0FBT3ZMO1lBQ1Q7WUFDQSxPQUFPO2dCQUFDd0wsT0FBT0E7Z0JBQU9FLFFBQVFBO1lBQU07UUFDdEM7UUFFQSw0REFBNEQ7UUFDNUQsaUVBQWlFO1FBQ2pFLDZEQUE2RDtRQUM3RCwyQkFBMkI7UUFDM0IvTCxRQUFPd0wsS0FBSyxDQUFDcEUsTUFBTSxHQUFHcUU7UUFDdEJ6TCxRQUFPd0wsS0FBSyxDQUFDRyxjQUFjLEdBQUdEO0lBRWhDLE9BQU87UUFDTCxxREFBcUQ7UUFDckQsSUFBSSxPQUFPRixVQUFVLGFBQWE7WUFDaEMsc0RBQXNEO1lBQ3REeEwsUUFBT3dMLEtBQUssR0FBRyxTQUFTUSxPQUFPLEVBQUVDLFFBQVE7Z0JBQ3ZDLE1BQU0sSUFBSXpMLE1BQU07WUFDbEI7UUFDRjtJQUNBLGlEQUFpRDtJQUNqRCxvRUFBb0U7SUFDdEU7SUFFQSxtRUFBbUU7SUFDbkUsa0NBQWtDO0lBQ2xDLElBQUksSUFBbUIsRUFBYTtRQUNsQ00sT0FBTzZDLElBQUksQ0FBQ3NDLFNBQVN1QixPQUFPLENBQUMsU0FBVXlDLEdBQUc7WUFDeENpQyxPQUFPLENBQUNqQyxJQUFJLEdBQUdoRSxPQUFPLENBQUNnRSxJQUFJO1FBQzdCO0lBQ0Y7QUFFQSw2QkFBNkI7QUFDN0IsR0FBRSxPQUFPaUMsWUFBWSxjQUFjbE0sU0FBUyxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0LWFuYWx5dGljcy8uL25vZGVfbW9kdWxlcy9oYXJtb255LXJlZmxlY3QvcmVmbGVjdC5qcz85YzlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMS0yMDEyIFNvZnR3YXJlIExhbmd1YWdlcyBMYWIsIFZyaWplIFVuaXZlcnNpdGVpdCBCcnVzc2VsXG4vLyBUaGlzIGNvZGUgaXMgZHVhbC1saWNlbnNlZCB1bmRlciBib3RoIHRoZSBBcGFjaGUgTGljZW5zZSBhbmQgdGhlIE1QTFxuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyogVmVyc2lvbjogTVBMIDEuMVxuICpcbiAqIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UgVmVyc2lvblxuICogMS4xICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGhcbiAqIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqIGh0dHA6Ly93d3cubW96aWxsYS5vcmcvTVBML1xuICpcbiAqIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiAqIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuICogZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGVcbiAqIExpY2Vuc2UuXG4gKlxuICogVGhlIE9yaWdpbmFsIENvZGUgaXMgYSBzaGltIGZvciB0aGUgRVMtSGFybW9ueSByZWZsZWN0aW9uIG1vZHVsZVxuICpcbiAqIFRoZSBJbml0aWFsIERldmVsb3BlciBvZiB0aGUgT3JpZ2luYWwgQ29kZSBpc1xuICogVG9tIFZhbiBDdXRzZW0sIFZyaWplIFVuaXZlcnNpdGVpdCBCcnVzc2VsLlxuICogUG9ydGlvbnMgY3JlYXRlZCBieSB0aGUgSW5pdGlhbCBEZXZlbG9wZXIgYXJlIENvcHlyaWdodCAoQykgMjAxMS0yMDEyXG4gKiB0aGUgSW5pdGlhbCBEZXZlbG9wZXIuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogQ29udHJpYnV0b3Iocyk6XG4gKlxuICovXG5cbiAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAvLyBUaGlzIGZpbGUgaXMgYSBwb2x5ZmlsbCBmb3IgdGhlIHVwY29taW5nIEVDTUFTY3JpcHQgUmVmbGVjdCBBUEksXG4gLy8gaW5jbHVkaW5nIHN1cHBvcnQgZm9yIFByb3hpZXMuIFNlZSB0aGUgZHJhZnQgc3BlY2lmaWNhdGlvbiBhdDpcbiAvLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OnJlZmxlY3RfYXBpXG4gLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpkaXJlY3RfcHJveGllc1xuXG4gLy8gRm9yIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBIYW5kbGVyIEFQSSwgc2VlIGhhbmRsZXJzLmpzLCB3aGljaCBpbXBsZW1lbnRzOlxuIC8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6dmlydHVhbF9vYmplY3RfYXBpXG5cbiAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHN1cGVyc2VkZXMgdGhlIGVhcmxpZXIgcG9seWZpbGwgYXQ6XG4gLy8gY29kZS5nb29nbGUuY29tL3AvZXMtbGFiL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL3Byb3hpZXMvRGlyZWN0UHJveGllcy5qc1xuXG4gLy8gVGhpcyBjb2RlIHdhcyB0ZXN0ZWQgb24gdHJhY2Vtb25rZXkgLyBGaXJlZm94IDEyXG4vLyAgKGFuZCBzaG91bGQgcnVuIGZpbmUgb24gb2xkZXIgRmlyZWZveCB2ZXJzaW9ucyBzdGFydGluZyB3aXRoIEZGNClcbiAvLyBUaGUgY29kZSBhbHNvIHdvcmtzIGNvcnJlY3RseSBvblxuIC8vICAgdjggLS1oYXJtb255X3Byb3hpZXMgLS1oYXJtb255X3dlYWttYXBzICh2My42LjUuMSlcblxuIC8vIExhbmd1YWdlIERlcGVuZGVuY2llczpcbiAvLyAgLSBFQ01BU2NyaXB0IDUvc3RyaWN0XG4gLy8gIC0gXCJvbGRcIiAoaS5lLiBub24tZGlyZWN0KSBIYXJtb255IFByb3hpZXNcbiAvLyAgLSBIYXJtb255IFdlYWtNYXBzXG4gLy8gUGF0Y2hlczpcbiAvLyAgLSBPYmplY3Que2ZyZWV6ZSxzZWFsLHByZXZlbnRFeHRlbnNpb25zfVxuIC8vICAtIE9iamVjdC57aXNGcm96ZW4saXNTZWFsZWQsaXNFeHRlbnNpYmxlfVxuIC8vICAtIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuIC8vICAtIE9iamVjdC5rZXlzXG4gLy8gIC0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mXG4gLy8gIC0gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mXG4gLy8gIC0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuIC8vICAtIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAvLyAgLSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gLy8gIC0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gLy8gIC0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAvLyAgLSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuIC8vICAtIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAvLyAgLSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAvLyAgLSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAvLyAgLSBPYmplY3QuYXNzaWduXG4gLy8gIC0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nXG4gLy8gIC0gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmdcbiAvLyAgLSBBcnJheS5pc0FycmF5XG4gLy8gIC0gQXJyYXkucHJvdG90eXBlLmNvbmNhdFxuIC8vICAtIFByb3h5XG4gLy8gQWRkcyBuZXcgZ2xvYmFsczpcbiAvLyAgLSBSZWZsZWN0XG5cbiAvLyBEaXJlY3QgcHJveGllcyBjYW4gYmUgY3JlYXRlZCB2aWEgUHJveHkodGFyZ2V0LCBoYW5kbGVyKVxuXG4gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4oZnVuY3Rpb24oZ2xvYmFsKXsgLy8gZnVuY3Rpb24tYXMtbW9kdWxlIHBhdHRlcm5cblwidXNlIHN0cmljdFwiO1xuXG4vLyA9PT0gRGlyZWN0IFByb3hpZXM6IEludmFyaWFudCBFbmZvcmNlbWVudCA9PT1cblxuLy8gRGlyZWN0IHByb3hpZXMgYnVpbGQgb24gbm9uLWRpcmVjdCBwcm94aWVzIGJ5IGF1dG9tYXRpY2FsbHkgd3JhcHBpbmdcbi8vIGFsbCB1c2VyLWRlZmluZWQgcHJveHkgaGFuZGxlcnMgaW4gYSBWYWxpZGF0b3IgaGFuZGxlciB0aGF0IGNoZWNrcyBhbmRcbi8vIGVuZm9yY2VzIEVTNSBpbnZhcmlhbnRzLlxuXG4vLyBBIGRpcmVjdCBwcm94eSBpcyBhIHByb3h5IGZvciBhbiBleGlzdGluZyBvYmplY3QgY2FsbGVkIHRoZSB0YXJnZXQgb2JqZWN0LlxuXG4vLyBBIFZhbGlkYXRvciBoYW5kbGVyIGlzIGEgd3JhcHBlciBmb3IgYSB0YXJnZXQgcHJveHkgaGFuZGxlciBILlxuLy8gVGhlIFZhbGlkYXRvciBmb3J3YXJkcyBhbGwgb3BlcmF0aW9ucyB0byBILCBidXQgYWRkaXRpb25hbGx5XG4vLyBwZXJmb3JtcyBhIG51bWJlciBvZiBpbnRlZ3JpdHkgY2hlY2tzIG9uIHRoZSByZXN1bHRzIG9mIHNvbWUgdHJhcHMsXG4vLyB0byBtYWtlIHN1cmUgSCBkb2VzIG5vdCB2aW9sYXRlIHRoZSBFUzUgaW52YXJpYW50cyB3LnIudC4gbm9uLWNvbmZpZ3VyYWJsZVxuLy8gcHJvcGVydGllcyBhbmQgbm9uLWV4dGVuc2libGUsIHNlYWxlZCBvciBmcm96ZW4gb2JqZWN0cy5cblxuLy8gRm9yIGVhY2ggcHJvcGVydHkgdGhhdCBIIGV4cG9zZXMgYXMgb3duLCBub24tY29uZmlndXJhYmxlXG4vLyAoZS5nLiBieSByZXR1cm5pbmcgYSBkZXNjcmlwdG9yIGZyb20gYSBjYWxsIHRvIGdldE93blByb3BlcnR5RGVzY3JpcHRvcilcbi8vIHRoZSBWYWxpZGF0b3IgaGFuZGxlciBkZWZpbmVzIHRob3NlIHByb3BlcnRpZXMgb24gdGhlIHRhcmdldCBvYmplY3QuXG4vLyBXaGVuIHRoZSBwcm94eSBiZWNvbWVzIG5vbi1leHRlbnNpYmxlLCBhbHNvIGNvbmZpZ3VyYWJsZSBvd24gcHJvcGVydGllc1xuLy8gYXJlIGNoZWNrZWQgYWdhaW5zdCB0aGUgdGFyZ2V0LlxuLy8gV2Ugd2lsbCBjYWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdFxuLy8gXCJmaXhlZCBwcm9wZXJ0aWVzXCIuXG5cbi8vIFdlIHdpbGwgbmFtZSBmaXhlZCBub24tY29uZmlndXJhYmxlIHByb3BlcnRpZXMgXCJzZWFsZWQgcHJvcGVydGllc1wiLlxuLy8gV2Ugd2lsbCBuYW1lIGZpeGVkIG5vbi1jb25maWd1cmFibGUgbm9uLXdyaXRhYmxlIHByb3BlcnRpZXMgXCJmcm96ZW5cbi8vIHByb3BlcnRpZXNcIi5cblxuLy8gVGhlIFZhbGlkYXRvciBoYW5kbGVyIHVwaG9sZHMgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIHcuci50LiBub24tY29uZmlndXJhYmlsaXR5OlxuLy8gLSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgY2Fubm90IHJlcG9ydCBzZWFsZWQgcHJvcGVydGllcyBhcyBub24tZXhpc3RlbnRcbi8vIC0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbm5vdCByZXBvcnQgaW5jb21wYXRpYmxlIGNoYW5nZXMgdG8gdGhlXG4vLyAgIGF0dHJpYnV0ZXMgb2YgYSBzZWFsZWQgcHJvcGVydHkgKGUuZy4gcmVwb3J0aW5nIGEgbm9uLWNvbmZpZ3VyYWJsZVxuLy8gICBwcm9wZXJ0eSBhcyBjb25maWd1cmFibGUsIG9yIHJlcG9ydGluZyBhIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZVxuLy8gICBwcm9wZXJ0eSBhcyB3cml0YWJsZSlcbi8vIC0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yIGNhbm5vdCByZXBvcnQgc2VhbGVkIHByb3BlcnRpZXMgYXMgbm9uLWV4aXN0ZW50XG4vLyAtIGdldFByb3BlcnR5RGVzY3JpcHRvciBjYW5ub3QgcmVwb3J0IGluY29tcGF0aWJsZSBjaGFuZ2VzIHRvIHRoZVxuLy8gICBhdHRyaWJ1dGVzIG9mIGEgc2VhbGVkIHByb3BlcnR5LiBJdCBfY2FuXyByZXBvcnQgaW5jb21wYXRpYmxlIGNoYW5nZXNcbi8vICAgdG8gdGhlIGF0dHJpYnV0ZXMgb2Ygbm9uLW93biwgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4vLyAtIGRlZmluZVByb3BlcnR5IGNhbm5vdCBtYWtlIGluY29tcGF0aWJsZSBjaGFuZ2VzIHRvIHRoZSBhdHRyaWJ1dGVzIG9mXG4vLyAgIHNlYWxlZCBwcm9wZXJ0aWVzXG4vLyAtIGRlbGV0ZVByb3BlcnR5IGNhbm5vdCByZXBvcnQgYSBzdWNjZXNzZnVsIGRlbGV0aW9uIG9mIGEgc2VhbGVkIHByb3BlcnR5XG4vLyAtIGhhc093biBjYW5ub3QgcmVwb3J0IGEgc2VhbGVkIHByb3BlcnR5IGFzIG5vbi1leGlzdGVudFxuLy8gLSBoYXMgY2Fubm90IHJlcG9ydCBhIHNlYWxlZCBwcm9wZXJ0eSBhcyBub24tZXhpc3RlbnRcbi8vIC0gZ2V0IGNhbm5vdCByZXBvcnQgaW5jb25zaXN0ZW50IHZhbHVlcyBmb3IgZnJvemVuIGRhdGFcbi8vICAgcHJvcGVydGllcywgYW5kIG11c3QgcmVwb3J0IHVuZGVmaW5lZCBmb3Igc2VhbGVkIGFjY2Vzc29ycyB3aXRoIGFuXG4vLyAgIHVuZGVmaW5lZCBnZXR0ZXJcbi8vIC0gc2V0IGNhbm5vdCByZXBvcnQgYSBzdWNjZXNzZnVsIGFzc2lnbm1lbnQgZm9yIGZyb3plbiBkYXRhXG4vLyAgIHByb3BlcnRpZXMgb3Igc2VhbGVkIGFjY2Vzc29ycyB3aXRoIGFuIHVuZGVmaW5lZCBzZXR0ZXIuXG4vLyAtIGdldHtPd259UHJvcGVydHlOYW1lcyBsaXN0cyBhbGwgc2VhbGVkIHByb3BlcnRpZXMgb2YgdGhlIHRhcmdldC5cbi8vIC0ga2V5cyBsaXN0cyBhbGwgZW51bWVyYWJsZSBzZWFsZWQgcHJvcGVydGllcyBvZiB0aGUgdGFyZ2V0LlxuLy8gLSBlbnVtZXJhdGUgbGlzdHMgYWxsIGVudW1lcmFibGUgc2VhbGVkIHByb3BlcnRpZXMgb2YgdGhlIHRhcmdldC5cbi8vIC0gaWYgYSBwcm9wZXJ0eSBvZiBhIG5vbi1leHRlbnNpYmxlIHByb3h5IGlzIHJlcG9ydGVkIGFzIG5vbi1leGlzdGVudCxcbi8vICAgdGhlbiBpdCBtdXN0IGZvcmV2ZXIgYmUgcmVwb3J0ZWQgYXMgbm9uLWV4aXN0ZW50LiBUaGlzIGFwcGxpZXMgdG9cbi8vICAgb3duIGFuZCBpbmhlcml0ZWQgcHJvcGVydGllcyBhbmQgaXMgZW5mb3JjZWQgaW4gdGhlXG4vLyAgIGRlbGV0ZVByb3BlcnR5LCBnZXR7T3dufVByb3BlcnR5RGVzY3JpcHRvciwgaGFze093bn0sXG4vLyAgIGdldHtPd259UHJvcGVydHlOYW1lcywga2V5cyBhbmQgZW51bWVyYXRlIHRyYXBzXG5cbi8vIFZpb2xhdGlvbiBvZiBhbnkgb2YgdGhlc2UgaW52YXJpYW50cyBieSBIIHdpbGwgcmVzdWx0IGluIFR5cGVFcnJvciBiZWluZ1xuLy8gdGhyb3duLlxuXG4vLyBBZGRpdGlvbmFsbHksIG9uY2UgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zLCBPYmplY3Quc2VhbCBvciBPYmplY3QuZnJlZXplXG4vLyBpcyBpbnZva2VkIG9uIHRoZSBwcm94eSwgdGhlIHNldCBvZiBvd24gcHJvcGVydHkgbmFtZXMgZm9yIHRoZSBwcm94eSBpc1xuLy8gZml4ZWQuIEFueSBwcm9wZXJ0eSBuYW1lIHRoYXQgaXMgbm90IGZpeGVkIGlzIGNhbGxlZCBhICduZXcnIHByb3BlcnR5LlxuXG4vLyBUaGUgVmFsaWRhdG9yIHVwaG9sZHMgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIHJlZ2FyZGluZyBleHRlbnNpYmlsaXR5OlxuLy8gLSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgY2Fubm90IHJlcG9ydCBuZXcgcHJvcGVydGllcyBhcyBleGlzdGVudFxuLy8gICAoaXQgbXVzdCByZXBvcnQgdGhlbSBhcyBub24tZXhpc3RlbnQgYnkgcmV0dXJuaW5nIHVuZGVmaW5lZClcbi8vIC0gZGVmaW5lUHJvcGVydHkgY2Fubm90IHN1Y2Nlc3NmdWxseSBhZGQgYSBuZXcgcHJvcGVydHkgKGl0IG11c3QgcmVqZWN0KVxuLy8gLSBnZXRPd25Qcm9wZXJ0eU5hbWVzIGNhbm5vdCBsaXN0IG5ldyBwcm9wZXJ0aWVzXG4vLyAtIGhhc093biBjYW5ub3QgcmVwb3J0IHRydWUgZm9yIG5ldyBwcm9wZXJ0aWVzIChpdCBtdXN0IHJlcG9ydCBmYWxzZSlcbi8vIC0ga2V5cyBjYW5ub3QgbGlzdCBuZXcgcHJvcGVydGllc1xuXG4vLyBJbnZhcmlhbnRzIGN1cnJlbnRseSBub3QgZW5mb3JjZWQ6XG4vLyAtIGdldE93blByb3BlcnR5TmFtZXMgbGlzdHMgb25seSBvd24gcHJvcGVydHkgbmFtZXNcbi8vIC0ga2V5cyBsaXN0cyBvbmx5IGVudW1lcmFibGUgb3duIHByb3BlcnR5IG5hbWVzXG4vLyBCb3RoIHRyYXBzIG1heSBsaXN0IG1vcmUgcHJvcGVydHkgbmFtZXMgdGhhbiBhcmUgYWN0dWFsbHkgZGVmaW5lZCBvbiB0aGVcbi8vIHRhcmdldC5cblxuLy8gSW52YXJpYW50cyB3aXRoIHJlZ2FyZCB0byBpbmhlcml0YW5jZSBhcmUgY3VycmVudGx5IG5vdCBlbmZvcmNlZC5cbi8vIC0gYSBub24tY29uZmlndXJhYmxlIHBvdGVudGlhbGx5IGluaGVyaXRlZCBwcm9wZXJ0eSBvbiBhIHByb3h5IHdpdGhcbi8vICAgbm9uLW11dGFibGUgYW5jZXN0cnkgY2Fubm90IGJlIHJlcG9ydGVkIGFzIG5vbi1leGlzdGVudFxuLy8gKEFuIG9iamVjdCB3aXRoIG5vbi1tdXRhYmxlIGFuY2VzdHJ5IGlzIGEgbm9uLWV4dGVuc2libGUgb2JqZWN0IHdob3NlXG4vLyBbW1Byb3RvdHlwZV1dIGlzIGVpdGhlciBudWxsIG9yIGFuIG9iamVjdCB3aXRoIG5vbi1tdXRhYmxlIGFuY2VzdHJ5LilcblxuLy8gQ2hhbmdlcyBpbiBIYW5kbGVyIEFQSSBjb21wYXJlZCB0byBwcmV2aW91cyBoYXJtb255OnByb3hpZXMsIHNlZTpcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmRpcmVjdF9wcm94aWVzXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmRpcmVjdF9wcm94aWVzXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gLS0tLSBXZWFrTWFwIHBvbHlmaWxsIC0tLS1cblxuLy8gVE9ETzogZmluZCBhIHByb3BlciBXZWFrTWFwIHBvbHlmaWxsXG5cbi8vIGRlZmluZSBhbiBlbXB0eSBXZWFrTWFwIHNvIHRoYXQgYXQgbGVhc3QgdGhlIFJlZmxlY3QgbW9kdWxlIGNvZGVcbi8vIHdpbGwgd29yayBpbiB0aGUgYWJzZW5jZSBvZiBXZWFrTWFwcy4gUHJveHkgZW11bGF0aW9uIGRlcGVuZHMgb25cbi8vIGFjdHVhbCBXZWFrTWFwcywgc28gd2lsbCBub3Qgd29yayB3aXRoIHRoaXMgbGl0dGxlIHNoaW0uXG5pZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgZ2xvYmFsLldlYWtNYXAgPSBmdW5jdGlvbigpe307XG4gIGdsb2JhbC5XZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGssdikgeyB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIG5vdCBzdXBwb3J0ZWRcIik7IH1cbiAgfTtcbn1cblxuLy8gLS0tLSBOb3JtYWxpemF0aW9uIGZ1bmN0aW9ucyBmb3IgcHJvcGVydHkgZGVzY3JpcHRvcnMgLS0tLVxuXG5mdW5jdGlvbiBpc1N0YW5kYXJkQXR0cmlidXRlKG5hbWUpIHtcbiAgcmV0dXJuIC9eKGdldHxzZXR8dmFsdWV8d3JpdGFibGV8ZW51bWVyYWJsZXxjb25maWd1cmFibGUpJC8udGVzdChuYW1lKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIEVTNSBzZWN0aW9uIDguMTAuNVxuZnVuY3Rpb24gdG9Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqKSB7XG4gIGlmIChPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3BlcnR5IGRlc2NyaXB0b3Igc2hvdWxkIGJlIGFuIE9iamVjdCwgZ2l2ZW46IFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqKTtcbiAgfVxuICB2YXIgZGVzYyA9IHt9O1xuICBpZiAoJ2VudW1lcmFibGUnIGluIG9iaikgeyBkZXNjLmVudW1lcmFibGUgPSAhIW9iai5lbnVtZXJhYmxlOyB9XG4gIGlmICgnY29uZmlndXJhYmxlJyBpbiBvYmopIHsgZGVzYy5jb25maWd1cmFibGUgPSAhIW9iai5jb25maWd1cmFibGU7IH1cbiAgaWYgKCd2YWx1ZScgaW4gb2JqKSB7IGRlc2MudmFsdWUgPSBvYmoudmFsdWU7IH1cbiAgaWYgKCd3cml0YWJsZScgaW4gb2JqKSB7IGRlc2Mud3JpdGFibGUgPSAhIW9iai53cml0YWJsZTsgfVxuICBpZiAoJ2dldCcgaW4gb2JqKSB7XG4gICAgdmFyIGdldHRlciA9IG9iai5nZXQ7XG4gICAgaWYgKGdldHRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBnZXR0ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3BlcnR5IGRlc2NyaXB0b3IgJ2dldCcgYXR0cmlidXRlIG11c3QgYmUgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FsbGFibGUgb3IgdW5kZWZpbmVkLCBnaXZlbjogXCIrZ2V0dGVyKTtcbiAgICB9XG4gICAgZGVzYy5nZXQgPSBnZXR0ZXI7XG4gIH1cbiAgaWYgKCdzZXQnIGluIG9iaikge1xuICAgIHZhciBzZXR0ZXIgPSBvYmouc2V0O1xuICAgIGlmIChzZXR0ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc2V0dGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wZXJ0eSBkZXNjcmlwdG9yICdzZXQnIGF0dHJpYnV0ZSBtdXN0IGJlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNhbGxhYmxlIG9yIHVuZGVmaW5lZCwgZ2l2ZW46IFwiK3NldHRlcik7XG4gICAgfVxuICAgIGRlc2Muc2V0ID0gc2V0dGVyO1xuICB9XG4gIGlmICgnZ2V0JyBpbiBkZXNjIHx8ICdzZXQnIGluIGRlc2MpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8ICd3cml0YWJsZScgaW4gZGVzYykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3BlcnR5IGRlc2NyaXB0b3IgY2Fubm90IGJlIGJvdGggYSBkYXRhIGFuZCBhbiBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhY2Nlc3NvciBkZXNjcmlwdG9yOiBcIitvYmopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzYztcbn1cblxuZnVuY3Rpb24gaXNBY2Nlc3NvckRlc2NyaXB0b3IoZGVzYykge1xuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoJ2dldCcgaW4gZGVzYyB8fCAnc2V0JyBpbiBkZXNjKTtcbn1cbmZ1bmN0aW9uIGlzRGF0YURlc2NyaXB0b3IoZGVzYykge1xuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoJ3ZhbHVlJyBpbiBkZXNjIHx8ICd3cml0YWJsZScgaW4gZGVzYyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyaWNEZXNjcmlwdG9yKGRlc2MpIHtcbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIWlzQWNjZXNzb3JEZXNjcmlwdG9yKGRlc2MpICYmICFpc0RhdGFEZXNjcmlwdG9yKGRlc2MpO1xufVxuXG5mdW5jdGlvbiB0b0NvbXBsZXRlUHJvcGVydHlEZXNjcmlwdG9yKGRlc2MpIHtcbiAgdmFyIGludGVybmFsRGVzYyA9IHRvUHJvcGVydHlEZXNjcmlwdG9yKGRlc2MpO1xuICBpZiAoaXNHZW5lcmljRGVzY3JpcHRvcihpbnRlcm5hbERlc2MpIHx8IGlzRGF0YURlc2NyaXB0b3IoaW50ZXJuYWxEZXNjKSkge1xuICAgIGlmICghKCd2YWx1ZScgaW4gaW50ZXJuYWxEZXNjKSkgeyBpbnRlcm5hbERlc2MudmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICBpZiAoISgnd3JpdGFibGUnIGluIGludGVybmFsRGVzYykpIHsgaW50ZXJuYWxEZXNjLndyaXRhYmxlID0gZmFsc2U7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISgnZ2V0JyBpbiBpbnRlcm5hbERlc2MpKSB7IGludGVybmFsRGVzYy5nZXQgPSB1bmRlZmluZWQ7IH1cbiAgICBpZiAoISgnc2V0JyBpbiBpbnRlcm5hbERlc2MpKSB7IGludGVybmFsRGVzYy5zZXQgPSB1bmRlZmluZWQ7IH1cbiAgfVxuICBpZiAoISgnZW51bWVyYWJsZScgaW4gaW50ZXJuYWxEZXNjKSkgeyBpbnRlcm5hbERlc2MuZW51bWVyYWJsZSA9IGZhbHNlOyB9XG4gIGlmICghKCdjb25maWd1cmFibGUnIGluIGludGVybmFsRGVzYykpIHsgaW50ZXJuYWxEZXNjLmNvbmZpZ3VyYWJsZSA9IGZhbHNlOyB9XG4gIHJldHVybiBpbnRlcm5hbERlc2M7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlEZXNjcmlwdG9yKGRlc2MpIHtcbiAgcmV0dXJuICEoJ2dldCcgaW4gZGVzYykgJiZcbiAgICAgICAgICEoJ3NldCcgaW4gZGVzYykgJiZcbiAgICAgICAgICEoJ3ZhbHVlJyBpbiBkZXNjKSAmJlxuICAgICAgICAgISgnd3JpdGFibGUnIGluIGRlc2MpICYmXG4gICAgICAgICAhKCdlbnVtZXJhYmxlJyBpbiBkZXNjKSAmJlxuICAgICAgICAgISgnY29uZmlndXJhYmxlJyBpbiBkZXNjKTtcbn1cblxuZnVuY3Rpb24gaXNFcXVpdmFsZW50RGVzY3JpcHRvcihkZXNjMSwgZGVzYzIpIHtcbiAgcmV0dXJuIHNhbWVWYWx1ZShkZXNjMS5nZXQsIGRlc2MyLmdldCkgJiZcbiAgICAgICAgIHNhbWVWYWx1ZShkZXNjMS5zZXQsIGRlc2MyLnNldCkgJiZcbiAgICAgICAgIHNhbWVWYWx1ZShkZXNjMS52YWx1ZSwgZGVzYzIudmFsdWUpICYmXG4gICAgICAgICBzYW1lVmFsdWUoZGVzYzEud3JpdGFibGUsIGRlc2MyLndyaXRhYmxlKSAmJlxuICAgICAgICAgc2FtZVZhbHVlKGRlc2MxLmVudW1lcmFibGUsIGRlc2MyLmVudW1lcmFibGUpICYmXG4gICAgICAgICBzYW1lVmFsdWUoZGVzYzEuY29uZmlndXJhYmxlLCBkZXNjMi5jb25maWd1cmFibGUpO1xufVxuXG4vLyBjb3BpZWQgZnJvbSBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWxcbmZ1bmN0aW9uIHNhbWVWYWx1ZSh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gMCA9PT0gLTAsIGJ1dCB0aGV5IGFyZSBub3QgaWRlbnRpY2FsXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9XG5cbiAgLy8gTmFOICE9PSBOYU4sIGJ1dCB0aGV5IGFyZSBpZGVudGljYWwuXG4gIC8vIE5hTnMgYXJlIHRoZSBvbmx5IG5vbi1yZWZsZXhpdmUgdmFsdWUsIGkuZS4sIGlmIHggIT09IHgsXG4gIC8vIHRoZW4geCBpcyBhIE5hTi5cbiAgLy8gaXNOYU4gaXMgYnJva2VuOiBpdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gbnVtYmVyLCBzb1xuICAvLyBpc05hTihcImZvb1wiKSA9PiB0cnVlXG4gIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZyZXNoIHByb3BlcnR5IGRlc2NyaXB0b3IgdGhhdCBpcyBndWFyYW50ZWVkXG4gKiB0byBiZSBjb21wbGV0ZSAoaS5lLiBjb250YWluIGFsbCB0aGUgc3RhbmRhcmQgYXR0cmlidXRlcykuXG4gKiBBZGRpdGlvbmFsbHksIGFueSBub24tc3RhbmRhcmQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mXG4gKiBhdHRyaWJ1dGVzIGFyZSBjb3BpZWQgb3ZlciB0byB0aGUgZnJlc2ggZGVzY3JpcHRvci5cbiAqXG4gKiBJZiBhdHRyaWJ1dGVzIGlzIHVuZGVmaW5lZCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogU2VlIGFsc286IGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6cHJveGllc19zZW1hbnRpY3NcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQW5kQ29tcGxldGVQcm9wZXJ0eURlc2NyaXB0b3IoYXR0cmlidXRlcykge1xuICBpZiAoYXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgdmFyIGRlc2MgPSB0b0NvbXBsZXRlUHJvcGVydHlEZXNjcmlwdG9yKGF0dHJpYnV0ZXMpO1xuICAvLyBOb3RlOiBubyBuZWVkIHRvIGNhbGwgRnJvbVByb3BlcnR5RGVzY3JpcHRvcihkZXNjKSwgYXMgd2UgcmVwcmVzZW50XG4gIC8vIFwiaW50ZXJuYWxcIiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBhcyBwcm9wZXIgT2JqZWN0cyBmcm9tIHRoZSBzdGFydFxuICBmb3IgKHZhciBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIWlzU3RhbmRhcmRBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXNjLCBuYW1lLFxuICAgICAgICB7IHZhbHVlOiBhdHRyaWJ1dGVzW25hbWVdLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzYztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnJlc2ggcHJvcGVydHkgZGVzY3JpcHRvciB3aG9zZSBzdGFuZGFyZFxuICogYXR0cmlidXRlcyBhcmUgZ3VhcmFudGVlZCB0byBiZSBkYXRhIHByb3BlcnRpZXMgb2YgdGhlIHJpZ2h0IHR5cGUuXG4gKiBBZGRpdGlvbmFsbHksIGFueSBub24tc3RhbmRhcmQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mXG4gKiBhdHRyaWJ1dGVzIGFyZSBjb3BpZWQgb3ZlciB0byB0aGUgZnJlc2ggZGVzY3JpcHRvci5cbiAqXG4gKiBJZiBhdHRyaWJ1dGVzIGlzIHVuZGVmaW5lZCwgd2lsbCB0aHJvdyBhIFR5cGVFcnJvci5cbiAqXG4gKiBTZWUgYWxzbzogaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpwcm94aWVzX3NlbWFudGljc1xuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eURlc2NyaXB0b3IoYXR0cmlidXRlcykge1xuICB2YXIgZGVzYyA9IHRvUHJvcGVydHlEZXNjcmlwdG9yKGF0dHJpYnV0ZXMpO1xuICAvLyBOb3RlOiBubyBuZWVkIHRvIGNhbGwgRnJvbUdlbmVyaWNQcm9wZXJ0eURlc2NyaXB0b3IoZGVzYyksIGFzIHdlIHJlcHJlc2VudFxuICAvLyBcImludGVybmFsXCIgcHJvcGVydHkgZGVzY3JpcHRvcnMgYXMgcHJvcGVyIE9iamVjdHMgZnJvbSB0aGUgc3RhcnRcbiAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCFpc1N0YW5kYXJkQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzYywgbmFtZSxcbiAgICAgICAgeyB2YWx1ZTogYXR0cmlidXRlc1tuYW1lXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc2M7XG59XG5cbi8vIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSByZWFsIEVTNSBwcmltaXRpdmVzIGJlZm9yZSBwYXRjaGluZyB0aGVtIGxhdGVyXG52YXIgcHJpbV9wcmV2ZW50RXh0ZW5zaW9ucyA9ICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMsXG4gICAgcHJpbV9zZWFsID0gICAgICAgICAgICAgICAgICAgICBPYmplY3Quc2VhbCxcbiAgICBwcmltX2ZyZWV6ZSA9ICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUsXG4gICAgcHJpbV9pc0V4dGVuc2libGUgPSAgICAgICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlLFxuICAgIHByaW1faXNTZWFsZWQgPSAgICAgICAgICAgICAgICAgT2JqZWN0LmlzU2VhbGVkLFxuICAgIHByaW1faXNGcm96ZW4gPSAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRnJvemVuLFxuICAgIHByaW1fZ2V0UHJvdG90eXBlT2YgPSAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIHByaW1fZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICBwcmltX2RlZmluZVByb3BlcnR5ID0gICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICBwcmltX2RlZmluZVByb3BlcnRpZXMgPSAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICAgIHByaW1fa2V5cyA9ICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMsXG4gICAgcHJpbV9nZXRPd25Qcm9wZXJ0eU5hbWVzID0gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICBwcmltX2dldE93blByb3BlcnR5U3ltYm9scyA9ICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgcHJpbV9hc3NpZ24gPSAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduLFxuICAgIHByaW1faXNBcnJheSA9ICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSxcbiAgICBwcmltX2NvbmNhdCA9ICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5jb25jYXQsXG4gICAgcHJpbV9pc1Byb3RvdHlwZU9mID0gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YsXG4gICAgcHJpbV9oYXNPd25Qcm9wZXJ0eSA9ICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyB0aGVzZSB3aWxsIHBvaW50IHRvIHRoZSBwYXRjaGVkIHZlcnNpb25zIG9mIHRoZSByZXNwZWN0aXZlIG1ldGhvZHMgb25cbi8vIE9iamVjdC4gVGhleSBhcmUgdXNlZCB3aXRoaW4gdGhpcyBtb2R1bGUgYXMgdGhlIFwiaW50cmluc2ljXCIgYmluZGluZ3Ncbi8vIG9mIHRoZXNlIG1ldGhvZHMgKGkuZS4gdGhlIFwib3JpZ2luYWxcIiBiaW5kaW5ncyBhcyBkZWZpbmVkIGluIHRoZSBzcGVjKVxudmFyIE9iamVjdF9pc0Zyb3plbixcbiAgICBPYmplY3RfaXNTZWFsZWQsXG4gICAgT2JqZWN0X2lzRXh0ZW5zaWJsZSxcbiAgICBPYmplY3RfZ2V0UHJvdG90eXBlT2YsXG4gICAgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXM7XG5cbi8qKlxuICogQSBwcm9wZXJ0eSAnbmFtZScgaXMgZml4ZWQgaWYgaXQgaXMgYW4gb3duIHByb3BlcnR5IG9mIHRoZSB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQobmFtZSwgdGFyZ2V0KSB7XG4gIHJldHVybiAoe30pLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGlzU2VhbGVkKG5hbWUsIHRhcmdldCkge1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIGRlc2MuY29uZmlndXJhYmxlID09PSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2VhbGVkRGVzYyhkZXNjKSB7XG4gIHJldHVybiBkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5jb25maWd1cmFibGUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFsbCB2YWxpZGF0aW9uIHRoYXQgT2JqZWN0LmRlZmluZVByb3BlcnR5IHBlcmZvcm1zLFxuICogd2l0aG91dCBhY3R1YWxseSBkZWZpbmluZyB0aGUgcHJvcGVydHkuIFJldHVybnMgYSBib29sZWFuXG4gKiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsaWRhdGlvbiBzdWNjZWVkZWQuXG4gKlxuICogSW1wbGVtZW50YXRpb24gdHJhbnNsaXRlcmF0ZWQgZnJvbSBFUzUuMSBzZWN0aW9uIDguMTIuOVxuICovXG5mdW5jdGlvbiBpc0NvbXBhdGlibGVEZXNjcmlwdG9yKGV4dGVuc2libGUsIGN1cnJlbnQsIGRlc2MpIHtcbiAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkICYmIGV4dGVuc2libGUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNFbXB0eURlc2NyaXB0b3IoZGVzYykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNFcXVpdmFsZW50RGVzY3JpcHRvcihjdXJyZW50LCBkZXNjKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICBpZiAoZGVzYy5jb25maWd1cmFibGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCdlbnVtZXJhYmxlJyBpbiBkZXNjICYmIGRlc2MuZW51bWVyYWJsZSAhPT0gY3VycmVudC5lbnVtZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0dlbmVyaWNEZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzRGF0YURlc2NyaXB0b3IoY3VycmVudCkgIT09IGlzRGF0YURlc2NyaXB0b3IoZGVzYykpIHtcbiAgICBpZiAoY3VycmVudC5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0RhdGFEZXNjcmlwdG9yKGN1cnJlbnQpICYmIGlzRGF0YURlc2NyaXB0b3IoZGVzYykpIHtcbiAgICBpZiAoY3VycmVudC5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICBpZiAoY3VycmVudC53cml0YWJsZSA9PT0gZmFsc2UgJiYgZGVzYy53cml0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYyAmJiAhc2FtZVZhbHVlKGRlc2MudmFsdWUsIGN1cnJlbnQudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FjY2Vzc29yRGVzY3JpcHRvcihjdXJyZW50KSAmJiBpc0FjY2Vzc29yRGVzY3JpcHRvcihkZXNjKSkge1xuICAgIGlmIChjdXJyZW50LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmICgnc2V0JyBpbiBkZXNjICYmICFzYW1lVmFsdWUoZGVzYy5zZXQsIGN1cnJlbnQuc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoJ2dldCcgaW4gZGVzYyAmJiAhc2FtZVZhbHVlKGRlc2MuZ2V0LCBjdXJyZW50LmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gRVM2IDcuMy4xMSBTZXRJbnRlZ3JpdHlMZXZlbFxuLy8gbGV2ZWwgaXMgb25lIG9mIFwic2VhbGVkXCIgb3IgXCJmcm96ZW5cIlxuZnVuY3Rpb24gc2V0SW50ZWdyaXR5TGV2ZWwodGFyZ2V0LCBsZXZlbCkge1xuICB2YXIgb3duUHJvcHMgPSBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB2YXIgcGVuZGluZ0V4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgaWYgKGxldmVsID09PSBcInNlYWxlZFwiKSB7XG4gICAgdmFyIGwgPSArb3duUHJvcHMubGVuZ3RoO1xuICAgIHZhciBrO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrID0gU3RyaW5nKG93blByb3BzW2ldKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGssIHsgY29uZmlndXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdFeGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBlbmRpbmdFeGNlcHRpb24gPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGxldmVsID09PSBcImZyb3plblwiXG4gICAgdmFyIGwgPSArb3duUHJvcHMubGVuZ3RoO1xuICAgIHZhciBrO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrID0gU3RyaW5nKG93blByb3BzW2ldKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjdXJyZW50RGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrKTtcbiAgICAgICAgaWYgKGN1cnJlbnREZXNjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGVzYztcbiAgICAgICAgICBpZiAoaXNBY2Nlc3NvckRlc2NyaXB0b3IoY3VycmVudERlc2MpKSB7XG4gICAgICAgICAgICBkZXNjID0geyBjb25maWd1cmFibGU6IGZhbHNlIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzYyA9IHsgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgaywgZGVzYyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAocGVuZGluZ0V4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGVuZGluZ0V4Y2VwdGlvbiA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBlbmRpbmdFeGNlcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IHBlbmRpbmdFeGNlcHRpb247XG4gIH1cbiAgcmV0dXJuIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbn1cblxuLy8gRVM2IDcuMy4xMiBUZXN0SW50ZWdyaXR5TGV2ZWxcbi8vIGxldmVsIGlzIG9uZSBvZiBcInNlYWxlZFwiIG9yIFwiZnJvemVuXCJcbmZ1bmN0aW9uIHRlc3RJbnRlZ3JpdHlMZXZlbCh0YXJnZXQsIGxldmVsKSB7XG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3RfaXNFeHRlbnNpYmxlKHRhcmdldCk7XG4gIGlmIChpc0V4dGVuc2libGUpIHJldHVybiBmYWxzZTtcbiAgXG4gIHZhciBvd25Qcm9wcyA9IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIHZhciBwZW5kaW5nRXhjZXB0aW9uID0gdW5kZWZpbmVkO1xuICB2YXIgY29uZmlndXJhYmxlID0gZmFsc2U7XG4gIHZhciB3cml0YWJsZSA9IGZhbHNlO1xuICBcbiAgdmFyIGwgPSArb3duUHJvcHMubGVuZ3RoO1xuICB2YXIgaztcbiAgdmFyIGN1cnJlbnREZXNjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGsgPSBTdHJpbmcob3duUHJvcHNbaV0pO1xuICAgIHRyeSB7XG4gICAgICBjdXJyZW50RGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrKTtcbiAgICAgIGNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZSB8fCBjdXJyZW50RGVzYy5jb25maWd1cmFibGU7XG4gICAgICBpZiAoaXNEYXRhRGVzY3JpcHRvcihjdXJyZW50RGVzYykpIHtcbiAgICAgICAgd3JpdGFibGUgPSB3cml0YWJsZSB8fCBjdXJyZW50RGVzYy53cml0YWJsZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAocGVuZGluZ0V4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBlbmRpbmdFeGNlcHRpb24gPSBlO1xuICAgICAgICBjb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGVuZGluZ0V4Y2VwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgcGVuZGluZ0V4Y2VwdGlvbjtcbiAgfVxuICBpZiAobGV2ZWwgPT09IFwiZnJvemVuXCIgJiYgd3JpdGFibGUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbmZpZ3VyYWJsZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gLS0tLSBUaGUgVmFsaWRhdG9yIGhhbmRsZXIgd3JhcHBlciBhcm91bmQgdXNlciBoYW5kbGVycyAtLS0tXG5cbi8qKlxuICogQHBhcmFtIHRhcmdldCB0aGUgb2JqZWN0IHdyYXBwZWQgYnkgdGhpcyBwcm94eS5cbiAqIEFzIGxvbmcgYXMgdGhlIHByb3h5IGlzIGV4dGVuc2libGUsIG9ubHkgbm9uLWNvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzXG4gKiBhcmUgY2hlY2tlZCBhZ2FpbnN0IHRoZSB0YXJnZXQuIE9uY2UgdGhlIHByb3h5IGJlY29tZXMgbm9uLWV4dGVuc2libGUsXG4gKiBpbnZhcmlhbnRzIHcuci50LiBub24tZXh0ZW5zaWJpbGl0eSBhcmUgYWxzbyBlbmZvcmNlZC5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlciB0aGUgaGFuZGxlciBvZiB0aGUgZGlyZWN0IHByb3h5LiBUaGUgb2JqZWN0IGVtdWxhdGVkIGJ5XG4gKiB0aGlzIGhhbmRsZXIgaXMgdmFsaWRhdGVkIGFnYWluc3QgdGhlIHRhcmdldCBvYmplY3Qgb2YgdGhlIGRpcmVjdCBwcm94eS5cbiAqIEFueSB2aW9sYXRpb25zIHRoYXQgdGhlIGhhbmRsZXIgbWFrZXMgYWdhaW5zdCB0aGUgaW52YXJpYW50c1xuICogb2YgdGhlIHRhcmdldCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yIHRvIGJlIHRocm93bi5cbiAqXG4gKiBCb3RoIHRhcmdldCBhbmQgaGFuZGxlciBtdXN0IGJlIHByb3BlciBPYmplY3RzIGF0IGluaXRpYWxpemF0aW9uIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIFZhbGlkYXRvcih0YXJnZXQsIGhhbmRsZXIpIHtcbiAgLy8gZm9yIG5vbi1yZXZva2FibGUgcHJveGllcywgdGhlc2UgYXJlIGNvbnN0IHJlZmVyZW5jZXNcbiAgLy8gZm9yIHJldm9rYWJsZSBwcm94aWVzLCBvbiByZXZvY2F0aW9uOlxuICAvLyAtIHRoaXMudGFyZ2V0IGlzIHNldCB0byBudWxsXG4gIC8vIC0gdGhpcy5oYW5kbGVyIGlzIHNldCB0byBhIGhhbmRsZXIgdGhhdCB0aHJvd3Mgb24gYWxsIHRyYXBzXG4gIHRoaXMudGFyZ2V0ICA9IHRhcmdldDtcbiAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbn1cblxuVmFsaWRhdG9yLnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogSWYgZ2V0VHJhcCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGNhbGxlciBzaG91bGQgcGVyZm9ybSB0aGVcbiAgICogZGVmYXVsdCBmb3J3YXJkaW5nIGJlaGF2aW9yLlxuICAgKiBJZiBnZXRUcmFwIHJldHVybnMgbm9ybWFsbHkgb3RoZXJ3aXNlLCB0aGUgcmV0dXJuIHZhbHVlXG4gICAqIHdpbGwgYmUgYSBjYWxsYWJsZSB0cmFwIGZ1bmN0aW9uLiBXaGVuIGNhbGxpbmcgdGhlIHRyYXAgZnVuY3Rpb24sXG4gICAqIHRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGJpbmRpbmcgaXRzIHx0aGlzfCB0byB8dGhpcy5oYW5kbGVyfC5cbiAgICovXG4gIGdldFRyYXA6IGZ1bmN0aW9uKHRyYXBOYW1lKSB7XG4gICAgdmFyIHRyYXAgPSB0aGlzLmhhbmRsZXJbdHJhcE5hbWVdO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoZSB0cmFwIHdhcyBub3QgZGVmaW5lZCxcbiAgICAgIC8vIHBlcmZvcm0gdGhlIGRlZmF1bHQgZm9yd2FyZGluZyBiZWhhdmlvclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYXAgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0cmFwTmFtZSArIFwiIHRyYXAgaXMgbm90IGNhbGxhYmxlOiBcIit0cmFwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfSxcblxuICAvLyA9PT0gZnVuZGFtZW50YWwgdHJhcHMgPT09XG5cbiAgLyoqXG4gICAqIElmIG5hbWUgZGVub3RlcyBhIGZpeGVkIHByb3BlcnR5LCBjaGVjazpcbiAgICogICAtIHdoZXRoZXIgdGFyZ2V0SGFuZGxlciByZXBvcnRzIGl0IGFzIGV4aXN0ZW50XG4gICAqICAgLSB3aGV0aGVyIHRoZSByZXR1cm5lZCBkZXNjcmlwdG9yIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgZml4ZWQgcHJvcGVydHlcbiAgICogSWYgdGhlIHByb3h5IGlzIG5vbi1leHRlbnNpYmxlLCBjaGVjazpcbiAgICogICAtIHdoZXRoZXIgbmFtZSBpcyBub3QgYSBuZXcgcHJvcGVydHlcbiAgICogQWRkaXRpb25hbGx5LCB0aGUgcmV0dXJuZWQgZGVzY3JpcHRvciBpcyBub3JtYWxpemVkIGFuZCBjb21wbGV0ZWQuXG4gICAqL1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIpO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLnRhcmdldCwgbmFtZSk7XG4gICAgfVxuXG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB2YXIgZGVzYyA9IHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRoaXMudGFyZ2V0LCBuYW1lKTtcbiAgICBkZXNjID0gbm9ybWFsaXplQW5kQ29tcGxldGVQcm9wZXJ0eURlc2NyaXB0b3IoZGVzYyk7XG5cbiAgICB2YXIgdGFyZ2V0RGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy50YXJnZXQsIG5hbWUpO1xuICAgIHZhciBleHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSh0aGlzLnRhcmdldCk7XG5cbiAgICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaXNTZWFsZWREZXNjKHRhcmdldERlc2MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgcmVwb3J0IG5vbi1jb25maWd1cmFibGUgcHJvcGVydHkgJ1wiK25hbWUrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInIGFzIG5vbi1leGlzdGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZXh0ZW5zaWJsZSAmJiB0YXJnZXREZXNjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBpZiBoYW5kbGVyIGlzIGFsbG93ZWQgdG8gcmV0dXJuIHVuZGVmaW5lZCwgd2UgY2Fubm90IGd1YXJhbnRlZVxuICAgICAgICAgIC8vIHRoYXQgaXQgd2lsbCBub3QgcmV0dXJuIGEgZGVzY3JpcHRvciBmb3IgdGhpcyBwcm9wZXJ0eSBsYXRlci5cbiAgICAgICAgICAvLyBPbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gcmVwb3J0ZWQgYXMgbm9uLWV4aXN0ZW50IG9uIGEgbm9uLWV4dGVuc2libGVcbiAgICAgICAgICAvLyBvYmplY3QsIGl0IHNob3VsZCBmb3JldmVyIGJlIHJlcG9ydGVkIGFzIG5vbi1leGlzdGVudFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgcmVwb3J0IGV4aXN0aW5nIG93biBwcm9wZXJ0eSAnXCIrbmFtZStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJyBhcyBub24tZXhpc3RlbnQgb24gYSBub24tZXh0ZW5zaWJsZSBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGtub3cgKGRlc2MgIT09IHVuZGVmaW5lZCksIGkuZS5cbiAgICAvLyB0YXJnZXRIYW5kbGVyIHJlcG9ydHMgJ25hbWUnIGFzIGFuIGV4aXN0aW5nIHByb3BlcnR5XG5cbiAgICAvLyBOb3RlOiB3ZSBjb3VsZCBjb2xsYXBzZSB0aGUgZm9sbG93aW5nIHR3byBpZi10ZXN0cyBpbnRvIGEgc2luZ2xlXG4gICAgLy8gdGVzdC4gU2VwYXJhdGluZyBvdXQgdGhlIGNhc2VzIHRvIGltcHJvdmUgZXJyb3IgcmVwb3J0aW5nLlxuXG4gICAgaWYgKCFleHRlbnNpYmxlKSB7XG4gICAgICBpZiAodGFyZ2V0RGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgcmVwb3J0IGEgbmV3IG93biBwcm9wZXJ0eSAnXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArIFwiJyBvbiBhIG5vbi1leHRlbnNpYmxlIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIWlzQ29tcGF0aWJsZURlc2NyaXB0b3IoZXh0ZW5zaWJsZSwgdGFyZ2V0RGVzYywgZGVzYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCByZXBvcnQgaW5jb21wYXRpYmxlIHByb3BlcnR5IGRlc2NyaXB0b3IgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3IgcHJvcGVydHkgJ1wiK25hbWUrXCInXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoZGVzYy5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICBpZiAodGFyZ2V0RGVzYyA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldERlc2MuY29uZmlndXJhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBjb25maWd1cmFibGUgb3Igbm9uLWV4aXN0ZW50IG9uIHRoZSB0YXJnZXQsXG4gICAgICAgIC8vIGJ1dCBpcyByZXBvcnRlZCBhcyBhIG5vbi1jb25maWd1cmFibGUgcHJvcGVydHksIGl0IG1heSBsYXRlciBiZVxuICAgICAgICAvLyByZXBvcnRlZCBhcyBjb25maWd1cmFibGUgb3Igbm9uLWV4aXN0ZW50LCB3aGljaCB2aW9sYXRlcyB0aGVcbiAgICAgICAgLy8gaW52YXJpYW50IHRoYXQgaWYgdGhlIHByb3BlcnR5IG1pZ2h0IGNoYW5nZSBvciBkaXNhcHBlYXIsIHRoZVxuICAgICAgICAvLyBjb25maWd1cmFibGUgYXR0cmlidXRlIG11c3QgYmUgdHJ1ZS5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcImNhbm5vdCByZXBvcnQgYSBub24tY29uZmlndXJhYmxlIGRlc2NyaXB0b3IgXCIgK1xuICAgICAgICAgIFwiZm9yIGNvbmZpZ3VyYWJsZSBvciBub24tZXhpc3RlbnQgcHJvcGVydHkgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd3JpdGFibGUnIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRhcmdldERlc2Mud3JpdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaXMgbm9uLWNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgb24gdGhlIHRhcmdldCxcbiAgICAgICAgICAvLyBidXQgaXMgcmVwb3J0ZWQgYXMgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlLCBpdCBtYXkgbGF0ZXJcbiAgICAgICAgICAvLyBiZSByZXBvcnRlZCBhcyBub24tY29uZmlndXJhYmxlLCB3cml0YWJsZSBhZ2Fpbiwgd2hpY2ggdmlvbGF0ZXNcbiAgICAgICAgICAvLyB0aGUgaW52YXJpYW50IHRoYXQgYSBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcbiAgICAgICAgICAvLyBtYXkgbm90IGNoYW5nZSBzdGF0ZS5cbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCJjYW5ub3QgcmVwb3J0IG5vbi1jb25maWd1cmFibGUsIHdyaXRhYmxlIHByb3BlcnR5ICdcIiArIG5hbWUgK1xuICAgICAgICAgICAgXCInIGFzIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbiB0aGUgZGlyZWN0IHByb3hpZXMgZGVzaWduIHdpdGggcmVmYWN0b3JlZCBwcm90b3R5cGUgY2xpbWJpbmcsXG4gICAqIHRoaXMgdHJhcCBpcyBkZXByZWNhdGVkLiBGb3IgcHJveGllcy1hcy1wcm90b3R5cGVzLCBpbnN0ZWFkXG4gICAqIG9mIGNhbGxpbmcgdGhpcyB0cmFwLCB0aGUgZ2V0LCBzZXQsIGhhcyBvciBlbnVtZXJhdGUgdHJhcHMgYXJlXG4gICAqIGNhbGxlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBJbiB0aGlzIGltcGxlbWVudGF0aW9uLCB3ZSBcImFidXNlXCIgZ2V0UHJvcGVydHlEZXNjcmlwdG9yIHRvXG4gICAqIHN1cHBvcnQgdHJhcHBpbmcgdGhlIGdldCBvciBzZXQgdHJhcHMgZm9yIHByb3hpZXMtYXMtcHJvdG90eXBlcy5cbiAgICogV2UgZG8gdGhpcyBieSByZXR1cm5pbmcgYSBnZXR0ZXIvc2V0dGVyIHBhaXIgdGhhdCBpbnZva2VzXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIHRyYXBzLlxuICAgKlxuICAgKiBXaGlsZSB0aGlzIGhhY2sgd29ya3MgZm9yIGluaGVyaXRlZCBwcm9wZXJ0eSBhY2Nlc3MsIGl0IGhhcyBzb21lXG4gICAqIHF1aXJrczpcbiAgICpcbiAgICogSW4gRmlyZWZveCwgdGhpcyB0cmFwIGlzIG9ubHkgY2FsbGVkIGFmdGVyIGEgcHJpb3IgaW52b2NhdGlvblxuICAgKiBvZiB0aGUgJ2hhcycgdHJhcCBoYXMgcmV0dXJuZWQgdHJ1ZS4gSGVuY2UsIGV4cGVjdCB0aGUgZm9sbG93aW5nXG4gICAqIGJlaGF2aW9yOlxuICAgKiA8Y29kZT5cbiAgICogdmFyIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShQcm94eSh0YXJnZXQsIGhhbmRsZXIpKTtcbiAgICogY2hpbGRbbmFtZV0gLy8gdHJpZ2dlcnMgaGFuZGxlci5oYXModGFyZ2V0LCBuYW1lKVxuICAgKiAvLyBpZiB0aGF0IHJldHVybnMgdHJ1ZSwgdHJpZ2dlcnMgaGFuZGxlci5nZXQodGFyZ2V0LCBuYW1lLCBjaGlsZClcbiAgICogPC9jb2RlPlxuICAgKlxuICAgKiBPbiB2OCwgdGhlICdpbicgb3BlcmF0b3IsIHdoZW4gYXBwbGllZCB0byBhbiBvYmplY3QgdGhhdCBpbmhlcml0c1xuICAgKiBmcm9tIGEgcHJveHksIHdpbGwgY2FsbCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgYW5kIHdhbGsgdGhlIHByb3RvLWNoYWluLlxuICAgKiBUaGF0IGNhbGxzIHRoZSBiZWxvdyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgdHJhcCBvbiB0aGUgcHJveHkuIFRoZVxuICAgKiByZXN1bHQgb2YgdGhlICdpbictb3BlcmF0b3IgaXMgdGhlbiBkZXRlcm1pbmVkIGJ5IHdoZXRoZXIgdGhpcyB0cmFwXG4gICAqIHJldHVybnMgdW5kZWZpbmVkIG9yIGEgcHJvcGVydHkgZGVzY3JpcHRvciBvYmplY3QuIFRoYXQgaXMgd2h5XG4gICAqIHdlIGZpcnN0IGV4cGxpY2l0bHkgdHJpZ2dlciB0aGUgJ2hhcycgdHJhcCB0byBkZXRlcm1pbmUgd2hldGhlclxuICAgKiB0aGUgcHJvcGVydHkgZXhpc3RzLlxuICAgKlxuICAgKiBUaGlzIGhhcyB0aGUgc2lkZS1lZmZlY3QgdGhhdCB3aGVuIGVudW1lcmF0aW5nIHByb3BlcnRpZXMgb25cbiAgICogYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhIHByb3h5IGluIHY4LCBvbmx5IHByb3BlcnRpZXNcbiAgICogZm9yIHdoaWNoICdoYXMnIHJldHVybnMgdHJ1ZSBhcmUgcmV0dXJuZWQ6XG4gICAqXG4gICAqIDxjb2RlPlxuICAgKiB2YXIgY2hpbGQgPSBPYmplY3QuY3JlYXRlKFByb3h5KHRhcmdldCwgaGFuZGxlcikpO1xuICAgKiBmb3IgKHZhciBwcm9wIGluIGNoaWxkKSB7XG4gICAqICAgLy8gb25seSBlbnVtZXJhdGVzIHByb3AgaWYgKHByb3AgaW4gY2hpbGQpIHJldHVybnMgdHJ1ZVxuICAgKiB9XG4gICAqIDwvY29kZT5cbiAgICovXG4gIGdldFByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoYW5kbGVyID0gdGhpcztcblxuICAgIGlmICghaGFuZGxlci5oYXMobmFtZSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0KHRoaXMsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnNldCh0aGlzLCBuYW1lLCB2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZmFpbGVkIGFzc2lnbm1lbnQgdG8gXCIrbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgbmFtZSBkZW5vdGVzIGEgZml4ZWQgcHJvcGVydHksIGNoZWNrIGZvciBpbmNvbXBhdGlibGUgY2hhbmdlcy5cbiAgICogSWYgdGhlIHByb3h5IGlzIG5vbi1leHRlbnNpYmxlLCBjaGVjayB0aGF0IG5ldyBwcm9wZXJ0aWVzIGFyZSByZWplY3RlZC5cbiAgICovXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCBkZXNjKSB7XG4gICAgLy8gVE9ETyh0dmN1dHNlbSk6IHRoZSBjdXJyZW50IHRyYWNlbW9ua2V5IGltcGxlbWVudGF0aW9uIG9mIHByb3hpZXNcbiAgICAvLyBhdXRvLWNvbXBsZXRlcyAnZGVzYycsIHdoaWNoIGlzIG5vdCBjb3JyZWN0LiAnZGVzYycgc2hvdWxkIGJlXG4gICAgLy8gbm9ybWFsaXplZCwgYnV0IG5vdCBjb21wbGV0ZWQuIENvbnNpZGVyOlxuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ2ZvbycsIHtlbnVtZXJhYmxlOmZhbHNlfSlcbiAgICAvLyBUaGlzIHRyYXAgd2lsbCByZWNlaXZlIGRlc2MgPVxuICAgIC8vICB7dmFsdWU6dW5kZWZpbmVkLHdyaXRhYmxlOmZhbHNlLGVudW1lcmFibGU6ZmFsc2UsY29uZmlndXJhYmxlOmZhbHNlfVxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIHNldCBhbGwgb3RoZXIgYXR0cmlidXRlcyB0byB0aGVpciBkZWZhdWx0IHZhbHVlLFxuICAgIC8vIHdoaWNoIGlzIHVuZXhwZWN0ZWQgYW5kIGRpZmZlcmVudCBmcm9tIFtbRGVmaW5lT3duUHJvcGVydHldXS5cbiAgICAvLyBCdWcgZmlsZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYwMTMyOVxuXG4gICAgdmFyIHRyYXAgPSB0aGlzLmdldFRyYXAoXCJkZWZpbmVQcm9wZXJ0eVwiKTtcbiAgICBpZiAodHJhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkZWZhdWx0IGZvcndhcmRpbmcgYmVoYXZpb3JcbiAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0LCBuYW1lLCBkZXNjKTtcbiAgICB9XG5cbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIHZhciBkZXNjT2JqID0gbm9ybWFsaXplUHJvcGVydHlEZXNjcmlwdG9yKGRlc2MpO1xuICAgIHZhciBzdWNjZXNzID0gdHJhcC5jYWxsKHRoaXMuaGFuZGxlciwgdGhpcy50YXJnZXQsIG5hbWUsIGRlc2NPYmopO1xuICAgIHN1Y2Nlc3MgPSAhIXN1Y2Nlc3M7IC8vIGNvZXJjZSB0byBCb29sZWFuXG5cbiAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSkge1xuXG4gICAgICB2YXIgdGFyZ2V0RGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy50YXJnZXQsIG5hbWUpO1xuICAgICAgdmFyIGV4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlKHRoaXMudGFyZ2V0KTtcblxuICAgICAgLy8gTm90ZTogd2UgY291bGQgY29sbGFwc2UgdGhlIGZvbGxvd2luZyB0d28gaWYtdGVzdHMgaW50byBhIHNpbmdsZVxuICAgICAgLy8gdGVzdC4gU2VwYXJhdGluZyBvdXQgdGhlIGNhc2VzIHRvIGltcHJvdmUgZXJyb3IgcmVwb3J0aW5nLlxuXG4gICAgICBpZiAoIWV4dGVuc2libGUpIHtcbiAgICAgICAgaWYgKHRhcmdldERlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3Qgc3VjY2Vzc2Z1bGx5IGFkZCBhIG5ldyBwcm9wZXJ0eSAnXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICsgXCInIHRvIGEgbm9uLWV4dGVuc2libGUgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXREZXNjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc0NvbXBhdGlibGVEZXNjcmlwdG9yKGV4dGVuc2libGUsIHRhcmdldERlc2MsIGRlc2MpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBkZWZpbmUgaW5jb21wYXRpYmxlIHByb3BlcnR5IFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdG9yIGZvciBwcm9wZXJ0eSAnXCIrbmFtZStcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0YURlc2NyaXB0b3IodGFyZ2V0RGVzYykgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MuY29uZmlndXJhYmxlID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdGFyZ2V0RGVzYy53cml0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlID09PSBmYWxzZSAmJiBkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaXMgbm9uLWNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgb24gdGhlIHRhcmdldFxuICAgICAgICAgICAgICAvLyBidXQgd2FzIHN1Y2Nlc3NmdWxseSByZXBvcnRlZCB0byBiZSB1cGRhdGVkIHRvXG4gICAgICAgICAgICAgIC8vIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZSwgaXQgY2FuIGxhdGVyIGJlIHJlcG9ydGVkXG4gICAgICAgICAgICAgIC8vIGFnYWluIGFzIG5vbi1jb25maWd1cmFibGUsIHdyaXRhYmxlLCB3aGljaCB2aW9sYXRlc1xuICAgICAgICAgICAgICAvLyB0aGUgaW52YXJpYW50IHRoYXQgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgLy8gY2Fubm90IGNoYW5nZSBzdGF0ZVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiY2Fubm90IHN1Y2Nlc3NmdWxseSBkZWZpbmUgbm9uLWNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgXCIgK1xuICAgICAgICAgICAgICAgIFwiIHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgYXMgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlID09PSBmYWxzZSAmJiAhaXNTZWFsZWREZXNjKHRhcmdldERlc2MpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBjb25maWd1cmFibGUgb3Igbm9uLWV4aXN0ZW50IG9uIHRoZSB0YXJnZXQsXG4gICAgICAgIC8vIGJ1dCBpcyBzdWNjZXNzZnVsbHkgYmVpbmcgcmVkZWZpbmVkIGFzIGEgbm9uLWNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSxcbiAgICAgICAgLy8gaXQgbWF5IGxhdGVyIGJlIHJlcG9ydGVkIGFzIGNvbmZpZ3VyYWJsZSBvciBub24tZXhpc3RlbnQsIHdoaWNoIHZpb2xhdGVzXG4gICAgICAgIC8vIHRoZSBpbnZhcmlhbnQgdGhhdCBpZiB0aGUgcHJvcGVydHkgbWlnaHQgY2hhbmdlIG9yIGRpc2FwcGVhciwgdGhlXG4gICAgICAgIC8vIGNvbmZpZ3VyYWJsZSBhdHRyaWJ1dGUgbXVzdCBiZSB0cnVlLlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiY2Fubm90IHN1Y2Nlc3NmdWxseSBkZWZpbmUgYSBub24tY29uZmlndXJhYmxlIFwiICtcbiAgICAgICAgICBcImRlc2NyaXB0b3IgZm9yIGNvbmZpZ3VyYWJsZSBvciBub24tZXhpc3RlbnQgcHJvcGVydHkgJ1wiICtcbiAgICAgICAgICBuYW1lICsgXCInXCIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9uIHN1Y2Nlc3MsIGNoZWNrIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3QgaXMgaW5kZWVkIG5vbi1leHRlbnNpYmxlLlxuICAgKi9cbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwicHJldmVudEV4dGVuc2lvbnNcIik7XG4gICAgaWYgKHRyYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZGVmYXVsdCBmb3J3YXJkaW5nIGJlaGF2aW9yXG4gICAgICByZXR1cm4gUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzLnRhcmdldCk7XG4gICAgfVxuXG4gICAgdmFyIHN1Y2Nlc3MgPSB0cmFwLmNhbGwodGhpcy5oYW5kbGVyLCB0aGlzLnRhcmdldCk7XG4gICAgc3VjY2VzcyA9ICEhc3VjY2VzczsgLy8gY29lcmNlIHRvIEJvb2xlYW5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgaWYgKE9iamVjdF9pc0V4dGVuc2libGUodGhpcy50YXJnZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCByZXBvcnQgZXh0ZW5zaWJsZSBvYmplY3QgYXMgbm9uLWV4dGVuc2libGU6IFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5hbWUgZGVub3RlcyBhIHNlYWxlZCBwcm9wZXJ0eSwgY2hlY2sgd2hldGhlciBoYW5kbGVyIHJlamVjdHMuXG4gICAqL1xuICBkZWxldGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdHJhcCA9IHRoaXMuZ2V0VHJhcChcImRlbGV0ZVByb3BlcnR5XCIpO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRlZmF1bHQgZm9yd2FyZGluZyBiZWhhdmlvclxuICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy50YXJnZXQsIG5hbWUpO1xuICAgIH1cblxuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgdmFyIHJlcyA9IHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRoaXMudGFyZ2V0LCBuYW1lKTtcbiAgICByZXMgPSAhIXJlczsgLy8gY29lcmNlIHRvIEJvb2xlYW5cblxuICAgIHZhciB0YXJnZXREZXNjO1xuICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgIHRhcmdldERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMudGFyZ2V0LCBuYW1lKTtcbiAgICAgIGlmICh0YXJnZXREZXNjICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0RGVzYy5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInIGlzIG5vbi1jb25maWd1cmFibGUgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmQgY2FuJ3QgYmUgZGVsZXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXREZXNjICE9PSB1bmRlZmluZWQgJiYgIU9iamVjdF9pc0V4dGVuc2libGUodGhpcy50YXJnZXQpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBzdGlsbCBleGlzdHMgb24gYSBub24tZXh0ZW5zaWJsZSB0YXJnZXQgYnV0XG4gICAgICAgIC8vIGlzIHJlcG9ydGVkIGFzIHN1Y2Nlc3NmdWxseSBkZWxldGVkLCBpdCBtYXkgbGF0ZXIgYmUgcmVwb3J0ZWRcbiAgICAgICAgLy8gYXMgcHJlc2VudCwgd2hpY2ggdmlvbGF0ZXMgdGhlIGludmFyaWFudCB0aGF0IGFuIG93biBwcm9wZXJ0eSxcbiAgICAgICAgLy8gZGVsZXRlZCBmcm9tIGEgbm9uLWV4dGVuc2libGUgb2JqZWN0IGNhbm5vdCByZWFwcGVhci5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcImNhbm5vdCBzdWNjZXNzZnVsbHkgZGVsZXRlIGV4aXN0aW5nIHByb3BlcnR5ICdcIiArIG5hbWUgK1xuICAgICAgICAgIFwiJyBvbiBhIG5vbi1leHRlbnNpYmxlIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZ2V0T3duUHJvcGVydHlOYW1lcyB0cmFwIHdhcyByZXBsYWNlZCBieSB0aGUgb3duS2V5cyB0cmFwLFxuICAgKiB3aGljaCBub3cgYWxzbyByZXR1cm5zIGFuIGFycmF5IChvZiBzdHJpbmdzIG9yIHN5bWJvbHMpIGFuZFxuICAgKiB3aGljaCBwZXJmb3JtcyB0aGUgc2FtZSByaWdvcm91cyBpbnZhcmlhbnQgY2hlY2tzIGFzIGdldE93blByb3BlcnR5TmFtZXNcbiAgICpcbiAgICogU2VlIGlzc3VlICM0OCBvbiBob3cgdGhpcyB0cmFwIGNhbiBzdGlsbCBnZXQgaW52b2tlZCBieSBleHRlcm5hbCBsaWJzXG4gICAqIHRoYXQgZG9uJ3QgdXNlIHRoZSBwYXRjaGVkIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGZ1bmN0aW9uLlxuICAgKi9cbiAgZ2V0T3duUHJvcGVydHlOYW1lczogZnVuY3Rpb24oKSB7XG4gICAgLy8gTm90ZTogcmVtb3ZlZCBkZXByZWNhdGlvbiB3YXJuaW5nIHRvIGF2b2lkIGRlcGVuZGVuY3kgb24gJ2NvbnNvbGUnXG4gICAgLy8gKGFuZCBvbiBub2RlLCBzaG91bGQgYW55d2F5IHVzZSB1dGlsLmRlcHJlY2F0ZSkuIERlcHJlY2F0aW9uIHdhcm5pbmdzXG4gICAgLy8gY2FuIGFsc28gYmUgYW5ub3lpbmcgd2hlbiB0aGV5IGFyZSBvdXRzaWRlIG9mIHRoZSB1c2VyJ3MgY29udHJvbCwgZS5nLlxuICAgIC8vIHdoZW4gYW4gZXh0ZXJuYWwgbGlicmFyeSBjYWxscyB1bnBhdGNoZWQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMuXG4gICAgLy8gU2luY2UgdGhlcmUgaXMgYSBjbGVhbiBmYWxsYmFjayB0byBgb3duS2V5c2AsIHRoZSBmYWN0IHRoYXQgdGhlXG4gICAgLy8gZGVwcmVjYXRlZCBtZXRob2QgaXMgc3RpbGwgY2FsbGVkIGlzIG1vc3RseSBoYXJtbGVzcyBhbnl3YXkuXG4gICAgLy8gU2VlIGFsc28gaXNzdWVzICM2NSBhbmQgIzY2LlxuICAgIC8vIGNvbnNvbGUud2FybihcImdldE93blByb3BlcnR5TmFtZXMgdHJhcCBpcyBkZXByZWNhdGVkLiBVc2Ugb3duS2V5cyBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiB0aGlzLm93bktleXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHRyYXAgcmVzdWx0IGRvZXMgbm90IGNvbnRhaW4gYW55IG5ldyBwcm9wZXJ0aWVzXG4gICAqIGlmIHRoZSBwcm94eSBpcyBub24tZXh0ZW5zaWJsZS5cbiAgICpcbiAgICogQW55IG93biBub24tY29uZmlndXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHRhcmdldCB0aGF0IGFyZSBub3QgaW5jbHVkZWRcbiAgICogaW4gdGhlIHRyYXAgcmVzdWx0IGdpdmUgcmlzZSB0byBhIFR5cGVFcnJvci4gQXMgc3VjaCwgd2UgY2hlY2sgd2hldGhlciB0aGVcbiAgICogcmV0dXJuZWQgcmVzdWx0IGNvbnRhaW5zIGF0IGxlYXN0IGFsbCBzZWFsZWQgcHJvcGVydGllcyBvZiB0aGUgdGFyZ2V0XG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQWRkaXRpb25hbGx5LCB0aGUgdHJhcCByZXN1bHQgaXMgbm9ybWFsaXplZC5cbiAgICogSW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlIHRyYXAgcmVzdWx0IGRpcmVjdGx5OlxuICAgKiAgLSBjcmVhdGUgYW5kIHJldHVybiBhIGZyZXNoIEFycmF5LFxuICAgKiAgLSBvZiB3aGljaCBlYWNoIGVsZW1lbnQgaXMgY29lcmNlZCB0byBhIFN0cmluZ1xuICAgKlxuICAgKiBUaGlzIHRyYXAgaXMgY2FsbGVkIGEuby4gYnkgUmVmbGVjdC5vd25LZXlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICAgKiBhbmQgT2JqZWN0LmtleXMgKHRoZSBsYXR0ZXIgZmlsdGVycyBvdXQgb25seSB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcykuXG4gICAqL1xuICBvd25LZXlzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhcCA9IHRoaXMuZ2V0VHJhcChcIm93bktleXNcIik7XG4gICAgaWYgKHRyYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZGVmYXVsdCBmb3J3YXJkaW5nIGJlaGF2aW9yXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRoaXMudGFyZ2V0KTtcbiAgICB9XG5cbiAgICB2YXIgdHJhcFJlc3VsdCA9IHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRoaXMudGFyZ2V0KTtcblxuICAgIC8vIHByb3BOYW1lcyBpcyB1c2VkIGFzIGEgc2V0IG9mIHN0cmluZ3NcbiAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgbnVtUHJvcHMgPSArdHJhcFJlc3VsdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShudW1Qcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVByb3BzOyBpKyspIHtcbiAgICAgIHZhciBzID0gU3RyaW5nKHRyYXBSZXN1bHRbaV0pO1xuICAgICAgaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKHRoaXMudGFyZ2V0KSAmJiAhaXNGaXhlZChzLCB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgLy8gbm9uLWV4dGVuc2libGUgcHJveGllcyBkb24ndCB0b2xlcmF0ZSBuZXcgb3duIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvd25LZXlzIHRyYXAgY2Fubm90IGxpc3QgYSBuZXcgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0eSAnXCIrcytcIicgb24gYSBub24tZXh0ZW5zaWJsZSBvYmplY3RcIik7XG4gICAgICB9XG5cbiAgICAgIHByb3BOYW1lc1tzXSA9IHRydWU7XG4gICAgICByZXN1bHRbaV0gPSBzO1xuICAgIH1cblxuICAgIHZhciBvd25Qcm9wcyA9IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMudGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgb3duUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAob3duUHJvcCkge1xuICAgICAgaWYgKCFwcm9wTmFtZXNbb3duUHJvcF0pIHtcbiAgICAgICAgaWYgKGlzU2VhbGVkKG93blByb3AsIHRhcmdldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3duS2V5cyB0cmFwIGZhaWxlZCB0byBpbmNsdWRlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJub24tY29uZmlndXJhYmxlIHByb3BlcnR5ICdcIitvd25Qcm9wK1wiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSAmJlxuICAgICAgICAgICAgaXNGaXhlZChvd25Qcm9wLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAvLyBpZiBoYW5kbGVyIGlzIGFsbG93ZWQgdG8gcmVwb3J0IG93blByb3AgYXMgbm9uLWV4aXN0ZW50LFxuICAgICAgICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgbmV2ZXIgbGF0ZXIgcmVwb3J0IGl0IGFzXG4gICAgICAgICAgICAvLyBleGlzdGVudC4gT25jZSBhIHByb3BlcnR5IGhhcyBiZWVuIHJlcG9ydGVkIGFzIG5vbi1leGlzdGVudFxuICAgICAgICAgICAgLy8gb24gYSBub24tZXh0ZW5zaWJsZSBvYmplY3QsIGl0IHNob3VsZCBmb3JldmVyIGJlIHJlcG9ydGVkIGFzXG4gICAgICAgICAgICAvLyBub24tZXhpc3RlbnRcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvd25LZXlzIHRyYXAgY2Fubm90IHJlcG9ydCBleGlzdGluZyBvd24gcHJvcGVydHkgJ1wiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25Qcm9wK1wiJyBhcyBub24tZXhpc3RlbnQgb24gYSBub24tZXh0ZW5zaWJsZSBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB0cmFwIHJlc3VsdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHN0YXRlIG9mIHRoZVxuICAgKiB3cmFwcGVkIHRhcmdldC5cbiAgICovXG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYXAgPSB0aGlzLmdldFRyYXAoXCJpc0V4dGVuc2libGVcIik7XG4gICAgaWYgKHRyYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZGVmYXVsdCBmb3J3YXJkaW5nIGJlaGF2aW9yXG4gICAgICByZXR1cm4gUmVmbGVjdC5pc0V4dGVuc2libGUodGhpcy50YXJnZXQpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0cmFwLmNhbGwodGhpcy5oYW5kbGVyLCB0aGlzLnRhcmdldCk7XG4gICAgcmVzdWx0ID0gISFyZXN1bHQ7IC8vIGNvZXJjZSB0byBCb29sZWFuXG4gICAgdmFyIHN0YXRlID0gT2JqZWN0X2lzRXh0ZW5zaWJsZSh0aGlzLnRhcmdldCk7XG4gICAgaWYgKHJlc3VsdCAhPT0gc3RhdGUpIHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCByZXBvcnQgbm9uLWV4dGVuc2libGUgb2JqZWN0IGFzIGV4dGVuc2libGU6IFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHJlcG9ydCBleHRlbnNpYmxlIG9iamVjdCBhcyBub24tZXh0ZW5zaWJsZTogXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSB0cmFwIHJlc3VsdCBjb3JyZXNwb25kcyB0byB0aGUgdGFyZ2V0J3MgW1tQcm90b3R5cGVdXVxuICAgKi9cbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwiZ2V0UHJvdG90eXBlT2ZcIik7XG4gICAgaWYgKHRyYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZGVmYXVsdCBmb3J3YXJkaW5nIGJlaGF2aW9yXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0aGlzLnRhcmdldCk7XG4gICAgfVxuXG4gICAgdmFyIGFsbGVnZWRQcm90byA9IHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRoaXMudGFyZ2V0KTtcblxuICAgIGlmICghT2JqZWN0X2lzRXh0ZW5zaWJsZSh0aGlzLnRhcmdldCkpIHtcbiAgICAgIHZhciBhY3R1YWxQcm90byA9IE9iamVjdF9nZXRQcm90b3R5cGVPZih0aGlzLnRhcmdldCk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShhbGxlZ2VkUHJvdG8sIGFjdHVhbFByb3RvKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHJvdG90eXBlIHZhbHVlIGRvZXMgbm90IG1hdGNoOiBcIiArIHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWxsZWdlZFByb3RvO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiB0YXJnZXQgaXMgbm9uLWV4dGVuc2libGUgYW5kIHNldFByb3RvdHlwZU9mIHRyYXAgcmV0dXJucyB0cnVlLFxuICAgKiBjaGVjayB3aGV0aGVyIHRoZSB0cmFwIHJlc3VsdCBjb3JyZXNwb25kcyB0byB0aGUgdGFyZ2V0J3MgW1tQcm90b3R5cGVdXVxuICAgKi9cbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uKG5ld1Byb3RvKSB7XG4gICAgdmFyIHRyYXAgPSB0aGlzLmdldFRyYXAoXCJzZXRQcm90b3R5cGVPZlwiKTtcbiAgICBpZiAodHJhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkZWZhdWx0IGZvcndhcmRpbmcgYmVoYXZpb3JcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRoaXMudGFyZ2V0LCBuZXdQcm90byk7XG4gICAgfVxuXG4gICAgdmFyIHN1Y2Nlc3MgPSB0cmFwLmNhbGwodGhpcy5oYW5kbGVyLCB0aGlzLnRhcmdldCwgbmV3UHJvdG8pO1xuXG4gICAgc3VjY2VzcyA9ICEhc3VjY2VzcztcbiAgICBpZiAoc3VjY2VzcyAmJiAhT2JqZWN0X2lzRXh0ZW5zaWJsZSh0aGlzLnRhcmdldCkpIHtcbiAgICAgIHZhciBhY3R1YWxQcm90byA9IE9iamVjdF9nZXRQcm90b3R5cGVPZih0aGlzLnRhcmdldCk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShuZXdQcm90bywgYWN0dWFsUHJvdG8pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm90b3R5cGUgdmFsdWUgZG9lcyBub3QgbWF0Y2g6IFwiICsgdGhpcy50YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbiB0aGUgZGlyZWN0IHByb3hpZXMgZGVzaWduIHdpdGggcmVmYWN0b3JlZCBwcm90b3R5cGUgY2xpbWJpbmcsXG4gICAqIHRoaXMgdHJhcCBpcyBkZXByZWNhdGVkLiBGb3IgcHJveGllcy1hcy1wcm90b3R5cGVzLCBmb3ItaW4gd2lsbFxuICAgKiBjYWxsIHRoZSBlbnVtZXJhdGUoKSB0cmFwLiBJZiB0aGF0IHRyYXAgaXMgbm90IGRlZmluZWQsIHRoZVxuICAgKiBvcGVyYXRpb24gaXMgZm9yd2FyZGVkIHRvIHRoZSB0YXJnZXQsIG5vIG1vcmUgZmFsbGJhY2sgb24gdGhpc1xuICAgKiBmdW5kYW1lbnRhbCB0cmFwLlxuICAgKi9cbiAgZ2V0UHJvcGVydHlOYW1lczogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdldFByb3BlcnR5TmFtZXMgdHJhcCBpcyBkZXByZWNhdGVkXCIpO1xuICB9LFxuXG4gIC8vID09PSBkZXJpdmVkIHRyYXBzID09PVxuXG4gIC8qKlxuICAgKiBJZiBuYW1lIGRlbm90ZXMgYSBmaXhlZCBwcm9wZXJ0eSwgY2hlY2sgd2hldGhlciB0aGUgdHJhcCByZXR1cm5zIHRydWUuXG4gICAqL1xuICBoYXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJhcCA9IHRoaXMuZ2V0VHJhcChcImhhc1wiKTtcbiAgICBpZiAodHJhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkZWZhdWx0IGZvcndhcmRpbmcgYmVoYXZpb3JcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0aGlzLnRhcmdldCwgbmFtZSk7XG4gICAgfVxuXG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB2YXIgcmVzID0gdHJhcC5jYWxsKHRoaXMuaGFuZGxlciwgdGhpcy50YXJnZXQsIG5hbWUpO1xuICAgIHJlcyA9ICEhcmVzOyAvLyBjb2VyY2UgdG8gQm9vbGVhblxuXG4gICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChpc1NlYWxlZChuYW1lLCB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCByZXBvcnQgZXhpc3Rpbmcgbm9uLWNvbmZpZ3VyYWJsZSBvd24gXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0eSAnXCIrIG5hbWUgKyBcIicgYXMgYSBub24tZXhpc3RlbnQgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZSh0aGlzLnRhcmdldCkgJiZcbiAgICAgICAgICBpc0ZpeGVkKG5hbWUsIHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgIC8vIGlmIGhhbmRsZXIgaXMgYWxsb3dlZCB0byByZXR1cm4gZmFsc2UsIHdlIGNhbm5vdCBndWFyYW50ZWVcbiAgICAgICAgICAvLyB0aGF0IGl0IHdpbGwgbm90IHJldHVybiB0cnVlIGZvciB0aGlzIHByb3BlcnR5IGxhdGVyLlxuICAgICAgICAgIC8vIE9uY2UgYSBwcm9wZXJ0eSBoYXMgYmVlbiByZXBvcnRlZCBhcyBub24tZXhpc3RlbnQgb24gYSBub24tZXh0ZW5zaWJsZVxuICAgICAgICAgIC8vIG9iamVjdCwgaXQgc2hvdWxkIGZvcmV2ZXIgYmUgcmVwb3J0ZWQgYXMgbm9uLWV4aXN0ZW50XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCByZXBvcnQgZXhpc3Rpbmcgb3duIHByb3BlcnR5ICdcIituYW1lK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInIGFzIG5vbi1leGlzdGVudCBvbiBhIG5vbi1leHRlbnNpYmxlIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiByZXMgPT09IHRydWUsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIGV4dGVuc2liaWxpdHlcbiAgICAvLyBldmVuIGZvciBhIG5vbi1leHRlbnNpYmxlIHByb3h5IHRoYXQgaGFzIG5vIG93biBuYW1lIHByb3BlcnR5LFxuICAgIC8vIHRoZSBwcm9wZXJ0eSBtYXkgaGF2ZSBiZWVuIGluaGVyaXRlZFxuXG4gICAgcmV0dXJuIHJlcztcbiAgfSxcblxuICAvKipcbiAgICogSWYgbmFtZSBkZW5vdGVzIGEgZml4ZWQgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlIGRhdGEgcHJvcGVydHksXG4gICAqIGNoZWNrIGl0cyByZXR1cm4gdmFsdWUgYWdhaW5zdCB0aGUgcHJldmlvdXNseSBhc3NlcnRlZCB2YWx1ZSBvZiB0aGVcbiAgICogZml4ZWQgcHJvcGVydHkuXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBuYW1lKSB7XG5cbiAgICAvLyBleHBlcmltZW50YWwgc3VwcG9ydCBmb3IgaW52b2tlKCkgdHJhcCBvbiBwbGF0Zm9ybXMgdGhhdFxuICAgIC8vIHN1cHBvcnQgX19ub1N1Y2hNZXRob2RfX1xuICAgIC8qXG4gICAgaWYgKG5hbWUgPT09ICdfX25vU3VjaE1ldGhvZF9fJykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuaW52b2tlKHJlY2VpdmVyLCBuYW1lLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwiZ2V0XCIpO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRlZmF1bHQgZm9yd2FyZGluZyBiZWhhdmlvclxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRoaXMudGFyZ2V0LCBuYW1lLCByZWNlaXZlcik7XG4gICAgfVxuXG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB2YXIgcmVzID0gdHJhcC5jYWxsKHRoaXMuaGFuZGxlciwgdGhpcy50YXJnZXQsIG5hbWUsIHJlY2VpdmVyKTtcblxuICAgIHZhciBmaXhlZERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMudGFyZ2V0LCBuYW1lKTtcbiAgICAvLyBjaGVjayBjb25zaXN0ZW5jeSBvZiB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICBpZiAoZml4ZWREZXNjICE9PSB1bmRlZmluZWQpIHsgLy8gZ2V0dGluZyBhbiBleGlzdGluZyBwcm9wZXJ0eVxuICAgICAgaWYgKGlzRGF0YURlc2NyaXB0b3IoZml4ZWREZXNjKSAmJlxuICAgICAgICAgIGZpeGVkRGVzYy5jb25maWd1cmFibGUgPT09IGZhbHNlICYmXG4gICAgICAgICAgZml4ZWREZXNjLndyaXRhYmxlID09PSBmYWxzZSkgeyAvLyBvd24gZnJvemVuIGRhdGEgcHJvcGVydHlcbiAgICAgICAgaWYgKCFzYW1lVmFsdWUocmVzLCBmaXhlZERlc2MudmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCByZXBvcnQgaW5jb25zaXN0ZW50IHZhbHVlIGZvciBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9uLXdyaXRhYmxlLCBub24tY29uZmlndXJhYmxlIHByb3BlcnR5ICdcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUrXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAvLyBpdCdzIGFuIGFjY2Vzc29yIHByb3BlcnR5XG4gICAgICAgIGlmIChpc0FjY2Vzc29yRGVzY3JpcHRvcihmaXhlZERlc2MpICYmXG4gICAgICAgICAgICBmaXhlZERlc2MuY29uZmlndXJhYmxlID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgZml4ZWREZXNjLmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibXVzdCByZXBvcnQgdW5kZWZpbmVkIGZvciBub24tY29uZmlndXJhYmxlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFjY2Vzc29yIHByb3BlcnR5ICdcIituYW1lK1wiJyB3aXRob3V0IGdldHRlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuYW1lIGRlbm90ZXMgYSBmaXhlZCBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUgZGF0YSBwcm9wZXJ0eSxcbiAgICogY2hlY2sgdGhhdCB0aGUgdHJhcCByZWplY3RzIHRoZSBhc3NpZ25tZW50LlxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihyZWNlaXZlciwgbmFtZSwgdmFsKSB7XG4gICAgdmFyIHRyYXAgPSB0aGlzLmdldFRyYXAoXCJzZXRcIik7XG4gICAgaWYgKHRyYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZGVmYXVsdCBmb3J3YXJkaW5nIGJlaGF2aW9yXG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGhpcy50YXJnZXQsIG5hbWUsIHZhbCwgcmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgdmFyIHJlcyA9IHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRoaXMudGFyZ2V0LCBuYW1lLCB2YWwsIHJlY2VpdmVyKTtcbiAgICByZXMgPSAhIXJlczsgLy8gY29lcmNlIHRvIEJvb2xlYW5cblxuICAgIC8vIGlmIHN1Y2Nlc3MgaXMgcmVwb3J0ZWQsIGNoZWNrIHdoZXRoZXIgcHJvcGVydHkgaXMgdHJ1bHkgYXNzaWduYWJsZVxuICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgIHZhciBmaXhlZERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMudGFyZ2V0LCBuYW1lKTtcbiAgICAgIGlmIChmaXhlZERlc2MgIT09IHVuZGVmaW5lZCkgeyAvLyBzZXR0aW5nIGFuIGV4aXN0aW5nIHByb3BlcnR5XG4gICAgICAgIGlmIChpc0RhdGFEZXNjcmlwdG9yKGZpeGVkRGVzYykgJiZcbiAgICAgICAgICAgIGZpeGVkRGVzYy5jb25maWd1cmFibGUgPT09IGZhbHNlICYmXG4gICAgICAgICAgICBmaXhlZERlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFzYW1lVmFsdWUodmFsLCBmaXhlZERlc2MudmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHN1Y2Nlc3NmdWxseSBhc3NpZ24gdG8gYSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJub24td3JpdGFibGUsIG5vbi1jb25maWd1cmFibGUgcHJvcGVydHkgJ1wiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lK1wiJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQWNjZXNzb3JEZXNjcmlwdG9yKGZpeGVkRGVzYykgJiZcbiAgICAgICAgICAgICAgZml4ZWREZXNjLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgJiYgLy8gbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgICAgICAgICBmaXhlZERlc2Muc2V0ID09PSB1bmRlZmluZWQpIHsgICAgICAvLyBhY2Nlc3NvciB3aXRoIHVuZGVmaW5lZCBzZXR0ZXJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzZXR0aW5nIGEgcHJvcGVydHkgJ1wiK25hbWUrXCInIHRoYXQgaGFzIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBvbmx5IGEgZ2V0dGVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFueSBvd24gZW51bWVyYWJsZSBub24tY29uZmlndXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHRhcmdldCB0aGF0IGFyZSBub3RcbiAgICogaW5jbHVkZWQgaW4gdGhlIHRyYXAgcmVzdWx0IGdpdmUgcmlzZSB0byBhIFR5cGVFcnJvci4gQXMgc3VjaCwgd2UgY2hlY2tcbiAgICogd2hldGhlciB0aGUgcmV0dXJuZWQgcmVzdWx0IGNvbnRhaW5zIGF0IGxlYXN0IGFsbCBzZWFsZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAqIG9mIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgdHJhcCBzaG91bGQgcmV0dXJuIGFuIGl0ZXJhdG9yLlxuICAgKlxuICAgKiBIb3dldmVyLCBhcyBpbXBsZW1lbnRhdGlvbnMgb2YgcHJlLWRpcmVjdCBwcm94aWVzIHN0aWxsIGV4cGVjdCBlbnVtZXJhdGVcbiAgICogdG8gcmV0dXJuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHdlIGNvbnZlcnQgdGhlIGl0ZXJhdG9yIGludG8gYW4gYXJyYXkuXG4gICAqL1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwiZW51bWVyYXRlXCIpO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRlZmF1bHQgZm9yd2FyZGluZyBiZWhhdmlvclxuICAgICAgdmFyIHRyYXBSZXN1bHQgPSBSZWZsZWN0LmVudW1lcmF0ZSh0aGlzLnRhcmdldCk7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgbnh0ID0gdHJhcFJlc3VsdC5uZXh0KCk7XG4gICAgICB3aGlsZSAoIW54dC5kb25lKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZyhueHQudmFsdWUpKTtcbiAgICAgICAgbnh0ID0gdHJhcFJlc3VsdC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciB0cmFwUmVzdWx0ID0gdHJhcC5jYWxsKHRoaXMuaGFuZGxlciwgdGhpcy50YXJnZXQpO1xuICAgIFxuICAgIGlmICh0cmFwUmVzdWx0ID09PSBudWxsIHx8XG4gICAgICAgIHRyYXBSZXN1bHQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB0cmFwUmVzdWx0Lm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVudW1lcmF0ZSB0cmFwIHNob3VsZCByZXR1cm4gYW4gaXRlcmF0b3IsIGdvdDogXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYXBSZXN1bHQpOyAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gcHJvcE5hbWVzIGlzIHVzZWQgYXMgYSBzZXQgb2Ygc3RyaW5nc1xuICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIFxuICAgIC8vIHZhciBudW1Qcm9wcyA9ICt0cmFwUmVzdWx0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gW107IC8vIG5ldyBBcnJheShudW1Qcm9wcyk7XG4gICAgXG4gICAgLy8gdHJhcFJlc3VsdCBpcyBzdXBwb3NlZCB0byBiZSBhbiBpdGVyYXRvclxuICAgIC8vIGRyYWluIGl0ZXJhdG9yIHRvIGFycmF5IGFzIGN1cnJlbnQgaW1wbGVtZW50YXRpb25zIHN0aWxsIGV4cGVjdFxuICAgIC8vIGVudW1lcmF0ZSB0byByZXR1cm4gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgIHZhciBueHQgPSB0cmFwUmVzdWx0Lm5leHQoKTtcbiAgICBcbiAgICB3aGlsZSAoIW54dC5kb25lKSB7XG4gICAgICB2YXIgcyA9IFN0cmluZyhueHQudmFsdWUpO1xuICAgICAgaWYgKHByb3BOYW1lc1tzXSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW51bWVyYXRlIHRyYXAgY2Fubm90IGxpc3QgYSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR1cGxpY2F0ZSBwcm9wZXJ0eSAnXCIrcytcIidcIik7XG4gICAgICB9XG4gICAgICBwcm9wTmFtZXNbc10gPSB0cnVlO1xuICAgICAgcmVzdWx0LnB1c2gocyk7XG4gICAgICBueHQgPSB0cmFwUmVzdWx0Lm5leHQoKTtcbiAgICB9XG4gICAgXG4gICAgLypmb3IgKHZhciBpID0gMDsgaSA8IG51bVByb3BzOyBpKyspIHtcbiAgICAgIHZhciBzID0gU3RyaW5nKHRyYXBSZXN1bHRbaV0pO1xuICAgICAgaWYgKHByb3BOYW1lc1tzXSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW51bWVyYXRlIHRyYXAgY2Fubm90IGxpc3QgYSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR1cGxpY2F0ZSBwcm9wZXJ0eSAnXCIrcytcIidcIik7XG4gICAgICB9XG5cbiAgICAgIHByb3BOYW1lc1tzXSA9IHRydWU7XG4gICAgICByZXN1bHRbaV0gPSBzO1xuICAgIH0gKi9cblxuICAgIHZhciBvd25FbnVtZXJhYmxlUHJvcHMgPSBPYmplY3Qua2V5cyh0aGlzLnRhcmdldCk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIG93bkVudW1lcmFibGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvd25FbnVtZXJhYmxlUHJvcCkge1xuICAgICAgaWYgKCFwcm9wTmFtZXNbb3duRW51bWVyYWJsZVByb3BdKSB7XG4gICAgICAgIGlmIChpc1NlYWxlZChvd25FbnVtZXJhYmxlUHJvcCwgdGFyZ2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbnVtZXJhdGUgdHJhcCBmYWlsZWQgdG8gaW5jbHVkZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9uLWNvbmZpZ3VyYWJsZSBlbnVtZXJhYmxlIHByb3BlcnR5ICdcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bkVudW1lcmFibGVQcm9wK1wiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSAmJlxuICAgICAgICAgICAgaXNGaXhlZChvd25FbnVtZXJhYmxlUHJvcCwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgLy8gaWYgaGFuZGxlciBpcyBhbGxvd2VkIG5vdCB0byByZXBvcnQgb3duRW51bWVyYWJsZVByb3AgYXMgYW4gb3duXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSwgd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgbmV2ZXIgcmVwb3J0IGl0IGFzXG4gICAgICAgICAgICAvLyBhbiBvd24gcHJvcGVydHkgbGF0ZXIuIE9uY2UgYSBwcm9wZXJ0eSBoYXMgYmVlbiByZXBvcnRlZCBhc1xuICAgICAgICAgICAgLy8gbm9uLWV4aXN0ZW50IG9uIGEgbm9uLWV4dGVuc2libGUgb2JqZWN0LCBpdCBzaG91bGQgZm9yZXZlciBiZVxuICAgICAgICAgICAgLy8gcmVwb3J0ZWQgYXMgbm9uLWV4aXN0ZW50XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHJlcG9ydCBleGlzdGluZyBvd24gcHJvcGVydHkgJ1wiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25FbnVtZXJhYmxlUHJvcCtcIicgYXMgbm9uLWV4aXN0ZW50IG9uIGEgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9uLWV4dGVuc2libGUgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgaXRlcmF0ZSB0cmFwIGlzIGRlcHJlY2F0ZWQgYnkgdGhlIGVudW1lcmF0ZSB0cmFwLlxuICAgKi9cbiAgaXRlcmF0ZTogVmFsaWRhdG9yLnByb3RvdHlwZS5lbnVtZXJhdGUsXG5cbiAgLyoqXG4gICAqIEFueSBvd24gbm9uLWNvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSB0YXJnZXQgdGhhdCBhcmUgbm90IGluY2x1ZGVkXG4gICAqIGluIHRoZSB0cmFwIHJlc3VsdCBnaXZlIHJpc2UgdG8gYSBUeXBlRXJyb3IuIEFzIHN1Y2gsIHdlIGNoZWNrIHdoZXRoZXIgdGhlXG4gICAqIHJldHVybmVkIHJlc3VsdCBjb250YWlucyBhdCBsZWFzdCBhbGwgc2VhbGVkIHByb3BlcnRpZXMgb2YgdGhlIHRhcmdldFxuICAgKiBvYmplY3QuXG4gICAqXG4gICAqIFRoZSB0cmFwIHJlc3VsdCBpcyBub3JtYWxpemVkLlxuICAgKiBUaGUgdHJhcCByZXN1bHQgaXMgbm90IHJldHVybmVkIGRpcmVjdGx5LiBJbnN0ZWFkOlxuICAgKiAgLSBjcmVhdGUgYW5kIHJldHVybiBhIGZyZXNoIEFycmF5LFxuICAgKiAgLSBvZiB3aGljaCBlYWNoIGVsZW1lbnQgaXMgY29lcmNlZCB0byBTdHJpbmcsXG4gICAqICAtIHdoaWNoIGRvZXMgbm90IGNvbnRhaW4gZHVwbGljYXRlc1xuICAgKlxuICAgKiBGSVhNRToga2V5cyB0cmFwIGlzIGRlcHJlY2F0ZWRcbiAgICovXG4gIC8qXG4gIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwia2V5c1wiKTtcbiAgICBpZiAodHJhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkZWZhdWx0IGZvcndhcmRpbmcgYmVoYXZpb3JcbiAgICAgIHJldHVybiBSZWZsZWN0LmtleXModGhpcy50YXJnZXQpO1xuICAgIH1cblxuICAgIHZhciB0cmFwUmVzdWx0ID0gdHJhcC5jYWxsKHRoaXMuaGFuZGxlciwgdGhpcy50YXJnZXQpO1xuXG4gICAgLy8gcHJvcE5hbWVzIGlzIHVzZWQgYXMgYSBzZXQgb2Ygc3RyaW5nc1xuICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBudW1Qcm9wcyA9ICt0cmFwUmVzdWx0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG51bVByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJvcHM7IGkrKykge1xuICAgICB2YXIgcyA9IFN0cmluZyh0cmFwUmVzdWx0W2ldKTtcbiAgICAgaWYgKHByb3BOYW1lc1tzXSkge1xuICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlzIHRyYXAgY2Fubm90IGxpc3QgYSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHVwbGljYXRlIHByb3BlcnR5ICdcIitzK1wiJ1wiKTtcbiAgICAgfVxuICAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUodGhpcy50YXJnZXQpICYmICFpc0ZpeGVkKHMsIHRoaXMudGFyZ2V0KSkge1xuICAgICAgIC8vIG5vbi1leHRlbnNpYmxlIHByb3hpZXMgZG9uJ3QgdG9sZXJhdGUgbmV3IG93biBwcm9wZXJ0eSBuYW1lc1xuICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlzIHRyYXAgY2Fubm90IGxpc3QgYSBuZXcgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcInByb3BlcnR5ICdcIitzK1wiJyBvbiBhIG5vbi1leHRlbnNpYmxlIG9iamVjdFwiKTtcbiAgICAgfVxuXG4gICAgIHByb3BOYW1lc1tzXSA9IHRydWU7XG4gICAgIHJlc3VsdFtpXSA9IHM7XG4gICAgfVxuXG4gICAgdmFyIG93bkVudW1lcmFibGVQcm9wcyA9IE9iamVjdC5rZXlzKHRoaXMudGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgb3duRW51bWVyYWJsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKG93bkVudW1lcmFibGVQcm9wKSB7XG4gICAgICBpZiAoIXByb3BOYW1lc1tvd25FbnVtZXJhYmxlUHJvcF0pIHtcbiAgICAgICAgaWYgKGlzU2VhbGVkKG93bkVudW1lcmFibGVQcm9wLCB0YXJnZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleXMgdHJhcCBmYWlsZWQgdG8gaW5jbHVkZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9uLWNvbmZpZ3VyYWJsZSBlbnVtZXJhYmxlIHByb3BlcnR5ICdcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bkVudW1lcmFibGVQcm9wK1wiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSAmJlxuICAgICAgICAgICAgaXNGaXhlZChvd25FbnVtZXJhYmxlUHJvcCwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgLy8gaWYgaGFuZGxlciBpcyBhbGxvd2VkIG5vdCB0byByZXBvcnQgb3duRW51bWVyYWJsZVByb3AgYXMgYW4gb3duXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSwgd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgbmV2ZXIgcmVwb3J0IGl0IGFzXG4gICAgICAgICAgICAvLyBhbiBvd24gcHJvcGVydHkgbGF0ZXIuIE9uY2UgYSBwcm9wZXJ0eSBoYXMgYmVlbiByZXBvcnRlZCBhc1xuICAgICAgICAgICAgLy8gbm9uLWV4aXN0ZW50IG9uIGEgbm9uLWV4dGVuc2libGUgb2JqZWN0LCBpdCBzaG91bGQgZm9yZXZlciBiZVxuICAgICAgICAgICAgLy8gcmVwb3J0ZWQgYXMgbm9uLWV4aXN0ZW50XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHJlcG9ydCBleGlzdGluZyBvd24gcHJvcGVydHkgJ1wiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25FbnVtZXJhYmxlUHJvcCtcIicgYXMgbm9uLWV4aXN0ZW50IG9uIGEgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9uLWV4dGVuc2libGUgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAqL1xuICBcbiAgLyoqXG4gICAqIE5ldyB0cmFwIHRoYXQgcmVpZmllcyBbW0NhbGxdXS5cbiAgICogSWYgdGhlIHRhcmdldCBpcyBhIGZ1bmN0aW9uLCB0aGVuIGEgY2FsbCB0b1xuICAgKiAgIHByb3h5KC4uLmFyZ3MpXG4gICAqIFRyaWdnZXJzIHRoaXMgdHJhcFxuICAgKi9cbiAgYXBwbHk6IGZ1bmN0aW9uKHRhcmdldCwgdGhpc0JpbmRpbmcsIGFyZ3MpIHtcbiAgICB2YXIgdHJhcCA9IHRoaXMuZ2V0VHJhcChcImFwcGx5XCIpO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRhcmdldCwgdGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXBwbHk6IFwiKyB0YXJnZXQgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5ldyB0cmFwIHRoYXQgcmVpZmllcyBbW0NvbnN0cnVjdF1dLlxuICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIHRoZW4gYSBjYWxsIHRvXG4gICAqICAgbmV3IHByb3h5KC4uLmFyZ3MpXG4gICAqIFRyaWdnZXJzIHRoaXMgdHJhcFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbih0YXJnZXQsIGFyZ3MsIG5ld1RhcmdldCkge1xuICAgIHZhciB0cmFwID0gdGhpcy5nZXRUcmFwKFwiY29uc3RydWN0XCIpO1xuICAgIGlmICh0cmFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5ldzogXCIrIHRhcmdldCArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmIChuZXdUYXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5ld1RhcmdldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZXc6IFwiKyBuZXdUYXJnZXQgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH0gICAgICBcbiAgICB9XG4gICAgcmV0dXJuIHRyYXAuY2FsbCh0aGlzLmhhbmRsZXIsIHRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgfVxufTtcblxuLy8gLS0tLSBlbmQgb2YgdGhlIFZhbGlkYXRvciBoYW5kbGVyIHdyYXBwZXIgaGFuZGxlciAtLS0tXG5cbi8vIEluIHdoYXQgZm9sbG93cywgYSAnZGlyZWN0IHByb3h5JyBpcyBhIHByb3h5XG4vLyB3aG9zZSBoYW5kbGVyIGlzIGEgVmFsaWRhdG9yLiBTdWNoIHByb3hpZXMgY2FuIGJlIG1hZGUgbm9uLWV4dGVuc2libGUsXG4vLyBzZWFsZWQgb3IgZnJvemVuIHdpdGhvdXQgbG9zaW5nIHRoZSBhYmlsaXR5IHRvIHRyYXAuXG5cbi8vIG1hcHMgZGlyZWN0IHByb3hpZXMgdG8gdGhlaXIgVmFsaWRhdG9yIGhhbmRsZXJzXG52YXIgZGlyZWN0UHJveGllcyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIHBhdGNoIE9iamVjdC57cHJldmVudEV4dGVuc2lvbnMsc2VhbCxmcmVlemV9IHNvIHRoYXRcbi8vIHRoZXkgcmVjb2duaXplIGZpeGFibGUgcHJveGllcyBhbmQgYWN0IGFjY29yZGluZ2x5XG5PYmplY3QucHJldmVudEV4dGVuc2lvbnMgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gIHZhciB2aGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHN1YmplY3QpO1xuICBpZiAodmhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh2aGFuZGxlci5wcmV2ZW50RXh0ZW5zaW9ucygpKSB7XG4gICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByZXZlbnRFeHRlbnNpb25zIG9uIFwiK3N1YmplY3QrXCIgcmVqZWN0ZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmltX3ByZXZlbnRFeHRlbnNpb25zKHN1YmplY3QpO1xuICB9XG59O1xuT2JqZWN0LnNlYWwgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gIHNldEludGVncml0eUxldmVsKHN1YmplY3QsIFwic2VhbGVkXCIpO1xuICByZXR1cm4gc3ViamVjdDtcbn07XG5PYmplY3QuZnJlZXplID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICBzZXRJbnRlZ3JpdHlMZXZlbChzdWJqZWN0LCBcImZyb3plblwiKTtcbiAgcmV0dXJuIHN1YmplY3Q7XG59O1xuT2JqZWN0LmlzRXh0ZW5zaWJsZSA9IE9iamVjdF9pc0V4dGVuc2libGUgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gIHZhciB2SGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHN1YmplY3QpO1xuICBpZiAodkhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2SGFuZGxlci5pc0V4dGVuc2libGUoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJpbV9pc0V4dGVuc2libGUoc3ViamVjdCk7XG4gIH1cbn07XG5PYmplY3QuaXNTZWFsZWQgPSBPYmplY3RfaXNTZWFsZWQgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gIHJldHVybiB0ZXN0SW50ZWdyaXR5TGV2ZWwoc3ViamVjdCwgXCJzZWFsZWRcIik7XG59O1xuT2JqZWN0LmlzRnJvemVuID0gT2JqZWN0X2lzRnJvemVuID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICByZXR1cm4gdGVzdEludGVncml0eUxldmVsKHN1YmplY3QsIFwiZnJvemVuXCIpO1xufTtcbk9iamVjdC5nZXRQcm90b3R5cGVPZiA9IE9iamVjdF9nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKHN1YmplY3QpIHtcbiAgdmFyIHZIYW5kbGVyID0gZGlyZWN0UHJveGllcy5nZXQoc3ViamVjdCk7XG4gIGlmICh2SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZIYW5kbGVyLmdldFByb3RvdHlwZU9mKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByaW1fZ2V0UHJvdG90eXBlT2Yoc3ViamVjdCk7XG4gIH1cbn07XG5cbi8vIHBhdGNoIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgdG8gZGlyZWN0bHkgY2FsbFxuLy8gdGhlIFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHRyYXBcbi8vIFRoaXMgaXMgdG8gY2lyY3VtdmVudCBhbiBhc3NlcnRpb24gaW4gdGhlIGJ1aWx0LWluIFByb3h5XG4vLyB0cmFwcGluZyBtZWNoYW5pc20gb2YgdjgsIHdoaWNoIGRpc2FsbG93cyB0aGF0IHRyYXAgdG9cbi8vIHJldHVybiBub24tY29uZmlndXJhYmxlIHByb3BlcnR5IGRlc2NyaXB0b3JzIChhcyBwZXIgdGhlXG4vLyBvbGQgUHJveHkgZGVzaWduKVxuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uKHN1YmplY3QsIG5hbWUpIHtcbiAgdmFyIHZoYW5kbGVyID0gZGlyZWN0UHJveGllcy5nZXQoc3ViamVjdCk7XG4gIGlmICh2aGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZoYW5kbGVyLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJpbV9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3ViamVjdCwgbmFtZSk7XG4gIH1cbn07XG5cbi8vIHBhdGNoIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBkaXJlY3RseSBjYWxsXG4vLyB0aGUgVmFsaWRhdG9yLnByb3RvdHlwZS5kZWZpbmVQcm9wZXJ0eSB0cmFwXG4vLyBUaGlzIGlzIHRvIGNpcmN1bXZlbnQgdHdvIGlzc3VlcyB3aXRoIHRoZSBidWlsdC1pblxuLy8gdHJhcCBtZWNoYW5pc206XG4vLyAxKSB0aGUgY3VycmVudCB0cmFjZW1vbmtleSBpbXBsZW1lbnRhdGlvbiBvZiBwcm94aWVzXG4vLyBhdXRvLWNvbXBsZXRlcyAnZGVzYycsIHdoaWNoIGlzIG5vdCBjb3JyZWN0LiAnZGVzYycgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkLCBidXQgbm90IGNvbXBsZXRlZC4gQ29uc2lkZXI6XG4vLyBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICdmb28nLCB7ZW51bWVyYWJsZTpmYWxzZX0pXG4vLyBUaGlzIHRyYXAgd2lsbCByZWNlaXZlIGRlc2MgPVxuLy8gIHt2YWx1ZTp1bmRlZmluZWQsd3JpdGFibGU6ZmFsc2UsZW51bWVyYWJsZTpmYWxzZSxjb25maWd1cmFibGU6ZmFsc2V9XG4vLyBUaGlzIHdpbGwgYWxzbyBzZXQgYWxsIG90aGVyIGF0dHJpYnV0ZXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZSxcbi8vIHdoaWNoIGlzIHVuZXhwZWN0ZWQgYW5kIGRpZmZlcmVudCBmcm9tIFtbRGVmaW5lT3duUHJvcGVydHldXS5cbi8vIEJ1ZyBmaWxlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjAxMzI5XG4vLyAyKSB0aGUgY3VycmVudCBzcGlkZXJtb25rZXkgaW1wbGVtZW50YXRpb24gZG9lcyBub3Rcbi8vIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIHRoaXMgdHJhcCByZXR1cm5zICdmYWxzZScsIGJ1dCBpbnN0ZWFkIHNpbGVudGx5XG4vLyBpZ25vcmVzIHRoZSBvcGVyYXRpb24gKHRoaXMgaXMgcmVnYXJkbGVzcyBvZiBzdHJpY3QtbW9kZSlcbi8vIDJhKSB2OCBkb2VzIHRocm93IGFuIGV4Y2VwdGlvbiBmb3IgdGhpcyBjYXNlLCBidXQgaW5jbHVkZXMgdGhlIHJhdGhlclxuLy8gICAgIHVuaGVscGZ1bCBlcnJvciBtZXNzYWdlOlxuLy8gJ1Byb3h5IGhhbmRsZXIgIzxPYmplY3Q+IHJldHVybmVkIGZhbHNlIGZyb20gJ2RlZmluZVByb3BlcnR5JyB0cmFwJ1xuT2JqZWN0LmRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oc3ViamVjdCwgbmFtZSwgZGVzYykge1xuICB2YXIgdmhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldChzdWJqZWN0KTtcbiAgaWYgKHZoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbm9ybWFsaXplZERlc2MgPSBub3JtYWxpemVQcm9wZXJ0eURlc2NyaXB0b3IoZGVzYyk7XG4gICAgdmFyIHN1Y2Nlc3MgPSB2aGFuZGxlci5kZWZpbmVQcm9wZXJ0eShuYW1lLCBub3JtYWxpemVkRGVzYyk7XG4gICAgaWYgKHN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgcmVkZWZpbmUgcHJvcGVydHkgJ1wiK25hbWUrXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViamVjdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJpbV9kZWZpbmVQcm9wZXJ0eShzdWJqZWN0LCBuYW1lLCBkZXNjKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbihzdWJqZWN0LCBkZXNjcykge1xuICB2YXIgdmhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldChzdWJqZWN0KTtcbiAgaWYgKHZoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhkZXNjcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciBub3JtYWxpemVkRGVzYyA9IG5vcm1hbGl6ZVByb3BlcnR5RGVzY3JpcHRvcihkZXNjc1tuYW1lXSk7XG4gICAgICB2YXIgc3VjY2VzcyA9IHZoYW5kbGVyLmRlZmluZVByb3BlcnR5KG5hbWUsIG5vcm1hbGl6ZWREZXNjKTtcbiAgICAgIGlmIChzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgcmVkZWZpbmUgcHJvcGVydHkgJ1wiK25hbWUrXCInXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3ViamVjdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJpbV9kZWZpbmVQcm9wZXJ0aWVzKHN1YmplY3QsIGRlc2NzKTtcbiAgfVxufTtcblxuT2JqZWN0LmtleXMgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gIHZhciB2SGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHN1YmplY3QpO1xuICBpZiAodkhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBvd25LZXlzID0gdkhhbmRsZXIub3duS2V5cygpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG93bktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrID0gU3RyaW5nKG93bktleXNbaV0pO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN1YmplY3QsIGspO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUgPT09IHRydWUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByaW1fa2V5cyhzdWJqZWN0KTtcbiAgfVxufVxuXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICB2YXIgdkhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldChzdWJqZWN0KTtcbiAgaWYgKHZIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdkhhbmRsZXIub3duS2V5cygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmltX2dldE93blByb3BlcnR5TmFtZXMoc3ViamVjdCk7XG4gIH1cbn1cblxuLy8gZml4ZXMgaXNzdWUgIzcxIChDYWxsaW5nIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoKSBvbiBhIFByb3h5XG4vLyB0aHJvd3MgYW4gZXJyb3IpXG5pZiAocHJpbV9nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IHVuZGVmaW5lZCkge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICAgIHZhciB2SGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHN1YmplY3QpO1xuICAgIGlmICh2SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhcyB0aGlzIHNoaW0gZG9lcyBub3Qgc3VwcG9ydCBzeW1ib2xzLCBhIFByb3h5IG5ldmVyIGFkdmVydGlzZXNcbiAgICAgIC8vIGFueSBzeW1ib2wtdmFsdWVkIG93biBwcm9wZXJ0aWVzXG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmltX2dldE93blByb3BlcnR5U3ltYm9scyhzdWJqZWN0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGZpeGVzIGlzc3VlICM3MiAoJ0lsbGVnYWwgYWNjZXNzJyBlcnJvciB3aGVuIHVzaW5nIE9iamVjdC5hc3NpZ24pXG4vLyBPYmplY3QuYXNzaWduIHBvbHlmaWxsIGJhc2VkIG9uIGEgcG9seWZpbGwgcG9zdGVkIG9uIE1ETjogXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9cXFxuLy8gIEdsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbi8vIE5vdGUgdGhhdCB0aGlzIHBvbHlmaWxsIGRvZXMgbm90IHN1cHBvcnQgU3ltYm9scywgYnV0IHRoaXMgUHJveHkgU2hpbVxuLy8gZG9lcyBub3Qgc3VwcG9ydCBTeW1ib2xzIGFueXdheS5cbmlmIChwcmltX2Fzc2lnbiAhPT0gdW5kZWZpbmVkKSB7XG4gIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgXG4gICAgLy8gY2hlY2sgaWYgYW55IGFyZ3VtZW50IGlzIGEgcHJveHkgb2JqZWN0XG4gICAgdmFyIG5vUHJveGllcyA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2SGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAodkhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub1Byb3hpZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub1Byb3hpZXMpIHtcbiAgICAgIC8vIG5vdCBhIHNpbmdsZSBhcmd1bWVudCBpcyBhIHByb3h5LCBwZXJmb3JtIGJ1aWx0LWluIGFsZ29yaXRobVxuICAgICAgcmV0dXJuIHByaW1fYXNzaWduLmFwcGx5KE9iamVjdCwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByb3h5IGFyZ3VtZW50LCB1c2UgdGhlIHBvbHlmaWxsXG4gICAgXG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG5cbi8vIHJldHVybnMgd2hldGhlciBhbiBhcmd1bWVudCBpcyBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QsXG4vLyB3aGljaCBpcyBsZWdhbCBhcyBhIFdlYWtNYXAga2V5LlxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgcmV0dXJuICh0eXBlID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGwpIHx8ICh0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG5cbi8vIGEgd3JhcHBlciBmb3IgV2Vha01hcC5nZXQgd2hpY2ggcmV0dXJucyB0aGUgdW5kZWZpbmVkIHZhbHVlXG4vLyBmb3Iga2V5cyB0aGF0IGFyZSBub3Qgb2JqZWN0cyAoaW4gd2hpY2ggY2FzZSB0aGUgdW5kZXJseWluZ1xuLy8gV2Vha01hcCB3b3VsZCBoYXZlIHRocm93biBhIFR5cGVFcnJvcikuXG5mdW5jdGlvbiBzYWZlV2Vha01hcEdldChtYXAsIGtleSkge1xuICByZXR1cm4gaXNPYmplY3Qoa2V5KSA/IG1hcC5nZXQoa2V5KSA6IHVuZGVmaW5lZDtcbn07XG5cbi8vIHJldHVybnMgYSBuZXcgZnVuY3Rpb24gb2YgemVybyBhcmd1bWVudHMgdGhhdCByZWN1cnNpdmVseVxuLy8gdW53cmFwcyBhbnkgcHJveGllcyBzcGVjaWZpZWQgYXMgdGhlIHx0aGlzfC12YWx1ZS5cbi8vIFRoZSBwcmltaXRpdmUgaXMgYXNzdW1lZCB0byBiZSBhIHplcm8tYXJndW1lbnQgbWV0aG9kXG4vLyB0aGF0IHVzZXMgaXRzIHx0aGlzfC1iaW5kaW5nLlxuZnVuY3Rpb24gbWFrZVVud3JhcHBpbmcwQXJnTWV0aG9kKHByaW1pdGl2ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gYnVpbHRpbigpIHtcbiAgICB2YXIgdkhhbmRsZXIgPSBzYWZlV2Vha01hcEdldChkaXJlY3RQcm94aWVzLCB0aGlzKTtcbiAgICBpZiAodkhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGJ1aWx0aW4uY2FsbCh2SGFuZGxlci50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIG9mIDEgYXJndW1lbnRzIHRoYXQgcmVjdXJzaXZlbHlcbi8vIHVud3JhcHMgYW55IHByb3hpZXMgc3BlY2lmaWVkIGFzIHRoZSB8dGhpc3wtdmFsdWUuXG4vLyBUaGUgcHJpbWl0aXZlIGlzIGFzc3VtZWQgdG8gYmUgYSAxLWFyZ3VtZW50IG1ldGhvZFxuLy8gdGhhdCB1c2VzIGl0cyB8dGhpc3wtYmluZGluZy5cbmZ1bmN0aW9uIG1ha2VVbndyYXBwaW5nMUFyZ01ldGhvZChwcmltaXRpdmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJ1aWx0aW4oYXJnKSB7XG4gICAgdmFyIHZIYW5kbGVyID0gc2FmZVdlYWtNYXBHZXQoZGlyZWN0UHJveGllcywgdGhpcyk7XG4gICAgaWYgKHZIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBidWlsdGluLmNhbGwodkhhbmRsZXIudGFyZ2V0LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlLmNhbGwodGhpcywgYXJnKTtcbiAgICB9XG4gIH1cbn07XG5cbk9iamVjdC5wcm90b3R5cGUudmFsdWVPZiA9XG4gIG1ha2VVbndyYXBwaW5nMEFyZ01ldGhvZChPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpO1xuT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9XG4gIG1ha2VVbndyYXBwaW5nMEFyZ01ldGhvZChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIG1ha2VVbndyYXBwaW5nMEFyZ01ldGhvZChGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcpO1xuRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBtYWtlVW53cmFwcGluZzBBcmdNZXRob2QoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG5PYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YgPSBmdW5jdGlvbiBidWlsdGluKGFyZykge1xuICAvLyBidWdmaXggdGhhbmtzIHRvIEJpbGwgTWFyazpcbiAgLy8gYnVpbHQtaW4gaXNQcm90b3R5cGVPZiBkb2VzIG5vdCB1bndyYXAgcHJveGllcyB1c2VkXG4gIC8vIGFzIGFyZ3VtZW50cy4gU28sIHdlIGltcGxlbWVudCB0aGUgYnVpbHRpbiBvdXJzZWx2ZXMsXG4gIC8vIGJhc2VkIG9uIHRoZSBFQ01BU2NyaXB0IDYgc3BlYy4gT3VyIGVuY29kaW5nIHdpbGxcbiAgLy8gbWFrZSBzdXJlIHRoYXQgaWYgYSBwcm94eSBpcyB1c2VkIGFzIGFuIGFyZ3VtZW50LFxuICAvLyBpdHMgZ2V0UHJvdG90eXBlT2YgdHJhcCB3aWxsIGJlIGNhbGxlZC5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgdkhhbmRsZXIyID0gc2FmZVdlYWtNYXBHZXQoZGlyZWN0UHJveGllcywgYXJnKTtcbiAgICBpZiAodkhhbmRsZXIyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFyZyA9IHZIYW5kbGVyMi5nZXRQcm90b3R5cGVPZigpO1xuICAgICAgaWYgKGFyZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWYWx1ZShhcmcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJpbV9pc1Byb3RvdHlwZU9mLmNhbGwodGhpcywgYXJnKTtcbiAgICB9XG4gIH1cbn07XG5cbkFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gIHZhciB2SGFuZGxlciA9IHNhZmVXZWFrTWFwR2V0KGRpcmVjdFByb3hpZXMsIHN1YmplY3QpO1xuICBpZiAodkhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZIYW5kbGVyLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByaW1faXNBcnJheShzdWJqZWN0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcm94eUFycmF5KGFyZykge1xuICB2YXIgdkhhbmRsZXIgPSBzYWZlV2Vha01hcEdldChkaXJlY3RQcm94aWVzLCBhcmcpO1xuICBpZiAodkhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZIYW5kbGVyLnRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBBcnJheS5wcm90b3R5cGUuY29uY2F0IGludGVybmFsbHkgdGVzdHMgd2hldGhlciBvbmUgb2YgaXRzXG4vLyBhcmd1bWVudHMgaXMgYW4gQXJyYXksIGJ5IGNoZWNraW5nIHdoZXRoZXIgW1tDbGFzc11dID09IFwiQXJyYXlcIlxuLy8gQXMgc3VjaCwgaXQgd2lsbCBmYWlsIHRvIHJlY29nbml6ZSBwcm94aWVzLWZvci1hcnJheXMgYXMgYXJyYXlzLlxuLy8gV2UgcGF0Y2ggQXJyYXkucHJvdG90eXBlLmNvbmNhdCBzbyB0aGF0IGl0IFwidW53cmFwc1wiIHByb3hpZXMtZm9yLWFycmF5c1xuLy8gYnkgbWFraW5nIGEgY29weS4gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIGV4YWN0IHNhbWUgc2VxdWVuY2Ugb2Zcbi8vIHRyYXBzIG9uIHRoZSBwcm94eS1mb3ItYXJyYXkgYXMgaWYgd2Ugd291bGQgbm90IGhhdmUgdW53cmFwcGVkIGl0LlxuLy8gU2VlIDxodHRwczovL2dpdGh1Yi5jb20vdHZjdXRzZW0vaGFybW9ueS1yZWZsZWN0L2lzc3Vlcy8xOT4gZm9yIG1vcmUuXG5BcnJheS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgdmFyIGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNQcm94eUFycmF5KGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgIGxlbmd0aCA9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgICBhcmd1bWVudHNbaV0gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHNbaV0sIDAsIGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmltX2NvbmNhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gc2V0UHJvdG90eXBlT2Ygc3VwcG9ydCBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IF9fcHJvdG9fX1xuXG52YXIgcHJpbV9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuLy8gcGF0Y2ggYW5kIGV4dHJhY3Qgb3JpZ2luYWwgX19wcm90b19fIHNldHRlclxudmFyIF9fcHJvdG9fX3NldHRlciA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHByb3RvRGVzYyA9IHByaW1fZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsJ19fcHJvdG9fXycpO1xuICBpZiAocHJvdG9EZXNjID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHR5cGVvZiBwcm90b0Rlc2Muc2V0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2V0UHJvdG90eXBlT2Ygbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlZSBpZiB3ZSBjYW4gYWN0dWFsbHkgbXV0YXRlIGEgcHJvdG90eXBlIHdpdGggdGhlIGdlbmVyaWMgc2V0dGVyXG4gIC8vIChlLmcuIENocm9tZSB2MjggZG9lc24ndCBhbGxvdyBzZXR0aW5nIF9fcHJvdG9fXyB2aWEgdGhlIGdlbmVyaWMgc2V0dGVyKVxuICB0cnkge1xuICAgIHByb3RvRGVzYy5zZXQuY2FsbCh7fSx7fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2V0UHJvdG90eXBlT2Ygbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbiAgfVxuXG4gIHByaW1fZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKG5ld1Byb3RvKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE9iamVjdChuZXdQcm90bykpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHByb3RvRGVzYy5zZXQ7XG59KCkpO1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbih0YXJnZXQsIG5ld1Byb3RvKSB7XG4gIHZhciBoYW5kbGVyID0gZGlyZWN0UHJveGllcy5nZXQodGFyZ2V0KTtcbiAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChoYW5kbGVyLnNldFByb3RvdHlwZU9mKG5ld1Byb3RvKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3h5IHJlamVjdGVkIHByb3RvdHlwZSBtdXRhdGlvblwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFPYmplY3RfaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBzZXQgcHJvdG90eXBlIG9uIG5vbi1leHRlbnNpYmxlIG9iamVjdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAocHJpbV9zZXRQcm90b3R5cGVPZilcbiAgICAgIHJldHVybiBwcmltX3NldFByb3RvdHlwZU9mKHRhcmdldCwgbmV3UHJvdG8pO1xuXG4gICAgaWYgKE9iamVjdChuZXdQcm90bykgIT09IG5ld1Byb3RvIHx8IG5ld1Byb3RvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3RvKTtcbiAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgbnVsbFwiKVxuICAgIH1cbiAgICBfX3Byb3RvX19zZXR0ZXIuY2FsbCh0YXJnZXQsIG5ld1Byb3RvKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG59XG5cbk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBoYW5kbGVyID0gc2FmZVdlYWtNYXBHZXQoZGlyZWN0UHJveGllcywgdGhpcyk7XG4gIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZGVzYyA9IGhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpO1xuICAgIHJldHVybiBkZXNjICE9PSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByaW1faGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09IFJlZmxlY3Rpb24gbW9kdWxlID09PT09PT09PT09PT1cbi8vIHNlZSBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OnJlZmxlY3RfYXBpXG5cbnZhciBSZWZsZWN0ID0ge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIGRlc2MpIHtcblxuICAgIC8vIGlmIHRhcmdldCBpcyBhIHByb3h5LCBpbnZva2UgaXRzIFwiZGVmaW5lUHJvcGVydHlcIiB0cmFwXG4gICAgdmFyIGhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldCh0YXJnZXQpO1xuICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzYyk7XG4gICAgfVxuXG4gICAgLy8gSW1wbGVtZW50YXRpb24gdHJhbnNsaXRlcmF0ZWQgZnJvbSBbW0RlZmluZU93blByb3BlcnR5XV1cbiAgICAvLyBzZWUgRVM1LjEgc2VjdGlvbiA4LjEyLjlcbiAgICAvLyB0aGlzIGlzIHRoZSBfZXhhY3Qgc2FtZSBhbGdvcml0aG1fIGFzIHRoZSBpc0NvbXBhdGlibGVEZXNjcmlwdG9yXG4gICAgLy8gYWxnb3JpdGhtIGRlZmluZWQgYWJvdmUsIGV4Y2VwdCB0aGF0IGF0IGV2ZXJ5IHBsYWNlIGl0XG4gICAgLy8gcmV0dXJucyB0cnVlLCB0aGlzIGFsZ29yaXRobSBhY3R1YWxseSBkb2VzIGRlZmluZSB0aGUgcHJvcGVydHkuXG4gICAgdmFyIGN1cnJlbnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG4gICAgdmFyIGV4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCk7XG4gICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpYmxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkICYmIGV4dGVuc2libGUgPT09IHRydWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIGRlc2MpOyAvLyBzaG91bGQgbmV2ZXIgZmFpbFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0VtcHR5RGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0VxdWl2YWxlbnREZXNjcmlwdG9yKGN1cnJlbnQsIGRlc2MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgnZW51bWVyYWJsZScgaW4gZGVzYyAmJiBkZXNjLmVudW1lcmFibGUgIT09IGN1cnJlbnQuZW51bWVyYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyaWNEZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAvLyBubyBmdXJ0aGVyIHZhbGlkYXRpb24gbmVjZXNzYXJ5XG4gICAgfSBlbHNlIGlmIChpc0RhdGFEZXNjcmlwdG9yKGN1cnJlbnQpICE9PSBpc0RhdGFEZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICBpZiAoY3VycmVudC5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRGF0YURlc2NyaXB0b3IoY3VycmVudCkgJiYgaXNEYXRhRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgaWYgKGN1cnJlbnQuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3VycmVudC53cml0YWJsZSA9PT0gZmFsc2UgJiYgZGVzYy53cml0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudC53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjICYmICFzYW1lVmFsdWUoZGVzYy52YWx1ZSwgY3VycmVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWNjZXNzb3JEZXNjcmlwdG9yKGN1cnJlbnQpICYmIGlzQWNjZXNzb3JEZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICBpZiAoY3VycmVudC5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICgnc2V0JyBpbiBkZXNjICYmICFzYW1lVmFsdWUoZGVzYy5zZXQsIGN1cnJlbnQuc2V0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dldCcgaW4gZGVzYyAmJiAhc2FtZVZhbHVlKGRlc2MuZ2V0LCBjdXJyZW50LmdldCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzYyk7IC8vIHNob3VsZCBuZXZlciBmYWlsXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgaGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHRhcmdldCk7XG4gICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcbiAgICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRlc2MuY29uZmlndXJhYmxlID09PSB0cnVlKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W25hbWVdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTsgICAgXG4gIH0sXG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbih0YXJnZXQsIG5ld1Byb3RvKSB7XG4gICAgXG4gICAgdmFyIGhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldCh0YXJnZXQpO1xuICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnNldFByb3RvdHlwZU9mKG5ld1Byb3RvKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKE9iamVjdChuZXdQcm90bykgIT09IG5ld1Byb3RvIHx8IG5ld1Byb3RvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3RvKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFPYmplY3RfaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICBpZiAoc2FtZVZhbHVlKGN1cnJlbnQsIG5ld1Byb3RvKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChwcmltX3NldFByb3RvdHlwZU9mKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcmltX3NldFByb3RvdHlwZU9mKHRhcmdldCwgbmV3UHJvdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fcHJvdG9fX3NldHRlci5jYWxsKHRhcmdldCwgbmV3UHJvdG8pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldCh0YXJnZXQpO1xuICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnByZXZlbnRFeHRlbnNpb25zKCk7XG4gICAgfVxuICAgIHByaW1fcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIHRhcmdldDtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIHJlY2VpdmVyKSB7XG4gICAgcmVjZWl2ZXIgPSByZWNlaXZlciB8fCB0YXJnZXQ7XG5cbiAgICAvLyBpZiB0YXJnZXQgaXMgYSBwcm94eSwgaW52b2tlIGl0cyBcImdldFwiIHRyYXBcbiAgICB2YXIgaGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHRhcmdldCk7XG4gICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0KHJlY2VpdmVyLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcbiAgICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHByb3RvLCBuYW1lLCByZWNlaXZlcik7XG4gICAgfVxuICAgIGlmIChpc0RhdGFEZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICB9LFxuICAvLyBSZWZsZWN0LnNldCBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBsYXRlc3QgdmVyc2lvbiBvZiBbW1NldFBdXSBhdFxuICAvLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OnByb3RvX2NsaW1iaW5nX3JlZmFjdG9yaW5nXG4gIHNldDogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICByZWNlaXZlciA9IHJlY2VpdmVyIHx8IHRhcmdldDtcblxuICAgIC8vIGlmIHRhcmdldCBpcyBhIHByb3h5LCBpbnZva2UgaXRzIFwic2V0XCIgdHJhcFxuICAgIHZhciBoYW5kbGVyID0gZGlyZWN0UHJveGllcy5nZXQodGFyZ2V0KTtcbiAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5zZXQocmVjZWl2ZXIsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCwgY2hlY2sgd2hldGhlciB0YXJnZXQgaGFzIGEgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG4gICAgLy8gc2hhZG93aW5nIG5hbWUgb24gcmVjZWl2ZXJcbiAgICB2YXIgb3duRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcblxuICAgIGlmIChvd25EZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5hbWUgaXMgbm90IGRlZmluZWQgaW4gdGFyZ2V0LCBzZWFyY2ggdGFyZ2V0J3MgcHJvdG90eXBlXG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcblxuICAgICAgaWYgKHByb3RvICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGNvbnRpbnVlIHRoZSBzZWFyY2ggaW4gdGFyZ2V0J3MgcHJvdG90eXBlXG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldChwcm90bywgbmFtZSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV2MTYgY2hhbmdlLiBDZi4gaHR0cHM6Ly9idWdzLmVjbWFzY3JpcHQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTQ5XG4gICAgICAvLyB0YXJnZXQgd2FzIHRoZSBsYXN0IHByb3RvdHlwZSwgbm93IHdlIGtub3cgdGhhdCAnbmFtZScgaXMgbm90IHNoYWRvd2VkXG4gICAgICAvLyBieSBhbiBleGlzdGluZyAoYWNjZXNzb3Igb3IgZGF0YSkgcHJvcGVydHksIHNvIHdlIGNhbiBhZGQgdGhlIHByb3BlcnR5XG4gICAgICAvLyB0byB0aGUgaW5pdGlhbCByZWNlaXZlciBvYmplY3RcbiAgICAgIC8vICh0aGlzIGJyYW5jaCB3aWxsIGludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBjb2RlIGJlbG93KVxuICAgICAgb3duRGVzYyA9XG4gICAgICAgIHsgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIHdlIG5vdyBrbm93IHRoYXQgb3duRGVzYyAhPT0gdW5kZWZpbmVkXG4gICAgaWYgKGlzQWNjZXNzb3JEZXNjcmlwdG9yKG93bkRlc2MpKSB7XG4gICAgICB2YXIgc2V0dGVyID0gb3duRGVzYy5zZXQ7XG4gICAgICBpZiAoc2V0dGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHNldHRlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7IC8vIGFzc3VtZXMgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGlzRGF0YURlc2NyaXB0b3Iob3duRGVzYykgbXVzdCBiZSB0cnVlXG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gd2UgZm91bmQgYW4gZXhpc3Rpbmcgd3JpdGFibGUgZGF0YSBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIE5vdyB1cGRhdGUgb3IgYWRkIHRoZSBkYXRhIHByb3BlcnR5IG9uIHRoZSByZWNlaXZlciwgZGVwZW5kaW5nIG9uXG4gICAgLy8gd2hldGhlciB0aGUgcmVjZWl2ZXIgYWxyZWFkeSBkZWZpbmVzIHRoZSBwcm9wZXJ0eSBvciBub3QuXG4gICAgdmFyIGV4aXN0aW5nRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIG5hbWUpO1xuICAgIGlmIChleGlzdGluZ0Rlc2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHVwZGF0ZURlc2MgPVxuICAgICAgICB7IHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAvLyBGSVhNRTogaXQgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgdG8gZGVzY3JpYmUgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIC8vIGF0dHJpYnV0ZXMuIEFkZGVkIHRvIGNpcmN1bXZlbnQgYSBidWcgaW4gdHJhY2Vtb25rZXk6XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjAxMzI5XG4gICAgICAgICAgd3JpdGFibGU6ICAgICBleGlzdGluZ0Rlc2Mud3JpdGFibGUsXG4gICAgICAgICAgZW51bWVyYWJsZTogICBleGlzdGluZ0Rlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGV4aXN0aW5nRGVzYy5jb25maWd1cmFibGUgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgbmFtZSwgdXBkYXRlRGVzYyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5ld0Rlc2MgPVxuICAgICAgICB7IHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBuYW1lLCBuZXdEZXNjKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcbiAgLyppbnZva2U6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgYXJncywgcmVjZWl2ZXIpIHtcbiAgICByZWNlaXZlciA9IHJlY2VpdmVyIHx8IHRhcmdldDtcblxuICAgIHZhciBoYW5kbGVyID0gZGlyZWN0UHJveGllcy5nZXQodGFyZ2V0KTtcbiAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5pbnZva2UocmVjZWl2ZXIsIG5hbWUsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBmdW4gPSBSZWZsZWN0LmdldCh0YXJnZXQsIG5hbWUsIHJlY2VpdmVyKTtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoZnVuLCByZWNlaXZlciwgYXJncyk7XG4gIH0sKi9cbiAgZW51bWVyYXRlOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgaGFuZGxlciA9IGRpcmVjdFByb3hpZXMuZ2V0KHRhcmdldCk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBoYW5kbGVyLmVudW1lcmF0ZSBzaG91bGQgcmV0dXJuIGFuIGl0ZXJhdG9yIGRpcmVjdGx5LCBidXQgdGhlXG4gICAgICAvLyBpdGVyYXRvciBnZXRzIGNvbnZlcnRlZCB0byBhbiBhcnJheSBmb3IgYmFja3dhcmQtY29tcGF0IHJlYXNvbnMsXG4gICAgICAvLyBzbyB3ZSBtdXN0IHJlLWl0ZXJhdGUgb3ZlciB0aGUgYXJyYXlcbiAgICAgIHJlc3VsdCA9IGhhbmRsZXIuZW51bWVyYXRlKGhhbmRsZXIudGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkgeyByZXN1bHQucHVzaChuYW1lKTsgfTsgICAgICBcbiAgICB9XG4gICAgdmFyIGwgPSArcmVzdWx0Lmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpZHggPT09IGwpIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXN1bHRbaWR4KytdIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gaW1wZXJmZWN0IG93bktleXMgaW1wbGVtZW50YXRpb246IGluIEVTNiwgc2hvdWxkIGFsc28gaW5jbHVkZVxuICAvLyBzeW1ib2wta2V5ZWQgcHJvcGVydGllcy5cbiAgb3duS2V5czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgLy8gdGFyZ2V0LmFwcGx5KHJlY2VpdmVyLCBhcmdzKVxuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfSxcbiAgY29uc3RydWN0OiBmdW5jdGlvbih0YXJnZXQsIGFyZ3MsIG5ld1RhcmdldCkge1xuICAgIC8vIHJldHVybiBuZXcgdGFyZ2V0KC4uLmFyZ3MpO1xuXG4gICAgLy8gaWYgdGFyZ2V0IGlzIGEgcHJveHksIGludm9rZSBpdHMgXCJjb25zdHJ1Y3RcIiB0cmFwXG4gICAgdmFyIGhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldCh0YXJnZXQpO1xuICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNvbnN0cnVjdChoYW5kbGVyLnRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBpcyBub3QgYSBmdW5jdGlvbjogXCIgKyB0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAobmV3VGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgbmV3VGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIElmIG5ld1RhcmdldCBpcyB1bmRlZmluZWQsIHRoZW4gbmV3VGFyZ2V0IGlzIHNldCB0byBgdGFyZ2V0YCBhbmRcbiAgICAgIC8vIGBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIC4uLmFyZ3MpYCBiZWNvbWVzIGVxdWl2YWxlbnQgdG9cbiAgICAgIC8vIGBuZXcgdGFyZ2V0KC4uLmFyZ3MpYFxuICAgICAgLy8gaWYgYHRhcmdldGAgaXMgYW4gRVMyMDE1IENsYXNzIGNvbnN0cnVjdG9yLCBpdCBtdXN0IGJlIGNhbGxlZCB1c2luZ1xuICAgICAgLy8gdGhlIGBuZXdgIG9wZXJhdG9yLiBIZW5jZSB3ZSB1c2UgdGhlIG5ldyBvcGVyYXRvciBvbiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICAvLyB0byB0cmlnZ2VyIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC4gVGhpcyB0ZWNobmlxdWUgd2lsbCB3b3JrIFxuICAgICAgLy8gZm9yIGJvdGggcGxhaW4gY29uc3RydWN0b3IgZnVuY3Rpb25zIGFuZCBFUzIwMTUgY2xhc3Nlc1xuICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkodGFyZ2V0LCBbbnVsbF0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3VGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5ld1RhcmdldCBpcyBub3QgYSBmdW5jdGlvbjogXCIgKyB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgLy8gaWYgbmV3VGFyZ2V0IGlzIGEgKmRpZmZlcmVudCogY29uc3RydWN0b3IgZnVuY3Rpb24sIHdlIG5lZWQgdG9cbiAgICAgIC8vIGVtdWxhdGUgW1tDb25zdHJ1Y3RdXSBieSBmYWxsaW5nIGJhY2sgdG8gW1tDYWxsXV0gd2l0aCBhIGhhbmQtY3JhZnRlZFxuICAgICAgLy8gbmV3IGluc3RhbmNlIGluaGVyaXRpbmcgZnJvbSBuZXdUYXJnZXQucHJvdG90eXBlXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgd29uJ3Qgd29yayBpZiB0YXJnZXQgaXMgYW4gRVMyMDE1IENvbnN0cnVjdG9yXG4gICAgICAvLyBmdW5jdGlvbiwgd2hvc2UgW1tDYWxsXV0gbWV0aG9kIHRocm93cyBhbiBlcnJvciAoaXQgbXVzdCBiZSBpbnZva2VkXG4gICAgICAvLyB1c2luZyB0aGUgYG5ld2Agb3BlcmF0b3IpXG4gICAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gKE9iamVjdChwcm90bykgPT09IHByb3RvKSA/IE9iamVjdC5jcmVhdGUocHJvdG8pIDoge307XG4gICAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgICByZXR1cm4gT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZmVhdHVyZS10ZXN0IHdoZXRoZXIgdGhlIFJlZmxlY3QgZ2xvYmFsIGV4aXN0c1xuaWYgKGdsb2JhbC5SZWZsZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgLy8gUmVmbGVjdCBleGlzdHMsIGFkZC9vdmVycmlkZSB0aGUgc2hpbW1lZCBtZXRob2RzXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFJlZmxlY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGdsb2JhbC5SZWZsZWN0W2tleV0gPSBSZWZsZWN0W2tleV07XG4gIH0pO1xufSBlbHNlIHtcbiAgLy8gUmVmbGVjdCBkb2Vzbid0IGV4aXN0LCBkZWZpbmUgaXQgYXMgdGhlIHNoaW1tZWQgUmVmbGVjdCBvYmplY3RcbiAgZ2xvYmFsLlJlZmxlY3QgPSBSZWZsZWN0O1xufVxuXG4vLyBmZWF0dXJlLXRlc3Qgd2hldGhlciB0aGUgUHJveHkgZ2xvYmFsIGV4aXN0cywgd2l0aFxuLy8gdGhlIGhhcm1vbnktZXJhIFByb3h5LmNyZWF0ZSBBUElcbmlmICh0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgUHJveHkuY3JlYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgdmFyIHByaW1DcmVhdGUgPSBQcm94eS5jcmVhdGUsXG4gICAgICBwcmltQ3JlYXRlRnVuY3Rpb24gPSBQcm94eS5jcmVhdGVGdW5jdGlvbjtcblxuICB2YXIgcmV2b2tlZEhhbmRsZXIgPSBwcmltQ3JlYXRlKHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHJveHkgaXMgcmV2b2tlZFwiKTsgfVxuICB9KTtcblxuICBnbG9iYWwuUHJveHkgPSBmdW5jdGlvbih0YXJnZXQsIGhhbmRsZXIpIHtcbiAgICAvLyBjaGVjayB0aGF0IHRhcmdldCBpcyBhbiBPYmplY3RcbiAgICBpZiAoT2JqZWN0KHRhcmdldCkgIT09IHRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3h5IHRhcmdldCBtdXN0IGJlIGFuIE9iamVjdCwgZ2l2ZW4gXCIrdGFyZ2V0KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgdGhhdCBoYW5kbGVyIGlzIGFuIE9iamVjdFxuICAgIGlmIChPYmplY3QoaGFuZGxlcikgIT09IGhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm94eSBoYW5kbGVyIG11c3QgYmUgYW4gT2JqZWN0LCBnaXZlbiBcIitoYW5kbGVyKTtcbiAgICB9XG5cbiAgICB2YXIgdkhhbmRsZXIgPSBuZXcgVmFsaWRhdG9yKHRhcmdldCwgaGFuZGxlcik7XG4gICAgdmFyIHByb3h5O1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb3h5ID0gcHJpbUNyZWF0ZUZ1bmN0aW9uKHZIYW5kbGVyLFxuICAgICAgICAvLyBjYWxsIHRyYXBcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiB2SGFuZGxlci5hcHBseSh0YXJnZXQsIHRoaXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBjb25zdHJ1Y3QgdHJhcFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHZIYW5kbGVyLmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveHkgPSBwcmltQ3JlYXRlKHZIYW5kbGVyLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSk7XG4gICAgfVxuICAgIGRpcmVjdFByb3hpZXMuc2V0KHByb3h5LCB2SGFuZGxlcik7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuXG4gIGdsb2JhbC5Qcm94eS5yZXZvY2FibGUgPSBmdW5jdGlvbih0YXJnZXQsIGhhbmRsZXIpIHtcbiAgICB2YXIgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCBoYW5kbGVyKTtcbiAgICB2YXIgcmV2b2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdkhhbmRsZXIgPSBkaXJlY3RQcm94aWVzLmdldChwcm94eSk7XG4gICAgICBpZiAodkhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAgICAgdkhhbmRsZXIudGFyZ2V0ICA9IG51bGw7XG4gICAgICAgIHZIYW5kbGVyLmhhbmRsZXIgPSByZXZva2VkSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4ge3Byb3h5OiBwcm94eSwgcmV2b2tlOiByZXZva2V9O1xuICB9XG4gIFxuICAvLyBhZGQgdGhlIG9sZCBQcm94eS5jcmVhdGUgYW5kIFByb3h5LmNyZWF0ZUZ1bmN0aW9uIG1ldGhvZHNcbiAgLy8gc28gb2xkIGNvZGUgdGhhdCBzdGlsbCBkZXBlbmRzIG9uIHRoZSBoYXJtb255LWVyYSBQcm94eSBvYmplY3RcbiAgLy8gaXMgbm90IGJyb2tlbi4gQWxzbyBlbnN1cmVzIHRoYXQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhpc1xuICAvLyBsaWJyYXJ5IHNob3VsZCBsb2FkIGZpbmVcbiAgZ2xvYmFsLlByb3h5LmNyZWF0ZSA9IHByaW1DcmVhdGU7XG4gIGdsb2JhbC5Qcm94eS5jcmVhdGVGdW5jdGlvbiA9IHByaW1DcmVhdGVGdW5jdGlvbjtcblxufSBlbHNlIHtcbiAgLy8gUHJveHkgZ2xvYmFsIG5vdCBkZWZpbmVkLCBvciBvbGQgQVBJIG5vdCBhdmFpbGFibGVcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIFByb3h5IGdsb2JhbCBub3QgZGVmaW5lZCwgYWRkIGEgUHJveHkgZnVuY3Rpb24gc3R1YlxuICAgIGdsb2JhbC5Qcm94eSA9IGZ1bmN0aW9uKF90YXJnZXQsIF9oYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm94aWVzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybS4gT24gdjgvbm9kZS9pb2pzLCBtYWtlIHN1cmUgdG8gcGFzcyB0aGUgLS1oYXJtb255X3Byb3hpZXMgZmxhZ1wiKTtcbiAgICB9O1xuICB9XG4gIC8vIFByb3h5IGdsb2JhbCBkZWZpbmVkIGJ1dCBvbGQgQVBJIG5vdCBhdmFpbGFibGVcbiAgLy8gcHJlc3VtYWJseSBQcm94eSBnbG9iYWwgYWxyZWFkeSBzdXBwb3J0cyBuZXcgQVBJLCBsZWF2ZSB1bnRvdWNoZWRcbn1cblxuLy8gZm9yIG5vZGUuanMgbW9kdWxlcywgZXhwb3J0IGV2ZXJ5IHByb3BlcnR5IGluIHRoZSBSZWZsZWN0IG9iamVjdFxuLy8gYXMgcGFydCBvZiB0aGUgbW9kdWxlIGludGVyZmFjZVxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBPYmplY3Qua2V5cyhSZWZsZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBleHBvcnRzW2tleV0gPSBSZWZsZWN0W2tleV07XG4gIH0pO1xufVxuXG4vLyBmdW5jdGlvbi1hcy1tb2R1bGUgcGF0dGVyblxufSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0aGlzKSk7Il0sIm5hbWVzIjpbImdsb2JhbCIsIldlYWtNYXAiLCJwcm90b3R5cGUiLCJnZXQiLCJrIiwidW5kZWZpbmVkIiwic2V0IiwidiIsIkVycm9yIiwiaXNTdGFuZGFyZEF0dHJpYnV0ZSIsIm5hbWUiLCJ0ZXN0IiwidG9Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvYmoiLCJPYmplY3QiLCJUeXBlRXJyb3IiLCJkZXNjIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJpc0FjY2Vzc29yRGVzY3JpcHRvciIsImlzRGF0YURlc2NyaXB0b3IiLCJpc0dlbmVyaWNEZXNjcmlwdG9yIiwidG9Db21wbGV0ZVByb3BlcnR5RGVzY3JpcHRvciIsImludGVybmFsRGVzYyIsImlzRW1wdHlEZXNjcmlwdG9yIiwiaXNFcXVpdmFsZW50RGVzY3JpcHRvciIsImRlc2MxIiwiZGVzYzIiLCJzYW1lVmFsdWUiLCJ4IiwieSIsIm5vcm1hbGl6ZUFuZENvbXBsZXRlUHJvcGVydHlEZXNjcmlwdG9yIiwiYXR0cmlidXRlcyIsImRlZmluZVByb3BlcnR5Iiwibm9ybWFsaXplUHJvcGVydHlEZXNjcmlwdG9yIiwicHJpbV9wcmV2ZW50RXh0ZW5zaW9ucyIsInByZXZlbnRFeHRlbnNpb25zIiwicHJpbV9zZWFsIiwic2VhbCIsInByaW1fZnJlZXplIiwiZnJlZXplIiwicHJpbV9pc0V4dGVuc2libGUiLCJpc0V4dGVuc2libGUiLCJwcmltX2lzU2VhbGVkIiwiaXNTZWFsZWQiLCJwcmltX2lzRnJvemVuIiwiaXNGcm96ZW4iLCJwcmltX2dldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJwcmltX2dldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInByaW1fZGVmaW5lUHJvcGVydHkiLCJwcmltX2RlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJpbV9rZXlzIiwia2V5cyIsInByaW1fZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcmltX2dldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByaW1fYXNzaWduIiwiYXNzaWduIiwicHJpbV9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwicHJpbV9jb25jYXQiLCJjb25jYXQiLCJwcmltX2lzUHJvdG90eXBlT2YiLCJpc1Byb3RvdHlwZU9mIiwicHJpbV9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiT2JqZWN0X2lzRnJvemVuIiwiT2JqZWN0X2lzU2VhbGVkIiwiT2JqZWN0X2lzRXh0ZW5zaWJsZSIsIk9iamVjdF9nZXRQcm90b3R5cGVPZiIsIk9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzIiwiaXNGaXhlZCIsInRhcmdldCIsImNhbGwiLCJpc1NlYWxlZERlc2MiLCJpc0NvbXBhdGlibGVEZXNjcmlwdG9yIiwiZXh0ZW5zaWJsZSIsImN1cnJlbnQiLCJzZXRJbnRlZ3JpdHlMZXZlbCIsImxldmVsIiwib3duUHJvcHMiLCJwZW5kaW5nRXhjZXB0aW9uIiwibCIsImxlbmd0aCIsImkiLCJTdHJpbmciLCJlIiwiY3VycmVudERlc2MiLCJSZWZsZWN0IiwidGVzdEludGVncml0eUxldmVsIiwiVmFsaWRhdG9yIiwiaGFuZGxlciIsImdldFRyYXAiLCJ0cmFwTmFtZSIsInRyYXAiLCJ0YXJnZXREZXNjIiwiZ2V0UHJvcGVydHlEZXNjcmlwdG9yIiwiaGFzIiwidmFsIiwiZGVzY09iaiIsInN1Y2Nlc3MiLCJkZWxldGUiLCJkZWxldGVQcm9wZXJ0eSIsInJlcyIsIm93bktleXMiLCJ0cmFwUmVzdWx0IiwicHJvcE5hbWVzIiwiY3JlYXRlIiwibnVtUHJvcHMiLCJyZXN1bHQiLCJzIiwiZm9yRWFjaCIsIm93blByb3AiLCJzdGF0ZSIsImFsbGVnZWRQcm90byIsImFjdHVhbFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJuZXdQcm90byIsImdldFByb3BlcnR5TmFtZXMiLCJyZWNlaXZlciIsImZpeGVkRGVzYyIsImVudW1lcmF0ZSIsIm54dCIsIm5leHQiLCJkb25lIiwicHVzaCIsIm93bkVudW1lcmFibGVQcm9wcyIsIm93bkVudW1lcmFibGVQcm9wIiwiaXRlcmF0ZSIsImFwcGx5IiwidGhpc0JpbmRpbmciLCJhcmdzIiwiY29uc3RydWN0IiwibmV3VGFyZ2V0IiwiZGlyZWN0UHJveGllcyIsInN1YmplY3QiLCJ2aGFuZGxlciIsInZIYW5kbGVyIiwibm9ybWFsaXplZERlc2MiLCJkZXNjcyIsIm5hbWVzIiwibm9Qcm94aWVzIiwiYXJndW1lbnRzIiwib3V0cHV0IiwiaW5kZXgiLCJzb3VyY2UiLCJuZXh0S2V5IiwiaXNPYmplY3QiLCJhcmciLCJ0eXBlIiwic2FmZVdlYWtNYXBHZXQiLCJtYXAiLCJrZXkiLCJtYWtlVW53cmFwcGluZzBBcmdNZXRob2QiLCJwcmltaXRpdmUiLCJidWlsdGluIiwibWFrZVVud3JhcHBpbmcxQXJnTWV0aG9kIiwidmFsdWVPZiIsInRvU3RyaW5nIiwiRnVuY3Rpb24iLCJEYXRlIiwidkhhbmRsZXIyIiwiaXNQcm94eUFycmF5Iiwic2xpY2UiLCJwcmltX3NldFByb3RvdHlwZU9mIiwiX19wcm90b19fc2V0dGVyIiwicHJvdG9EZXNjIiwicHJvdG8iLCJvd25EZXNjIiwiZXhpc3RpbmdEZXNjIiwidXBkYXRlRGVzYyIsIm5ld0Rlc2MiLCJpZHgiLCJiaW5kIiwiaW5zdGFuY2UiLCJQcm94eSIsInByaW1DcmVhdGUiLCJwcmltQ3JlYXRlRnVuY3Rpb24iLCJjcmVhdGVGdW5jdGlvbiIsInJldm9rZWRIYW5kbGVyIiwicHJveHkiLCJyZXZvY2FibGUiLCJyZXZva2UiLCJfdGFyZ2V0IiwiX2hhbmRsZXIiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/harmony-reflect/reflect.js\n");

/***/ })

};
;
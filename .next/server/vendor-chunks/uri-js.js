/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uri-js";
exports.ids = ["vendor-chunks/uri-js"];
exports.modules = {

/***/ "(rsc)/./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function merge() {\n        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){\n            sets[_key] = arguments[_key];\n        }\n        if (sets.length > 1) {\n            sets[0] = sets[0].slice(0, -1);\n            var xl = sets.length - 1;\n            for(var x = 1; x < xl; ++x){\n                sets[x] = sets[x].slice(1, -1);\n            }\n            sets[xl] = sets[xl].slice(1);\n            return sets.join(\"\");\n        } else {\n            return sets[0];\n        }\n    }\n    function subexp(str) {\n        return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n        return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n        return str.toUpperCase();\n    }\n    function toArray(obj) {\n        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [\n            obj\n        ] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n        var obj = target;\n        if (source) {\n            for(var key in source){\n                obj[key] = source[key];\n            }\n        }\n        return obj;\n    }\n    function buildExps(isIRI) {\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), //case-insensitive\n        LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), //expanded\n        GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", //subset, excludes bidi control characters\n        IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", //subset\n        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), //relaxed parsing rules\n        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n        IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n        IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), //[ *6( h16 \":\" ) h16 ] \"::\"\n        IPV6ADDRESS$ = subexp([\n            IPV6ADDRESS1$,\n            IPV6ADDRESS2$,\n            IPV6ADDRESS3$,\n            IPV6ADDRESS4$,\n            IPV6ADDRESS5$,\n            IPV6ADDRESS6$,\n            IPV6ADDRESS7$,\n            IPV6ADDRESS8$,\n            IPV6ADDRESS9$\n        ].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"), //RFC 6874\n        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), //RFC 6874\n        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$), //RFC 6874, with relaxed parsing rules\n        IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), //RFC 6874\n        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), //simplified\n        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified\n        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified\n        PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n        return {\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n            IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n            IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n        };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                    _arr.push(_s.value);\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally{\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally{\n                    if (_d) throw _e;\n                }\n            }\n            return _arr;\n        }\n        return function(arr, i) {\n            if (Array.isArray(arr)) {\n                return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n            } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n        };\n    }();\n    var toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    };\n    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n    /** Bootstring parameters */ var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128; // 0x80\n    var delimiter = \"-\"; // '\\x2D'\n    /** Regular expressions */ var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n    /** Error messages */ var errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    };\n    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    /*--------------------------------------------------------------------------*/ /**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */ function error$1(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */ function map(array, fn) {\n        var result = [];\n        var length = array.length;\n        while(length--){\n            result[length] = fn(array[length]);\n        }\n        return result;\n    }\n    /**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */ function ucs2decode(string) {\n        var output = [];\n        var counter = 0;\n        var length = string.length;\n        while(counter < length){\n            var value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // It's a high surrogate, and there is a next character.\n                var extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                    // Low surrogate.\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // It's an unmatched surrogate; only append this code unit, in case the\n                    // next code unit is the high surrogate of a surrogate pair.\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n    /**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */ var ucs2encode = function ucs2encode(array) {\n        return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    /**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */ var basicToDigit = function basicToDigit(codePoint) {\n        if (codePoint - 0x30 < 0x0A) {\n            return codePoint - 0x16;\n        }\n        if (codePoint - 0x41 < 0x1A) {\n            return codePoint - 0x41;\n        }\n        if (codePoint - 0x61 < 0x1A) {\n            return codePoint - 0x61;\n        }\n        return base;\n    };\n    /**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */ var digitToBasic = function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    /**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */ var adapt = function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base){\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    /**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */ var decode = function decode(input) {\n        // Don't use UCS-2.\n        var output = [];\n        var inputLength = input.length;\n        var i = 0;\n        var n = initialN;\n        var bias = initialBias;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        var basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n        for(var j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error$1(\"not-basic\");\n            }\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            var oldi = i;\n            for(var w = 1, k = base;; k += base){\n                if (index >= inputLength) {\n                    error$1(\"invalid-input\");\n                }\n                var digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error$1(\"overflow\");\n                }\n                i += digit * w;\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                var baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error$1(\"overflow\");\n                }\n                w *= baseMinusT;\n            }\n            var out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error$1(\"overflow\");\n            }\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output.\n            output.splice(i++, 0, n);\n        }\n        return String.fromCodePoint.apply(String, output);\n    };\n    /**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */ var encode = function encode(input) {\n        var output = [];\n        // Convert the input in UCS-2 to an array of Unicode code points.\n        input = ucs2decode(input);\n        // Cache the length.\n        var inputLength = input.length;\n        // Initialize the state.\n        var n = initialN;\n        var delta = 0;\n        var bias = initialBias;\n        // Handle the basic code points.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _currentValue2 = _step.value;\n                if (_currentValue2 < 0x80) {\n                    output.push(stringFromCharCode(_currentValue2));\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        var basicLength = output.length;\n        var handledCPCount = basicLength;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string with a delimiter unless it's empty.\n        if (basicLength) {\n            output.push(delimiter);\n        }\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            var m = maxInt;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                    var currentValue = _step2.value;\n                    if (currentValue >= n && currentValue < m) {\n                        m = currentValue;\n                    }\n                }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow.\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally{\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n            var handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error$1(\"overflow\");\n            }\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                    var _currentValue = _step3.value;\n                    if (_currentValue < n && ++delta > maxInt) {\n                        error$1(\"overflow\");\n                    }\n                    if (_currentValue == n) {\n                        // Represent delta as a generalized variable-length integer.\n                        var q = delta;\n                        for(var k = base;; k += base){\n                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                            if (q < t) {\n                                break;\n                            }\n                            var qMinusT = q - t;\n                            var baseMinusT = base - t;\n                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                            q = floor(qMinusT / baseMinusT);\n                        }\n                        output.push(stringFromCharCode(digitToBasic(q, 0)));\n                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                        delta = 0;\n                        ++handledCPCount;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally{\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    };\n    /**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */ var toUnicode = function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    };\n    /**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */ var toASCII = function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    };\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {\n        /**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */ \"version\": \"2.1.0\",\n        /**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */ /**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */ var SCHEMES = {};\n    function pctEncChar(chr) {\n        var c = chr.charCodeAt(0);\n        var e = void 0;\n        if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n        else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n        else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        return e;\n    }\n    function pctDecChars(str) {\n        var newStr = \"\";\n        var i = 0;\n        var il = str.length;\n        while(i < il){\n            var c = parseInt(str.substr(i + 1, 2), 16);\n            if (c < 128) {\n                newStr += String.fromCharCode(c);\n                i += 3;\n            } else if (c >= 194 && c < 224) {\n                if (il - i >= 6) {\n                    var c2 = parseInt(str.substr(i + 4, 2), 16);\n                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n                } else {\n                    newStr += str.substr(i, 6);\n                }\n                i += 6;\n            } else if (c >= 224) {\n                if (il - i >= 9) {\n                    var _c = parseInt(str.substr(i + 4, 2), 16);\n                    var c3 = parseInt(str.substr(i + 7, 2), 16);\n                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n                } else {\n                    newStr += str.substr(i, 9);\n                }\n                i += 9;\n            } else {\n                newStr += str.substr(i, 3);\n                i += 3;\n            }\n        }\n        return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n        function decodeUnreserved(str) {\n            var decStr = pctDecChars(str);\n            return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n        }\n        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        return components;\n    }\n    function _stripLeadingZeros(str) {\n        return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n        var matches = host.match(protocol.IPV4ADDRESS) || [];\n        var _matches = slicedToArray(matches, 2), address = _matches[1];\n        if (address) {\n            return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n        } else {\n            return host;\n        }\n    }\n    function _normalizeIPv6(host, protocol) {\n        var matches = host.match(protocol.IPV6ADDRESS) || [];\n        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n        if (address) {\n            var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n            var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n            var lastFields = last.split(\":\").map(_stripLeadingZeros);\n            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n            var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n            var lastFieldsStart = lastFields.length - fieldCount;\n            var fields = Array(fieldCount);\n            for(var x = 0; x < fieldCount; ++x){\n                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n            }\n            if (isLastFieldIPv4Address) {\n                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n            }\n            var allZeroFields = fields.reduce(function(acc, field, index) {\n                if (!field || field === \"0\") {\n                    var lastLongest = acc[acc.length - 1];\n                    if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                        lastLongest.length++;\n                    } else {\n                        acc.push({\n                            index: index,\n                            length: 1\n                        });\n                    }\n                }\n                return acc;\n            }, []);\n            var longestZeroFields = allZeroFields.sort(function(a, b) {\n                return b.length - a.length;\n            })[0];\n            var newHost = void 0;\n            if (longestZeroFields && longestZeroFields.length > 1) {\n                var newFirst = fields.slice(0, longestZeroFields.index);\n                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n                newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n            } else {\n                newHost = fields.join(\":\");\n            }\n            if (zone) {\n                newHost += \"%\" + zone;\n            }\n            return newHost;\n        } else {\n            return host;\n        }\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var components = {};\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n        var matches = uriString.match(URI_PARSE);\n        if (matches) {\n            if (NO_MATCH_IS_UNDEFINED) {\n                //store each component\n                components.scheme = matches[1];\n                components.userinfo = matches[3];\n                components.host = matches[4];\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = matches[7];\n                components.fragment = matches[8];\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = matches[5];\n                }\n            } else {\n                //IE FIX for improper RegExp matching\n                //store each component\n                components.scheme = matches[1] || undefined;\n                components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n                components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n                components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n                }\n            }\n            if (components.host) {\n                //normalize IP hosts\n                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n            }\n            //determine reference type\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n                components.reference = \"same-document\";\n            } else if (components.scheme === undefined) {\n                components.reference = \"relative\";\n            } else if (components.fragment === undefined) {\n                components.reference = \"absolute\";\n            } else {\n                components.reference = \"uri\";\n            }\n            //check for reference errors\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n            }\n            //find scheme handler\n            var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n            //check if scheme can't handle IRIs\n            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                //if host component is a domain name\n                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                    } catch (e) {\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                }\n                //convert IRI -> URI\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\n            } else {\n                //normalize encodings\n                _normalizeComponentEncoding(components, protocol);\n            }\n            //perform scheme specific parsing\n            if (schemeHandler && schemeHandler.parse) {\n                schemeHandler.parse(components, options);\n            }\n        } else {\n            components.error = components.error || \"URI can not be parsed.\";\n        }\n        return components;\n    }\n    function _recomposeAuthority(components, options) {\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        if (components.userinfo !== undefined) {\n            uriTokens.push(components.userinfo);\n            uriTokens.push(\"@\");\n        }\n        if (components.host !== undefined) {\n            //normalize IP hosts, add brackets and escape zone separator for IPv6\n            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n                return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n            }));\n        }\n        if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n            uriTokens.push(\":\");\n            uriTokens.push(String(components.port));\n        }\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n        var output = [];\n        while(input.length){\n            if (input.match(RDS1)) {\n                input = input.replace(RDS1, \"\");\n            } else if (input.match(RDS2)) {\n                input = input.replace(RDS2, \"/\");\n            } else if (input.match(RDS3)) {\n                input = input.replace(RDS3, \"/\");\n                output.pop();\n            } else if (input === \".\" || input === \"..\") {\n                input = \"\";\n            } else {\n                var im = input.match(RDS5);\n                if (im) {\n                    var s = im[0];\n                    input = input.slice(s.length);\n                    output.push(s);\n                } else {\n                    throw new Error(\"Unexpected dot segment condition\");\n                }\n            }\n        }\n        return output.join(\"\");\n    }\n    function serialize(components) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //perform scheme specific serialization\n        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n        if (components.host) {\n            //if host component is an IPv6 address\n            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n        }\n        //normalize encoding\n        _normalizeComponentEncoding(components, protocol);\n        if (options.reference !== \"suffix\" && components.scheme) {\n            uriTokens.push(components.scheme);\n            uriTokens.push(\":\");\n        }\n        var authority = _recomposeAuthority(components, options);\n        if (authority !== undefined) {\n            if (options.reference !== \"suffix\") {\n                uriTokens.push(\"//\");\n            }\n            uriTokens.push(authority);\n            if (components.path && components.path.charAt(0) !== \"/\") {\n                uriTokens.push(\"/\");\n            }\n        }\n        if (components.path !== undefined) {\n            var s = components.path;\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n                s = removeDotSegments(s);\n            }\n            if (authority === undefined) {\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n            }\n            uriTokens.push(s);\n        }\n        if (components.query !== undefined) {\n            uriTokens.push(\"?\");\n            uriTokens.push(components.query);\n        }\n        if (components.fragment !== undefined) {\n            uriTokens.push(\"#\");\n            uriTokens.push(components.fragment);\n        }\n        return uriTokens.join(\"\"); //merge tokens into a string\n    }\n    function resolveComponents(base, relative) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var skipNormalization = arguments[3];\n        var target = {};\n        if (!skipNormalization) {\n            base = parse(serialize(base, options), options); //normalize base components\n            relative = parse(serialize(relative, options), options); //normalize relative components\n        }\n        options = options || {};\n        if (!options.tolerant && relative.scheme) {\n            target.scheme = relative.scheme;\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                //target.authority = relative.authority;\n                target.userinfo = relative.userinfo;\n                target.host = relative.host;\n                target.port = relative.port;\n                target.path = removeDotSegments(relative.path || \"\");\n                target.query = relative.query;\n            } else {\n                if (!relative.path) {\n                    target.path = base.path;\n                    if (relative.query !== undefined) {\n                        target.query = relative.query;\n                    } else {\n                        target.query = base.query;\n                    }\n                } else {\n                    if (relative.path.charAt(0) === \"/\") {\n                        target.path = removeDotSegments(relative.path);\n                    } else {\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                            target.path = \"/\" + relative.path;\n                        } else if (!base.path) {\n                            target.path = relative.path;\n                        } else {\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                        }\n                        target.path = removeDotSegments(target.path);\n                    }\n                    target.query = relative.query;\n                }\n                //target.authority = base.authority;\n                target.userinfo = base.userinfo;\n                target.host = base.host;\n                target.port = base.port;\n            }\n            target.scheme = base.scheme;\n        }\n        target.fragment = relative.fragment;\n        return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n        var schemelessOptions = assign({\n            scheme: \"null\"\n        }, options);\n        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n        if (typeof uri === \"string\") {\n            uri = serialize(parse(uri, options), options);\n        } else if (typeOf(uri) === \"object\") {\n            uri = parse(serialize(uri, options), options);\n        }\n        return uri;\n    }\n    function equal(uriA, uriB, options) {\n        if (typeof uriA === \"string\") {\n            uriA = serialize(parse(uriA, options), options);\n        } else if (typeOf(uriA) === \"object\") {\n            uriA = serialize(uriA, options);\n        }\n        if (typeof uriB === \"string\") {\n            uriB = serialize(parse(uriB, options), options);\n        } else if (typeOf(uriB) === \"object\") {\n            uriB = serialize(uriB, options);\n        }\n        return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n        scheme: \"http\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            //report missing host\n            if (!components.host) {\n                components.error = components.error || \"HTTP URIs must have a host.\";\n            }\n            return components;\n        },\n        serialize: function serialize(components, options) {\n            var secure = String(components.scheme).toLowerCase() === \"https\";\n            //normalize the default port\n            if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n                components.port = undefined;\n            }\n            //normalize the empty path\n            if (!components.path) {\n                components.path = \"/\";\n            }\n            //NOTE: We do not parse query strings for HTTP URIs\n            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n            //and not the HTTP spec.\n            return components;\n        }\n    };\n    var handler$1 = {\n        scheme: \"https\",\n        domainHost: handler.domainHost,\n        parse: handler.parse,\n        serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n        return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    //RFC 6455\n    var handler$2 = {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            var wsComponents = components;\n            //indicate if the secure flag is set\n            wsComponents.secure = isSecure(wsComponents);\n            //construct resouce name\n            wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n            wsComponents.path = undefined;\n            wsComponents.query = undefined;\n            return wsComponents;\n        },\n        serialize: function serialize(wsComponents, options) {\n            //normalize the default port\n            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n                wsComponents.port = undefined;\n            }\n            //ensure scheme matches secure flag\n            if (typeof wsComponents.secure === \"boolean\") {\n                wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n                wsComponents.secure = undefined;\n            }\n            //reconstruct path from resource name\n            if (wsComponents.resourceName) {\n                var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n                wsComponents.path = path && path !== \"/\" ? path : undefined;\n                wsComponents.query = query;\n                wsComponents.resourceName = undefined;\n            }\n            //forbid fragment component\n            wsComponents.fragment = undefined;\n            return wsComponents;\n        }\n    };\n    var handler$3 = {\n        scheme: \"wss\",\n        domainHost: handler$2.domainHost,\n        parse: handler$2.parse,\n        serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    //RFC 3986\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n    //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n    //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n    //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n    //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n    //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n    //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, '[\\\\\"\\\\\\\\]');\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n        scheme: \"mailto\",\n        parse: function parse$$1(components, options) {\n            var mailtoComponents = components;\n            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n            mailtoComponents.path = undefined;\n            if (mailtoComponents.query) {\n                var unknownHeaders = false;\n                var headers = {};\n                var hfields = mailtoComponents.query.split(\"&\");\n                for(var x = 0, xl = hfields.length; x < xl; ++x){\n                    var hfield = hfields[x].split(\"=\");\n                    switch(hfield[0]){\n                        case \"to\":\n                            var toAddrs = hfield[1].split(\",\");\n                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){\n                                to.push(toAddrs[_x]);\n                            }\n                            break;\n                        case \"subject\":\n                            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                            break;\n                        case \"body\":\n                            mailtoComponents.body = unescapeComponent(hfield[1], options);\n                            break;\n                        default:\n                            unknownHeaders = true;\n                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                            break;\n                    }\n                }\n                if (unknownHeaders) mailtoComponents.headers = headers;\n            }\n            mailtoComponents.query = undefined;\n            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){\n                var addr = to[_x2].split(\"@\");\n                addr[0] = unescapeComponent(addr[0]);\n                if (!options.unicodeSupport) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                    } catch (e) {\n                        mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                } else {\n                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n                }\n                to[_x2] = addr.join(\"@\");\n            }\n            return mailtoComponents;\n        },\n        serialize: function serialize$$1(mailtoComponents, options) {\n            var components = mailtoComponents;\n            var to = toArray(mailtoComponents.to);\n            if (to) {\n                for(var x = 0, xl = to.length; x < xl; ++x){\n                    var toAddr = String(to[x]);\n                    var atIdx = toAddr.lastIndexOf(\"@\");\n                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                    var domain = toAddr.slice(atIdx + 1);\n                    //convert IDN via punycode\n                    try {\n                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                    } catch (e) {\n                        components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                    }\n                    to[x] = localPart + \"@\" + domain;\n                }\n                components.path = to.join(\",\");\n            }\n            var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n            if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n            if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n            var fields = [];\n            for(var name in headers){\n                if (headers[name] !== O[name]) {\n                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n                }\n            }\n            if (fields.length) {\n                components.query = fields.join(\"&\");\n            }\n            return components;\n        }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    //RFC 2141\n    var handler$5 = {\n        scheme: \"urn\",\n        parse: function parse$$1(components, options) {\n            var matches = components.path && components.path.match(URN_PARSE);\n            var urnComponents = components;\n            if (matches) {\n                var scheme = options.scheme || urnComponents.scheme || \"urn\";\n                var nid = matches[1].toLowerCase();\n                var nss = matches[2];\n                var urnScheme = scheme + \":\" + (options.nid || nid);\n                var schemeHandler = SCHEMES[urnScheme];\n                urnComponents.nid = nid;\n                urnComponents.nss = nss;\n                urnComponents.path = undefined;\n                if (schemeHandler) {\n                    urnComponents = schemeHandler.parse(urnComponents, options);\n                }\n            } else {\n                urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n            }\n            return urnComponents;\n        },\n        serialize: function serialize$$1(urnComponents, options) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = urnComponents.nid;\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            if (schemeHandler) {\n                urnComponents = schemeHandler.serialize(urnComponents, options);\n            }\n            var uriComponents = urnComponents;\n            var nss = urnComponents.nss;\n            uriComponents.path = (nid || options.nid) + \":\" + nss;\n            return uriComponents;\n        }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    //RFC 4122\n    var handler$6 = {\n        scheme: \"urn:uuid\",\n        parse: function parse(urnComponents, options) {\n            var uuidComponents = urnComponents;\n            uuidComponents.uuid = uuidComponents.nss;\n            uuidComponents.nss = undefined;\n            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n                uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n            }\n            return uuidComponents;\n        },\n        serialize: function serialize(uuidComponents, options) {\n            var urnComponents = uuidComponents;\n            //normalize UUID\n            urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n            return urnComponents;\n        }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports1.SCHEMES = SCHEMES;\n    exports1.pctEncChar = pctEncChar;\n    exports1.pctDecChars = pctDecChars;\n    exports1.parse = parse;\n    exports1.removeDotSegments = removeDotSegments;\n    exports1.serialize = serialize;\n    exports1.resolveComponents = resolveComponents;\n    exports1.resolve = resolve;\n    exports1.normalize = normalize;\n    exports1.equal = equal;\n    exports1.escapeComponent = escapeComponent;\n    exports1.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=uri.all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQTRGLEdBQzNGLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN6QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUN3QztBQUN6QyxHQUFFLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFOUIsU0FBU0s7UUFDTCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBT0MsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQ2pGRixJQUFJLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO1FBQ2hDO1FBRUEsSUFBSUYsS0FBS0QsTUFBTSxHQUFHLEdBQUc7WUFDakJDLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDNUIsSUFBSUMsS0FBS0osS0FBS0QsTUFBTSxHQUFHO1lBQ3ZCLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJRCxJQUFJLEVBQUVDLEVBQUc7Z0JBQ3pCTCxJQUFJLENBQUNLLEVBQUUsR0FBR0wsSUFBSSxDQUFDSyxFQUFFLENBQUNGLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDaEM7WUFDQUgsSUFBSSxDQUFDSSxHQUFHLEdBQUdKLElBQUksQ0FBQ0ksR0FBRyxDQUFDRCxLQUFLLENBQUM7WUFDMUIsT0FBT0gsS0FBS00sSUFBSSxDQUFDO1FBQ3JCLE9BQU87WUFDSCxPQUFPTixJQUFJLENBQUMsRUFBRTtRQUNsQjtJQUNKO0lBQ0EsU0FBU08sT0FBT0MsR0FBRztRQUNmLE9BQU8sUUFBUUEsTUFBTTtJQUN6QjtJQUNBLFNBQVNDLE9BQU9DLENBQUM7UUFDYixPQUFPQSxNQUFNQyxZQUFZLGNBQWNELE1BQU0sT0FBTyxTQUFTRSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTCxHQUFH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LFVBQVVyRixNQUFNLENBQUMsR0FBR3FGO0lBQzVCeEcsT0FBTyxDQUFDMkcsVUFBVXhGLE1BQU0sQ0FBQyxHQUFHd0Y7SUFDNUIzRyxPQUFPLENBQUMrRyxVQUFVNUYsTUFBTSxDQUFDLEdBQUc0RjtJQUM1Qi9HLE9BQU8sQ0FBQ3dILFVBQVVyRyxNQUFNLENBQUMsR0FBR3FHO0lBQzVCeEgsT0FBTyxDQUFDK0ksVUFBVTVILE1BQU0sQ0FBQyxHQUFHNEg7SUFDNUIvSSxPQUFPLENBQUNzSixVQUFVbkksTUFBTSxDQUFDLEdBQUdtSTtJQUU1QmpZLFNBQVEyTyxPQUFPLEdBQUdBO0lBQ2xCM08sU0FBUTRPLFVBQVUsR0FBR0E7SUFDckI1TyxTQUFRZ1AsV0FBVyxHQUFHQTtJQUN0QmhQLFNBQVFxUyxLQUFLLEdBQUdBO0lBQ2hCclMsU0FBUTBULGlCQUFpQixHQUFHQTtJQUM1QjFULFNBQVE4VCxTQUFTLEdBQUdBO0lBQ3BCOVQsU0FBUWtVLGlCQUFpQixHQUFHQTtJQUM1QmxVLFNBQVFzVSxPQUFPLEdBQUdBO0lBQ2xCdFUsU0FBUTBVLFNBQVMsR0FBR0E7SUFDcEIxVSxTQUFRNFUsS0FBSyxHQUFHQTtJQUNoQjVVLFNBQVErVSxlQUFlLEdBQUdBO0lBQzFCL1UsU0FBUWdWLGlCQUFpQixHQUFHQTtJQUU1QjNULE9BQU8rVyxjQUFjLENBQUNwWSxVQUFTLGNBQWM7UUFBRXFJLE9BQU87SUFBSztBQUUzRCxJQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanM/ZTdmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgVVJJLmpzIHY0LjQuMSAoYykgMjAxMSBHYXJ5IENvdXJ0LiBMaWNlbnNlOiBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuVVJJID0gZ2xvYmFsLlVSSSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHNbMF0gPSBzZXRzWzBdLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIHhsID0gc2V0cy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgIHNldHNbeF0gPSBzZXRzW3hdLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gc2V0cy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0c1swXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJleHAoc3RyKSB7XG4gICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiBvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikgOiBbXTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBvYmogPSB0YXJnZXQ7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSSkge1xuICAgIHZhciBBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuICAgICAgICBDUiQgPSBcIltcXFxceDBEXVwiLFxuICAgICAgICBESUdJVCQkID0gXCJbMC05XVwiLFxuICAgICAgICBEUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG4gICAgICAgIEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSxcbiAgICAgICAgLy9jYXNlLWluc2Vuc2l0aXZlXG4gICAgTEYkJCA9IFwiW1xcXFx4MEFdXCIsXG4gICAgICAgIFNQJCQgPSBcIltcXFxceDIwXVwiLFxuICAgICAgICBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksXG4gICAgICAgIC8vZXhwYW5kZWRcbiAgICBHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcbiAgICAgICAgU1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcbiAgICAgICAgUkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcbiAgICAgICAgVUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0XG4gICAgVU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG4gICAgICAgIFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG4gICAgICAgIFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcbiAgICAgICAgREVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG4gICAgICAgIERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksXG4gICAgICAgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG4gICAgICAgIEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuICAgICAgICBMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuICAgICAgICBJUFY2QUREUkVTUzEkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMiQgPSBzdWJleHAoXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQgKyBcIlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQpLFxuICAgICAgICAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgSVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIpLFxuICAgICAgICAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgIElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuICAgICAgICBaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcbiAgICAgICAgSVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcbiAgICAgICAgSE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcbiAgICAgICAgUE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcbiAgICAgICAgQVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG4gICAgICAgIFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG4gICAgICAgIFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcbiAgICAgICAgU0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuICAgICAgICBTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcbiAgICAgICAgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuICAgICAgICBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG4gICAgICAgIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcbiAgICAgICAgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG4gICAgICAgIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuICAgICAgICBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG4gICAgICAgIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTk9UX1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG4gICAgICAgIE5PVF9VU0VSSU5GTzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIX05PU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9GUkFHTUVOVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcbiAgICAgICAgRVNDQVBFOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuICAgICAgICBPVEhFUl9DSEFSUzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcbiAgICAgICAgUENUX0VOQ09ERUQ6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG4gICAgICAgIElQVjRBRERSRVNTOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG4gICAgICAgIElQVjZBRERSRVNTOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIH07XG59XG52YXIgVVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKGZhbHNlKTtcblxudmFyIElSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyh0cnVlKTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cbi8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbnZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG52YXIgZXJyb3JzID0ge1xuXHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcblxuLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yJDEodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gKiBhZGRyZXNzZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICogY2hhcmFjdGVyLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0dmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuXHRcdFx0XHQvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG52YXIgdWNzMmVuY29kZSA9IGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xudmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkYXB0ID0gZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdHZhciBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKDsgLyogbm8gaW5pdGlhbGl6YXRpb24gKi9kZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdHZhciBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdGlmIChiYXNpYyA8IDApIHtcblx0XHRiYXNpYyA9IDA7XG5cdH1cblxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRlcnJvciQxKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yICh2YXIgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOykgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL3tcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0dmFyIG9sZGkgPSBpO1xuXHRcdGZvciAodmFyIHcgPSAxLCBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IkMSgnaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cdFx0fVxuXG5cdFx0dmFyIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgb3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBkZWx0YSA9IDA7XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZTIgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKF9jdXJyZW50VmFsdWUyIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoX2N1cnJlbnRWYWx1ZTIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0dmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0dmFyIG0gPSBtYXhJbnQ7XG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBfY3VycmVudFZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG5cdFx0XHRcdFx0dmFyIHEgPSBkZWx0YTtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG52YXIgdG9Vbmljb2RlID0gZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbnZhciB0b0FTQ0lJID0gZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbnZhciBwdW55Y29kZSA9IHtcblx0LyoqXG4gICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIFN0cmluZ1xuICAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBPYmplY3RcbiAgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG4vKipcbiAqIFVSSS5qc1xuICpcbiAqIEBmaWxlb3ZlcnZpZXcgQW4gUkZDIDM5ODYgY29tcGxpYW50LCBzY2hlbWUgZXh0ZW5kYWJsZSBVUkkgcGFyc2luZy92YWxpZGF0aW5nL3Jlc29sdmluZyBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cbiAqIEBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xuICovXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cbnZhciBTQ0hFTUVTID0ge307XG5mdW5jdGlvbiBwY3RFbmNDaGFyKGNocikge1xuICAgIHZhciBjID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGUgPSB2b2lkIDA7XG4gICAgaWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDEyOCkgZSA9IFwiJVwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKGMgPj4gNiB8IDE5MikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgZSA9IFwiJVwiICsgKGMgPj4gMTIgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyA+PiA2ICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cikge1xuICAgIHZhciBuZXdTdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaWwgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgaWwpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgYzIgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoX2MgJiA2MykgPDwgNiB8IGMzICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdHI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpIHtcbiAgICBmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgICAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICAgICAgcmV0dXJuICFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1VTRVJJTkZPLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoY29tcG9uZW50cy5zY2hlbWUgPyBwcm90b2NvbC5OT1RfUEFUSCA6IHByb3RvY29sLk5PVF9QQVRIX05PU0NIRU1FLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2NChob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDIpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXNbMV07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNkFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzMiA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMyksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlczJbMV0sXG4gICAgICAgIHpvbmUgPSBfbWF0Y2hlczJbMl07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgX2FkZHJlc3MkdG9Mb3dlckNhc2UkID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCc6OicpLnJldmVyc2UoKSxcbiAgICAgICAgICAgIF9hZGRyZXNzJHRvTG93ZXJDYXNlJDIgPSBzbGljZWRUb0FycmF5KF9hZGRyZXNzJHRvTG93ZXJDYXNlJCwgMiksXG4gICAgICAgICAgICBsYXN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlswXSxcbiAgICAgICAgICAgIGZpcnN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlsxXTtcblxuICAgICAgICB2YXIgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuICAgICAgICB2YXIgbGFzdEZpZWxkcyA9IGxhc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpO1xuICAgICAgICB2YXIgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdmFyIGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG4gICAgICAgIHZhciBsYXN0RmllbGRzU3RhcnQgPSBsYXN0RmllbGRzLmxlbmd0aCAtIGZpZWxkQ291bnQ7XG4gICAgICAgIHZhciBmaWVsZHMgPSBBcnJheShmaWVsZENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcbiAgICAgICAgICAgIGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFplcm9GaWVsZHMgPSBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExvbmdlc3QubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goeyBpbmRleDogaW5kZXgsIGxlbmd0aDogMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHZhciBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICB2YXIgbmV3SG9zdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCk7XG4gICAgICAgICAgICB2YXIgbmV3TGFzdCA9IGZpZWxkcy5zbGljZShsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCArIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdIb3N0ID0gbmV3Rmlyc3Quam9pbihcIjpcIikgKyBcIjo6XCIgKyBuZXdMYXN0LmpvaW4oXCI6XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgbmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxudmFyIFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xudmFyIE5PX01BVENIX0lTX1VOREVGSU5FRCA9IFwiXCIubWF0Y2goLygpezB9LylbMV0gPT09IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIikgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuICAgIHZhciBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL0lFIEZJWCBmb3IgaW1wcm9wZXIgUmVnRXhwIG1hdGNoaW5nXG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHNcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwic2FtZS1kb2N1bWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwidXJpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udmVydCBJUkkgLT4gVVJJXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIGVuY29kaW5nc1xuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIkBcIik7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIjtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKFwiXCIpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgUkRTMSA9IC9eXFwuXFwuP1xcLy87XG52YXIgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG52YXIgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG52YXIgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpLztcbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG4gICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuICAgICAgICAgICAgaWYgKGltKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpbVswXTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG4gICAgICAgIGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHt9XG4gICAgICAgIC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblxuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy9ub3JtYWxpemUgZW5jb2RpbmdcbiAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICB9XG4gICAgdmFyIGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi9cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzID0gY29tcG9uZW50cy5wYXRoO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAvL2Rvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2gocyk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI/XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIiNcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7IC8vbWVyZ2UgdG9rZW5zIGludG8gYSBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZSwgcmVsYXRpdmUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNraXBOb3JtYWxpemF0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgICAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZTtcbiAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgfVxuICAgIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2NoZW1lbGVzc09wdGlvbnMgPSBhc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmkgPSBwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZSh1cmlBLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUocGFyc2UodXJpQiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUodXJpQiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmlBID09PSB1cmlCO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFLCBwY3RFbmNDaGFyKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpO1xufVxuXG52YXIgaGFuZGxlciA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cFwiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9yZXBvcnQgbWlzc2luZyBob3N0XG4gICAgICAgIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHBzXCI7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9OT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gICAgICAgIC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gICAgICAgIC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQxID0ge1xuICAgIHNjaGVtZTogXCJodHRwc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlci5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIuc2VyaWFsaXplXG59O1xuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbn1cbi8vUkZDIDY0NTVcbnZhciBoYW5kbGVyJDIgPSB7XG4gICAgc2NoZW1lOiBcIndzXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgd3NDb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgLy9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpO1xuICAgICAgICAvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHdzQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gICAgICAgIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gd3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIF93c0NvbXBvbmVudHMkcmVzb3VyYyA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKSxcbiAgICAgICAgICAgICAgICBfd3NDb21wb25lbnRzJHJlc291cmMyID0gc2xpY2VkVG9BcnJheShfd3NDb21wb25lbnRzJHJlc291cmMsIDIpLFxuICAgICAgICAgICAgICAgIHBhdGggPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlsxXTtcblxuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSBwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gICAgICAgIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQzID0ge1xuICAgIHNjaGVtZTogXCJ3c3NcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyJDIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlciQyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlciQyLnNlcmlhbGl6ZVxufTtcblxudmFyIE8gPSB7fTtcbnZhciBpc0lSSSA9IHRydWU7XG4vL1JGQyAzOTg2XG52YXIgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xudmFyIEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiOyAvL2Nhc2UtaW5zZW5zaXRpdmVcbnZhciBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7IC8vZXhwYW5kZWRcbi8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPVxuLy9jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC9cXFxcPVxcXFw/XFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RVEVYVCQkID0gXCJbXFxcXHgwMS1cXFxceDA4XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGXVwiOyAgLy8oJWQxLTggLyAlZDExLTEyIC8gJWQxNC0zMSAvICVkMTI3KVxuLy9jb25zdCBRVEVYVCQkID0gbWVyZ2UoXCJbXFxcXHgyMVxcXFx4MjMtXFxcXHg1QlxcXFx4NUQtXFxcXHg3RV1cIiwgT0JTX1FURVhUJCQpOyAgLy8lZDMzIC8gJWQzNS05MSAvICVkOTMtMTI2IC8gb2JzLXF0ZXh0XG4vL2NvbnN0IFZDSEFSJCQgPSBcIltcXFxceDIxLVxcXFx4N0VdXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RUCQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgbWVyZ2UoXCJbXFxcXHgwMFxcXFx4MERcXFxceDBBXVwiLCBPQlNfUVRFWFQkJCkpOyAgLy8lZDAgLyBDUiAvIExGIC8gb2JzLXF0ZXh0XG4vL2NvbnN0IEZXUyQgPSBzdWJleHAoc3ViZXhwKFdTUCQkICsgXCIqXCIgKyBcIlxcXFx4MERcXFxceDBBXCIpICsgXCI/XCIgKyBXU1AkJCArIFwiK1wiKTtcbi8vY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKHN1YmV4cChcIlxcXFxcXFxcXCIgKyBzdWJleHAoVkNIQVIkJCArIFwifFwiICsgV1NQJCQpKSArIFwifFwiICsgT0JTX1FQJCk7XG4vL2NvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgc3ViZXhwKEZXUyQgKyBcIj9cIiArIFFDT05URU5UJCkgKyBcIipcIiArIEZXUyQgKyBcIj9cIiArICdcXFxcXCInKTtcbnZhciBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbnZhciBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG52YXIgVkNIQVIkJCA9IG1lcmdlKFFURVhUJCQsIFwiW1xcXFxcXFwiXFxcXFxcXFxdXCIpO1xudmFyIFNPTUVfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcOlxcXFxAXVwiO1xudmFyIFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xudmFyIFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbnZhciBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG52YXIgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgcmV0dXJuICFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG59XG52YXIgaGFuZGxlciQ0ID0ge1xuICAgIHNjaGVtZTogXCJtYWlsdG9cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSBtYWlsdG9Db21wb25lbnRzLnBhdGggPyBtYWlsdG9Db21wb25lbnRzLnBhdGguc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcbiAgICAgICAgICAgIHZhciB1bmtub3duSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBoZmllbGRzID0gbWFpbHRvQ29tcG9uZW50cy5xdWVyeS5zcGxpdChcIiZcIik7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZmllbGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfeCA9IDAsIF94bCA9IHRvQWRkcnMubGVuZ3RoOyBfeCA8IF94bDsgKytfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLnB1c2godG9BZGRyc1tfeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLnN1YmplY3QgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBfeDIgPSAwLCBfeGwyID0gdG8ubGVuZ3RoOyBfeDIgPCBfeGwyOyArK194Mikge1xuICAgICAgICAgICAgdmFyIGFkZHIgPSB0b1tfeDJdLnNwbGl0KFwiQFwiKTtcbiAgICAgICAgICAgIGFkZHJbMF0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzBdKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1tfeDJdID0gYWRkci5qb2luKFwiQFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKG1haWx0b0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcbiAgICAgICAgICAgICAgICB2YXIgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBhcnQgPSB0b0FkZHIuc2xpY2UoMCwgYXRJZHgpLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBwY3RFbmNDaGFyKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzW25hbWVdICE9PSBPW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArIFwiPVwiICsgaGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuLy9SRkMgMjE0MVxudmFyIGhhbmRsZXIkNSA9IHtcbiAgICBzY2hlbWU6IFwidXJuXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICAgICAgdmFyIG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBuc3MgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubmlkID0gbmlkO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSBuc3M7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICB2YXIgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG4gICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHZhciBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcbiAgICAgICAgdXJpQ29tcG9uZW50cy5wYXRoID0gKG5pZCB8fCBvcHRpb25zLm5pZCkgKyBcIjpcIiArIG5zcztcbiAgICAgICAgcmV0dXJuIHVyaUNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG4vL1JGQyA0MTIyXG52YXIgaGFuZGxlciQ2ID0ge1xuICAgIHNjaGVtZTogXCJ1cm46dXVpZFwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcbiAgICAgICAgICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXVpZENvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh1dWlkQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzO1xuICAgICAgICAvL25vcm1hbGl6ZSBVVUlEXG4gICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfVxufTtcblxuU0NIRU1FU1toYW5kbGVyLnNjaGVtZV0gPSBoYW5kbGVyO1xuU0NIRU1FU1toYW5kbGVyJDEuc2NoZW1lXSA9IGhhbmRsZXIkMTtcblNDSEVNRVNbaGFuZGxlciQyLnNjaGVtZV0gPSBoYW5kbGVyJDI7XG5TQ0hFTUVTW2hhbmRsZXIkMy5zY2hlbWVdID0gaGFuZGxlciQzO1xuU0NIRU1FU1toYW5kbGVyJDQuc2NoZW1lXSA9IGhhbmRsZXIkNDtcblNDSEVNRVNbaGFuZGxlciQ1LnNjaGVtZV0gPSBoYW5kbGVyJDU7XG5TQ0hFTUVTW2hhbmRsZXIkNi5zY2hlbWVdID0gaGFuZGxlciQ2O1xuXG5leHBvcnRzLlNDSEVNRVMgPSBTQ0hFTUVTO1xuZXhwb3J0cy5wY3RFbmNDaGFyID0gcGN0RW5jQ2hhcjtcbmV4cG9ydHMucGN0RGVjQ2hhcnMgPSBwY3REZWNDaGFycztcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50cyA9IHJlc29sdmVDb21wb25lbnRzO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lc2NhcGVDb21wb25lbnQgPSBlc2NhcGVDb21wb25lbnQ7XG5leHBvcnRzLnVuZXNjYXBlQ29tcG9uZW50ID0gdW5lc2NhcGVDb21wb25lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuYWxsLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiVVJJIiwibWVyZ2UiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2V0cyIsIkFycmF5IiwiX2tleSIsInNsaWNlIiwieGwiLCJ4Iiwiam9pbiIsInN1YmV4cCIsInN0ciIsInR5cGVPZiIsIm8iLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzcGxpdCIsInBvcCIsInNoaWZ0IiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsInRvQXJyYXkiLCJvYmoiLCJzZXRJbnRlcnZhbCIsImFzc2lnbiIsInRhcmdldCIsInNvdXJjZSIsImtleSIsImJ1aWxkRXhwcyIsImlzSVJJIiwiQUxQSEEkJCIsIkNSJCIsIkRJR0lUJCQiLCJEUVVPVEUkJCIsIkhFWERJRyQkIiwiTEYkJCIsIlNQJCQiLCJQQ1RfRU5DT0RFRCQiLCJHRU5fREVMSU1TJCQiLCJTVUJfREVMSU1TJCQiLCJSRVNFUlZFRCQkIiwiVUNTQ0hBUiQkIiwiSVBSSVZBVEUkJCIsIlVOUkVTRVJWRUQkJCIsIlNDSEVNRSQiLCJVU0VSSU5GTyQiLCJERUNfT0NURVQkIiwiREVDX09DVEVUX1JFTEFYRUQkIiwiSVBWNEFERFJFU1MkIiwiSDE2JCIsIkxTMzIkIiwiSVBWNkFERFJFU1MxJCIsIklQVjZBRERSRVNTMiQiLCJJUFY2QUREUkVTUzMkIiwiSVBWNkFERFJFU1M0JCIsIklQVjZBRERSRVNTNSQiLCJJUFY2QUREUkVTUzYkIiwiSVBWNkFERFJFU1M3JCIsIklQVjZBRERSRVNTOCQiLCJJUFY2QUREUkVTUzkkIiwiSVBWNkFERFJFU1MkIiwiWk9ORUlEJCIsIklQVjZBRERSWiQiLCJJUFY2QUREUlpfUkVMQVhFRCQiLCJJUFZGVVRVUkUkIiwiSVBfTElURVJBTCQiLCJSRUdfTkFNRSQiLCJIT1NUJCIsIlBPUlQkIiwiQVVUSE9SSVRZJCIsIlBDSEFSJCIsIlNFR01FTlQkIiwiU0VHTUVOVF9OWiQiLCJTRUdNRU5UX05aX05DJCIsIlBBVEhfQUJFTVBUWSQiLCJQQVRIX0FCU09MVVRFJCIsIlBBVEhfTk9TQ0hFTUUkIiwiUEFUSF9ST09UTEVTUyQiLCJQQVRIX0VNUFRZJCIsIlBBVEgkIiwiUVVFUlkkIiwiRlJBR01FTlQkIiwiSElFUl9QQVJUJCIsIlVSSSQiLCJSRUxBVElWRV9QQVJUJCIsIlJFTEFUSVZFJCIsIlVSSV9SRUZFUkVOQ0UkIiwiQUJTT0xVVEVfVVJJJCIsIkdFTkVSSUNfUkVGJCIsIlJFTEFUSVZFX1JFRiQiLCJBQlNPTFVURV9SRUYkIiwiU0FNRURPQ19SRUYkIiwiQVVUSE9SSVRZX1JFRiQiLCJOT1RfU0NIRU1FIiwiUmVnRXhwIiwiTk9UX1VTRVJJTkZPIiwiTk9UX0hPU1QiLCJOT1RfUEFUSCIsIk5PVF9QQVRIX05PU0NIRU1FIiwiTk9UX1FVRVJZIiwiTk9UX0ZSQUdNRU5UIiwiRVNDQVBFIiwiVU5SRVNFUlZFRCIsIk9USEVSX0NIQVJTIiwiUENUX0VOQ09ERUQiLCJJUFY0QUREUkVTUyIsIklQVjZBRERSRVNTIiwiVVJJX1BST1RPQ09MIiwiSVJJX1BST1RPQ09MIiwic2xpY2VkVG9BcnJheSIsInNsaWNlSXRlcmF0b3IiLCJhcnIiLCJpIiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcyIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsIlR5cGVFcnJvciIsInRvQ29uc3VtYWJsZUFycmF5IiwiYXJyMiIsImZyb20iLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJmbG9vciIsIk1hdGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJlcnJvciQxIiwidHlwZSIsIlJhbmdlRXJyb3IiLCJtYXAiLCJhcnJheSIsImZuIiwicmVzdWx0IiwibWFwRG9tYWluIiwic3RyaW5nIiwicGFydHMiLCJyZXBsYWNlIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiY2hhckNvZGVBdCIsImV4dHJhIiwidWNzMmVuY29kZSIsImZyb21Db2RlUG9pbnQiLCJhcHBseSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJrIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm4iLCJiaWFzIiwiYmFzaWMiLCJsYXN0SW5kZXhPZiIsImoiLCJpbmRleCIsIm9sZGkiLCJ3IiwidCIsImJhc2VNaW51c1QiLCJvdXQiLCJzcGxpY2UiLCJlbmNvZGUiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9zdGVwIiwiX2N1cnJlbnRWYWx1ZTIiLCJyZXR1cm4iLCJiYXNpY0xlbmd0aCIsImhhbmRsZWRDUENvdW50IiwibSIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yIiwiX2RpZEl0ZXJhdG9yRXJyb3IyIiwiX2l0ZXJhdG9yRXJyb3IyIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zIiwiX2RpZEl0ZXJhdG9yRXJyb3IzIiwiX2l0ZXJhdG9yRXJyb3IzIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsIl9jdXJyZW50VmFsdWUiLCJxIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRlc3QiLCJ0b0FTQ0lJIiwicHVueWNvZGUiLCJTQ0hFTUVTIiwicGN0RW5jQ2hhciIsImNociIsImMiLCJlIiwicGN0RGVjQ2hhcnMiLCJuZXdTdHIiLCJpbCIsInBhcnNlSW50Iiwic3Vic3RyIiwiYzIiLCJfYyIsImMzIiwiX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIiwiY29tcG9uZW50cyIsInByb3RvY29sIiwiZGVjb2RlVW5yZXNlcnZlZCIsImRlY1N0ciIsIm1hdGNoIiwic2NoZW1lIiwidXNlcmluZm8iLCJob3N0IiwicGF0aCIsInF1ZXJ5IiwiZnJhZ21lbnQiLCJfc3RyaXBMZWFkaW5nWmVyb3MiLCJfbm9ybWFsaXplSVB2NCIsIm1hdGNoZXMiLCJfbWF0Y2hlcyIsImFkZHJlc3MiLCJfbm9ybWFsaXplSVB2NiIsIl9tYXRjaGVzMiIsInpvbmUiLCJfYWRkcmVzcyR0b0xvd2VyQ2FzZSQiLCJyZXZlcnNlIiwiX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiIsImxhc3QiLCJmaXJzdCIsImZpcnN0RmllbGRzIiwibGFzdEZpZWxkcyIsImlzTGFzdEZpZWxkSVB2NEFkZHJlc3MiLCJmaWVsZENvdW50IiwibGFzdEZpZWxkc1N0YXJ0IiwiZmllbGRzIiwiYWxsWmVyb0ZpZWxkcyIsInJlZHVjZSIsImFjYyIsImZpZWxkIiwibGFzdExvbmdlc3QiLCJsb25nZXN0WmVyb0ZpZWxkcyIsInNvcnQiLCJhIiwiYiIsIm5ld0hvc3QiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJVUklfUEFSU0UiLCJOT19NQVRDSF9JU19VTkRFRklORUQiLCJwYXJzZSIsInVyaVN0cmluZyIsIm9wdGlvbnMiLCJpcmkiLCJyZWZlcmVuY2UiLCJwb3J0IiwiaXNOYU4iLCJpbmRleE9mIiwiZXJyb3IiLCJzY2hlbWVIYW5kbGVyIiwidW5pY29kZVN1cHBvcnQiLCJkb21haW5Ib3N0IiwiX3JlY29tcG9zZUF1dGhvcml0eSIsInVyaVRva2VucyIsIl8iLCIkMSIsIiQyIiwiUkRTMSIsIlJEUzIiLCJSRFMzIiwiUkRTNSIsInJlbW92ZURvdFNlZ21lbnRzIiwiaW0iLCJzIiwiRXJyb3IiLCJzZXJpYWxpemUiLCJhdXRob3JpdHkiLCJjaGFyQXQiLCJhYnNvbHV0ZVBhdGgiLCJyZXNvbHZlQ29tcG9uZW50cyIsInJlbGF0aXZlIiwic2tpcE5vcm1hbGl6YXRpb24iLCJ0b2xlcmFudCIsInJlc29sdmUiLCJiYXNlVVJJIiwicmVsYXRpdmVVUkkiLCJzY2hlbWVsZXNzT3B0aW9ucyIsIm5vcm1hbGl6ZSIsInVyaSIsImVxdWFsIiwidXJpQSIsInVyaUIiLCJlc2NhcGVDb21wb25lbnQiLCJ1bmVzY2FwZUNvbXBvbmVudCIsImhhbmRsZXIiLCJzZWN1cmUiLCJoYW5kbGVyJDEiLCJpc1NlY3VyZSIsIndzQ29tcG9uZW50cyIsImhhbmRsZXIkMiIsInJlc291cmNlTmFtZSIsIl93c0NvbXBvbmVudHMkcmVzb3VyYyIsIl93c0NvbXBvbmVudHMkcmVzb3VyYzIiLCJoYW5kbGVyJDMiLCJPIiwiQVRFWFQkJCIsIlFURVhUJCQiLCJWQ0hBUiQkIiwiU09NRV9ERUxJTVMkJCIsIk5PVF9MT0NBTF9QQVJUIiwiTk9UX0hGTkFNRSIsIk5PVF9IRlZBTFVFIiwiaGFuZGxlciQ0IiwicGFyc2UkJDEiLCJtYWlsdG9Db21wb25lbnRzIiwidG8iLCJ1bmtub3duSGVhZGVycyIsImhlYWRlcnMiLCJoZmllbGRzIiwiaGZpZWxkIiwidG9BZGRycyIsIl94IiwiX3hsIiwic3ViamVjdCIsImJvZHkiLCJfeDIiLCJfeGwyIiwiYWRkciIsInNlcmlhbGl6ZSQkMSIsInRvQWRkciIsImF0SWR4IiwibG9jYWxQYXJ0IiwiZG9tYWluIiwibmFtZSIsIlVSTl9QQVJTRSIsImhhbmRsZXIkNSIsInVybkNvbXBvbmVudHMiLCJuaWQiLCJuc3MiLCJ1cm5TY2hlbWUiLCJ1cmlDb21wb25lbnRzIiwiVVVJRCIsImhhbmRsZXIkNiIsInV1aWRDb21wb25lbnRzIiwidXVpZCIsImRlZmluZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uri-js/dist/es5/uri.all.js\n");

/***/ })

};
;